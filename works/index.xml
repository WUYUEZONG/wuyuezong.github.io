<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Works on a half fish</title><link>/works/</link><description>Recent content in Works on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Sun, 13 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="/works/index.xml" rel="self" type="application/rss+xml"/><item><title>WZPageViewController</title><link>/works/06/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/06/</guid><description>头文件> 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。</description></item><item><title>封装AI算法升级或切换</title><link>/works/07/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/07/</guid><description>首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。
那么这个时候首先会想到单例，在已有的单例中扩充该功能。
需求点> 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； &amp;hellip; 其他页面优先级不高，暂不考虑 实现> 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息</description></item><item><title>时长云存逻辑梳理优化</title><link>/works/02/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/02/</guid><description>当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。
一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。
至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。
所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。</description></item><item><title>第三方登陆会请求两次的问题</title><link>/works/05/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/05/</guid><description>通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。</description></item><item><title>简历2022</title><link>/works/resume/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/resume/</guid><description>所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.</description></item><item><title>通过控制线程并发数量来优化首页在多设备情况下的表现</title><link>/works/01/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/01/</guid><description>由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。</description></item><item><title>项目定制优化</title><link>/works/03/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/03/</guid><description>我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….</description></item><item><title>首页替换第三方组件为系统组件</title><link>/works/04/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/04/</guid><description>在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。</description></item></channel></rss>