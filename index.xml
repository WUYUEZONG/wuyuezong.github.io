<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WUYUEZONG on a half fish</title><link>/</link><description>Recent content in WUYUEZONG on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Wed, 16 Nov 2022 10:42:43 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>片刻</title><link>/posts/moments/</link><pubDate>Wed, 16 Nov 2022 10:42:43 +0800</pubDate><guid>/posts/moments/</guid><description>片刻所想，可以简单，又或者囫囵，都可以被记忆</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/posts/moments/featured.jpg"/></item><item><title>关于潮州特斯拉车主11月05日2死3伤的看法</title><link>/posts/tsl-event-1105/</link><pubDate>Tue, 15 Nov 2022 09:11:53 +0800</pubDate><guid>/posts/tsl-event-1105/</guid><description>特斯拉一直是我比较看好的品牌，它创新，开创，激进鲜明的个性，典型的一个有干劲的&amp;quot;年轻人&amp;quot;， 从一开始就收割了一票追从者，也包括我。车的设计造型也刚好长在我审美点上。虽然都是是毛坯房，但这种简约仍然是一种受众方向，以及独创的中控大屏，当时来看真是让人耳目一新，试图改变人与车的交互方式，事实证明这方面它做到了，现在大家都爱大屏😄。
回归正题
我很纳闷为什么大家的焦点都放在刹车失灵，这次的现象我看到的是，车主想停，并且速度也降得差不多要停了，突然，又驶回马路，并发了疯一样的加速。整个过程，我很难想象车主会出于何种目的才会做这样疯狂的事情，首先这样报复社会的行为需要付出多严重的法律后果就不用说了，买了Model Y，并且家里还有店铺，我想也是个殷实的家庭。那为什么要疯狂加速汽车？汽车故障是我能想到的唯一解释，软件程序虽然是死的，但是环境因素是变的，程序交付到用户去使用，总会有这样那样的BUG。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/posts/tsl-event-1105/featured.jpg"/></item><item><title>Link and Symbol</title><link>/ios/link-and-symbol/</link><pubDate>Mon, 14 Nov 2022 17:45:43 +0800</pubDate><guid>/ios/link-and-symbol/</guid><description>Mach-O> Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。</description></item><item><title>High Performance Autolayout</title><link>/ios/high-performance-autolayout/</link><pubDate>Mon, 14 Nov 2022 17:44:45 +0800</pubDate><guid>/ios/high-performance-autolayout/</guid><description>以下是看完 WWDC18: High Performance Auto Layout 的简单总结。</description></item><item><title>Target-Action组件化方案CTMediator</title><link>/ios/center-core-mode/</link><pubDate>Mon, 14 Nov 2022 17:43:24 +0800</pubDate><guid>/ios/center-core-mode/</guid><description> 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤> 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处> 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方> 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多&amp;hellip;</description></item><item><title>Authentication Biometrics</title><link>/ios/authentication-biometrics/</link><pubDate>Mon, 14 Nov 2022 17:40:27 +0800</pubDate><guid>/ios/authentication-biometrics/</guid><description>事前准备> 事前准备 # 添加权限请求描述: e.g. &amp;ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者&amp;rdquo;</description></item><item><title>Togged Pointer</title><link>/oc/togged-pointer/</link><pubDate>Mon, 14 Nov 2022 16:17:51 +0800</pubDate><guid>/oc/togged-pointer/</guid><description>对 NSNumber、NSString、NSDate 优化。
当以上类型对象需要存储的数据没有超出固定分配的字节，该对象可以被看作是简单数据类型；而当对象需要存储的数据超过了固定字节，该对象就会变成真正的对象。</description></item><item><title>Keywords</title><link>/oc/keywords/</link><pubDate>Mon, 14 Nov 2022 16:16:52 +0800</pubDate><guid>/oc/keywords/</guid><description>strong / weak / copy(ARC环境)</description></item><item><title>Runloop</title><link>/oc/runloop/</link><pubDate>Mon, 14 Nov 2022 16:12:19 +0800</pubDate><guid>/oc/runloop/</guid><description>RunLoop的简介、作用> RunLoop的简介、作用 # 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 RunLoop可以简单理解为，让程序保持运行的一个while循环，这个循环内监听各种事件（如触摸事件、performSelector、定时器NSTimer等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）</description></item><item><title>Objc Instance</title><link>/oc/objc-instance/</link><pubDate>Mon, 14 Nov 2022 16:10:35 +0800</pubDate><guid>/oc/objc-instance/</guid><description>oc对象 在内存中存储的东西 instance isa, _property(value) class isa, property, function, protocol, _property, superclass meta-class isa, superclass, class function instance对象（实例对象）> instance对象（实例对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; instance对象在内存中存储的信息包括> instance对象在内存中存储的信息包括 # isa指针 其他成员变量（这里指的是变量的值，比如变量age = 4，存储这个4) class对象（类对象）> class对象（类对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; // objClass1 ~ objClass5 都是NSObject的class对象（类对象） // 他们是同一个对象，每个类在内存中有且只有一个class对象 Class objClass1 = [obj1 class]; Class objClass2 = [obj2 class]; Class objClass3 = [NSObject class]; Class objClass4 = object_getClass(obj1); Class objClass5 = object_getClass(obj2); class对象在内存中存储的信息包括> class对象在内存中存储的信息包括 # isa指针 superclass指针 类的属性信息（@property）、类的对象方法信息（instance method） 类的协议信息（protocol）、类的成员变量信息（ivar，这里主要是变量名不会发生改变的信息，变量类型） meta-class对象（元类对象）> meta-class对象（元类对象） # // objMetaClass 是NSObject的meta-class对象（元类对象） // 每个类在内存中有且只有一个meta-class对象 Class objMetaClass = object_getClass([NSObject class]); // runtime api meta-class对象和class对象的内存结构是一样的，只是用途不一样> meta-class对象和class对象的内存结构是一样的，只是用途不一样 # isa指针 superclass指针 类的类方法信息（class method） &amp;hellip; 注意> 注意 # //objectClass是class对象，并不是meta-class对象 Class objClass = [[NSObject class] class]; // 查看Class是否是meta-class #import &amp;lt;objc/runtime.</description></item><item><title>Objective-C的本质</title><link>/oc/objc/</link><pubDate>Mon, 14 Nov 2022 16:09:26 +0800</pubDate><guid>/oc/objc/</guid><description>Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。 Objective-C被翻译的过程 graph LR; A[OC]-->B[C\C++]; B-->C[汇编语言]; C-->D[机器语言] Objective-C代码转换为C、C++代码</description></item><item><title>KVO (Key-Value Observing)</title><link>/oc/kvo/</link><pubDate>Mon, 14 Nov 2022 16:08:48 +0800</pubDate><guid>/oc/kvo/</guid><description>KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 可以用于监听某个对象属性值的改
// 如何设置属性的KVO @property (nonatomic, strong) Person *person1; - (void)viewDidLoad { [super viewDidLoad]; _person1 = [[Person alloc] init]; _person1.</description></item><item><title>KVC (Key-Value Coding)</title><link>/oc/kvc/</link><pubDate>Mon, 14 Nov 2022 16:08:03 +0800</pubDate><guid>/oc/kvc/</guid><description>KVC主要方法> KVC主要方法 # - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (id)valueForKey:(NSString *)key; setValue: forKey: 的原理> setValue: forKey: 的原理 # valueForKey: 的原理> valueForKey: 的原理 # 使用KVC修改是否会触发KVO？（设置了监听）> 使用KVC修改是否会触发KVO？（设置了监听） # 使用KVC，不管是修改成员变量还是属性的值都会触发KVO。</description></item><item><title>Isa</title><link>/oc/isa/</link><pubDate>Mon, 14 Nov 2022 16:07:25 +0800</pubDate><guid>/oc/isa/</guid><description>oc为什么要存在isa> oc为什么要存在isa # isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。</description></item><item><title>Copy &amp; MutableCopy</title><link>/oc/copy-mutablecopy/</link><pubDate>Mon, 14 Nov 2022 16:06:23 +0800</pubDate><guid>/oc/copy-mutablecopy/</guid><description> copy 是复制出不可变对象 mutableCopy 是复制出可变对象； 复制出来的对象互不影响。 copy 复制不可变对象属于浅拷贝（浅拷贝就只是地址拷贝） copy 复制可变对象属于深拷贝（需要复制出一份不可变对象，以免之前可变对象变更影响复制出来的对象） mutableCopy 属于深拷贝（重新申请一份内存和指针） - (void)viewDidLoad { [super viewDidLoad]; NSArray * arr = @[@1, @2]; NSArray *arrCopy = [arr copy]; NSMutableArray * arrMCopy = [arr mutableCopy]; [arrMCopy addObject:@3]; NSLog(@&amp;#34;%p, %p, %p&amp;#34;, arr, arrCopy, arrMCopy); NSMutableArray * marr = [NSMutableArray arrayWithArray:arr]; NSArray *marrCopy = [marr copy]; NSMutableArray * marrMCopy = [marr mutableCopy]; NSLog(@&amp;#34;%p, %p, %p&amp;#34;, marr, marrCopy, marrMCopy); } copy mutableCopy NSString NSString NSMutableString NSMutableString NSString NSMutableString NSArray NSArray NSMutableArray NSMutableArray NSArray NSMutableArray NSDictionary NSDictionary NSMutableDictionary NSMutableDictionary NSDictionary NSMutableDictionary</description></item><item><title>Category</title><link>/oc/category/</link><pubDate>Mon, 14 Nov 2022 14:48:46 +0800</pubDate><guid>/oc/category/</guid><description>category定义在objc-runtime-new.h中，结构如下：
所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点> 知识点 # 后编译的先调用> 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。</description></item><item><title>Notes: 碎片笔记本使用手册</title><link>/apps/notes/</link><pubDate>Sun, 13 Nov 2022 20:55:37 +0100</pubDate><guid>/apps/notes/</guid><description>碎片笔记本，简单的记个笔记～</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/apps/notes/featured.png"/></item><item><title>Upaper: 高清壁纸</title><link>/apps/upaper/</link><pubDate>Sun, 13 Nov 2022 20:55:37 +0100</pubDate><guid>/apps/upaper/</guid><description>方便简单的找到一个壁纸～</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/apps/upaper/featured.png"/></item><item><title>WZPageViewController</title><link>/works/06/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/06/</guid><description>头文件> 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/06/featured.jpg"/></item><item><title>封装AI算法升级或切换</title><link>/works/07/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/07/</guid><description>首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。
那么这个时候首先会想到单例，在已有的单例中扩充该功能。
需求点> 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； &amp;hellip; 其他页面优先级不高，暂不考虑 实现> 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/07/featured.jpg"/></item><item><title>时长云存逻辑梳理优化</title><link>/works/02/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/02/</guid><description>当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。
一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。
至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。
所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。</description></item><item><title>第三方登陆会请求两次的问题</title><link>/works/05/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/05/</guid><description>通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。</description></item><item><title>简历2022</title><link>/works/resume/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/resume/</guid><description>所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/resume/featured.jpg"/></item><item><title>通过控制线程并发数量来优化首页在多设备情况下的表现</title><link>/works/01/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/01/</guid><description>由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。</description></item><item><title>项目定制优化</title><link>/works/03/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/03/</guid><description>我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….</description></item><item><title>首页替换第三方组件为系统组件</title><link>/works/04/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/04/</guid><description>在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。</description></item><item><title>@synthesize, @dynamic</title><link>/oc/synthesize-dynamic/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/synthesize-dynamic/</guid><description>@synthesize是给属性添加别名，并生成get、set方法（默认使用）
@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.</description></item><item><title>+initialize</title><link>/oc/initialize/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/initialize/</guid><description>initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序> initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码> initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !</description></item><item><title>+load</title><link>/oc/load/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/load/</guid><description>+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序> load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）> 阅读源码（objc4） # objc-os.</description></item><item><title>AssociationObject</title><link>/oc/association-object/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/association-object/</guid><description>AssociationObject关联对象的原理> AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有
AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap&amp;gt; class ObjectAssociationMap: public std::map&amp;lt;void *, ObjcAssociationMap&amp;gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构> 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用> AssociationObject关联对象的使用 # 关联对象常用API> 关联对象常用API # 添加关联对象</description></item><item><title>AutoreleasePool</title><link>/oc/autorelease-pool/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/autorelease-pool/</guid><description>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构> AutoreleasePoolPage内部结构 # 每个 AutoreleasePoolPage 对象占用 4096 字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 autorelease 对象的地址 所有的 AutoreleasePoolPage 对象通过双向链表的形式连接在一起 @autoreleasepool作用原理> @autoreleasepool作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。</description></item><item><title>Block</title><link>/oc/block/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/block/</guid><description>Block的本质> Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。
block的底层结构> block的底层结构 # block的变量捕获（capture）> block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</description></item><item><title>iOS签名机制</title><link>/ios/ios-signing/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/ios/ios-signing/</guid><description>要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。
在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密
加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。
非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。</description></item><item><title>pthread / NSThread</title><link>/ios/pthred-nsthread/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/ios/pthred-nsthread/</guid><description>pthread> pthread # 导入头文件> 导入头文件 # #import &amp;lt;pthread.</description></item><item><title>React Native Flexbox</title><link>/rn/flex-layout/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/rn/flex-layout/</guid><description>这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。
推荐阅读官网 “使用Flexbox布局”
Flex> Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。</description></item><item><title>安装包瘦身</title><link>/oc/ipa/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/ipa/</guid><description>资源（图片、音频、视频等）> 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.</description></item><item><title>定时器</title><link>/oc/nstimer/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/nstimer/</guid><description>NSTimer、CADisplayLink定时器> NSTimer、CADisplayLink定时器 # CADisplayLink使用
@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用</description></item><item><title>性能优化</title><link>/oc/performance-optimization/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/performance-optimization/</guid><description>在屏幕成像的过程中，CPU和GPU起着至关重要的作用
查看详情 CPU和GPU> CPU和GPU # CPU（Central Processing Unit，中央处理器）</description></item><item><title>探究UIViewController生命周期</title><link>/oc/uiviewcontroller-life-cycle/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/uiviewcontroller-life-cycle/</guid><description>进入 ViewController2
+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController</description></item><item><title>数据持久化、缓存</title><link>/oc/data-store/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/data-store/</guid><description>首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。
应用沙盒文件夹> 应用沙盒文件夹 # Application（应用程序包）: 包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。</description></item><item><title>App Lanuch</title><link>/oc/app-lanuch/</link><pubDate>Mon, 13 Jun 2022 20:55:37 +0100</pubDate><guid>/oc/app-lanuch/</guid><description>APP启动的分类> APP启动的分类 # 冷启动> 冷启动 # 冷启动（Cold Launch）：从零开始启动APP</description></item></channel></rss>