<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WUYUEZONG on a half fish</title><link>/</link><description>Recent content in WUYUEZONG on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Mon, 14 Nov 2022 17:45:43 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Link and Symbol</title><link>/posts/link-and-symbol/</link><pubDate>Mon, 14 Nov 2022 17:45:43 +0800</pubDate><guid>/posts/link-and-symbol/</guid><description>Mach-O> Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。</description></item><item><title>High Performance Autolayout</title><link>/posts/high-performance-autolayout/</link><pubDate>Mon, 14 Nov 2022 17:44:45 +0800</pubDate><guid>/posts/high-performance-autolayout/</guid><description>以下是看完 WWDC18: High Performance Auto Layout 的简单总结。</description></item><item><title>Target-Action组件化方案CTMediator</title><link>/posts/center-core-mode/</link><pubDate>Mon, 14 Nov 2022 17:43:24 +0800</pubDate><guid>/posts/center-core-mode/</guid><description> 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤> 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处> 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方> 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多&amp;hellip;</description></item><item><title>Authentication Biometrics</title><link>/posts/authentication-biometrics/</link><pubDate>Mon, 14 Nov 2022 17:40:27 +0800</pubDate><guid>/posts/authentication-biometrics/</guid><description>事前准备> 事前准备 # 添加权限请求描述: e.g. &amp;ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者&amp;rdquo;</description></item><item><title>Runloop</title><link>/posts/oc/runloop/</link><pubDate>Mon, 14 Nov 2022 16:12:19 +0800</pubDate><guid>/posts/oc/runloop/</guid><description>参考阅读> 参考阅读 # 理解 OC 中 RunLoop</description></item><item><title>Category</title><link>/posts/oc/category/</link><pubDate>Mon, 14 Nov 2022 14:48:46 +0800</pubDate><guid>/posts/oc/category/</guid><description>category定义在objc-runtime-new.h中，结构如下：
所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点> 知识点 # 后编译的先调用> 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。</description></item><item><title>Notes: 碎片笔记本使用手册</title><link>/apps/notes/</link><pubDate>Sun, 13 Nov 2022 20:55:37 +0100</pubDate><guid>/apps/notes/</guid><description>碎片笔记本，简单的记个笔记～</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/apps/notes/featured.png"/></item><item><title>Upaper: 高清壁纸</title><link>/apps/upaper/</link><pubDate>Sun, 13 Nov 2022 20:55:37 +0100</pubDate><guid>/apps/upaper/</guid><description>方便简单的找到一个壁纸～</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/apps/upaper/featured.png"/></item><item><title>WZPageViewController</title><link>/works/06/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/06/</guid><description>头文件> 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/06/featured.jpg"/></item><item><title>封装AI算法升级或切换</title><link>/works/07/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/07/</guid><description>首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。
那么这个时候首先会想到单例，在已有的单例中扩充该功能。
需求点> 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； &amp;hellip; 其他页面优先级不高，暂不考虑 实现> 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/07/featured.jpg"/></item><item><title>时长云存逻辑梳理优化</title><link>/works/02/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/02/</guid><description>当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。 一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。 至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。 所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。 另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。 想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。</description></item><item><title>第三方登陆会请求两次的问题</title><link>/works/05/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/05/</guid><description>通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。</description></item><item><title>简历2022</title><link>/works/resume/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/resume/</guid><description>所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="/works/resume/featured.jpg"/></item><item><title>通过控制线程并发数量来优化首页在多设备情况下的表现</title><link>/works/01/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/01/</guid><description>由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。</description></item><item><title>项目定制优化</title><link>/works/03/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/03/</guid><description>我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….</description></item><item><title>首页替换第三方组件为系统组件</title><link>/works/04/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/04/</guid><description>在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。</description></item><item><title>@synthesize, @dynamic</title><link>/posts/oc/synthesize-dynamic/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/synthesize-dynamic/</guid><description>@synthesize是给属性添加别名，并生成get、set方法（默认使用）
@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.</description></item><item><title>+initialize</title><link>/posts/oc/initialize/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/initialize/</guid><description>initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序> initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码> initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !</description></item><item><title>+load方法</title><link>/posts/oc/load/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/load/</guid><description>+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序> load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）> 阅读源码（objc4） # objc-os.</description></item><item><title>AssociationObject关联对象</title><link>/posts/oc/association-object/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/association-object/</guid><description>AssociationObject关联对象的原理> AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有
AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap&amp;gt; class ObjectAssociationMap: public std::map&amp;lt;void *, ObjcAssociationMap&amp;gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构> 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用> AssociationObject关联对象的使用 # 关联对象常用API> 关联对象常用API # 添加关联对象</description></item><item><title>AutoreleasePool</title><link>/posts/oc/autorelease-pool/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/autorelease-pool/</guid><description>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构> AutoreleasePoolPage内部结构 # 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址 所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起 @autoreleasepool 作用原理> @autoreleasepool 作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。</description></item><item><title>Block</title><link>/posts/oc/block/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/block/</guid><description>Block的本质> Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。
block的底层结构> block的底层结构 # block的变量捕获（capture）> block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</description></item><item><title>iOS Runloop</title><link>/posts/runloop/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/runloop/</guid><description>整理中&amp;hellip;> 整理中&amp;hellip; # RunLoop与线程> RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。</description></item><item><title>iOS签名机制</title><link>/posts/ios-signing/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/ios-signing/</guid><description>要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。
在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密
加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。
非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。</description></item><item><title>pthread / NSThread</title><link>/posts/pthred-nsthread/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/pthred-nsthread/</guid><description>pthread> pthread # 导入头文件> 导入头文件 # #import &amp;lt;pthread.</description></item><item><title>React Native Flexbox</title><link>/posts/rn-flex-layout/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/rn-flex-layout/</guid><description>这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。
推荐阅读官网 “使用Flexbox布局”
Flex> Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。</description></item><item><title>安装包瘦身</title><link>/posts/oc/ipa/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/ipa/</guid><description>资源（图片、音频、视频等）> 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.</description></item><item><title>定时器</title><link>/posts/oc/nstimer/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/nstimer/</guid><description>NSTimer、CADisplayLink定时器> NSTimer、CADisplayLink定时器 # CADisplayLink使用
@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用</description></item><item><title>性能优化</title><link>/posts/oc/performance-optimization/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/performance-optimization/</guid><description>在屏幕成像的过程中，CPU和GPU起着至关重要的作用
查看详情 CPU和GPU> CPU和GPU # CPU（Central Processing Unit，中央处理器）</description></item><item><title>探究UIViewController生命周期</title><link>/posts/oc/uiviewcontroller-life-cycle/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/uiviewcontroller-life-cycle/</guid><description>进入 ViewController2
+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController</description></item><item><title>数据持久化、缓存</title><link>/posts/oc/data-store/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/data-store/</guid><description>首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。
应用沙盒文件夹> 应用沙盒文件夹 # Application（应用程序包）：包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。</description></item><item><title>APP启动</title><link>/posts/oc/app-lanuch/</link><pubDate>Mon, 13 Jun 2022 20:55:37 +0100</pubDate><guid>/posts/oc/app-lanuch/</guid><description>APP启动的分类> APP启动的分类 # 冷启动> 冷启动 # 冷启动（Cold Launch）：从零开始启动APP</description></item></channel></rss>