<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Objc on a half fish</title><link>/series/objc/</link><description>Recent content in Objc on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Mon, 14 Nov 2022 16:17:51 +0800</lastBuildDate><atom:link href="/series/objc/index.xml" rel="self" type="application/rss+xml"/><item><title>Togged Pointer</title><link>/oc/togged-pointer/</link><pubDate>Mon, 14 Nov 2022 16:17:51 +0800</pubDate><guid>/oc/togged-pointer/</guid><description>对 &lt;code>NSNumber、NSString、NSDate&lt;/code> 优化。</description></item><item><title>Keywords</title><link>/oc/keywords/</link><pubDate>Mon, 14 Nov 2022 16:16:52 +0800</pubDate><guid>/oc/keywords/</guid><description>Automatic Reference Counting(ARC)技术是用于OC对象的内存管理。即在适当的时候对OC对象retain和release操作。</description></item><item><title>Runloop</title><link>/oc/runloop/</link><pubDate>Mon, 14 Nov 2022 16:12:19 +0800</pubDate><guid>/oc/runloop/</guid><description>&lt;code>RunLoop&lt;/code>可以简单理解为，让程序保持运行的一个&lt;code>while&lt;/code>循环，这个循环内监听各种事件（如触摸事件、&lt;code>performSelector&lt;/code>、定时器&lt;code>NSTimer&lt;/code>等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）</description></item><item><title>Objc Instance</title><link>/oc/objc-instance/</link><pubDate>Mon, 14 Nov 2022 16:10:35 +0800</pubDate><guid>/oc/objc-instance/</guid><description>实例对象、类对象、元类对象（Instance Class Meta-Class）</description></item><item><title>Objective-C的本质</title><link>/oc/objc/</link><pubDate>Mon, 14 Nov 2022 16:09:26 +0800</pubDate><guid>/oc/objc/</guid><description>Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。</description></item><item><title>KVO (Key-Value Observing)</title><link>/oc/kvo/</link><pubDate>Mon, 14 Nov 2022 16:08:48 +0800</pubDate><guid>/oc/kvo/</guid><description>KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。</description></item><item><title>KVC (Key-Value Coding)</title><link>/oc/kvc/</link><pubDate>Mon, 14 Nov 2022 16:08:03 +0800</pubDate><guid>/oc/kvc/</guid><description>使用KVC，不管是修改成员变量还是属性的值都会触发KVO。</description></item><item><title>Isa</title><link>/oc/isa/</link><pubDate>Mon, 14 Nov 2022 16:07:25 +0800</pubDate><guid>/oc/isa/</guid><description>isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。</description></item><item><title>Copy &amp; MutableCopy</title><link>/oc/copy-mutablecopy/</link><pubDate>Mon, 14 Nov 2022 16:06:23 +0800</pubDate><guid>/oc/copy-mutablecopy/</guid><description>Copy &amp;amp; MutableCopy / 浅拷贝和深拷贝的解释</description></item><item><title>Category</title><link>/oc/category/</link><pubDate>Mon, 14 Nov 2022 14:48:46 +0800</pubDate><guid>/oc/category/</guid><description>所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 &lt;code>class&lt;/code> 对象中一样的数据类型，只使用了新的变量存储。在 &lt;code>runtime&lt;/code>时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（&lt;code>isa&lt;/code>）。</description></item><item><title>+initialize</title><link>/oc/initialize/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/initialize/</guid><description>initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。</description></item><item><title>+load</title><link>/oc/load/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/load/</guid><description>+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。</description></item><item><title>AssociationObject</title><link>/oc/association-object/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/association-object/</guid><description>关联对象的原理与使用</description></item><item><title>AutoreleasePool</title><link>/oc/autorelease-pool/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/autorelease-pool/</guid><description>自动释放池的原理与使用</description></item><item><title>Block</title><link>/oc/block/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/block/</guid><description>&lt;code>block&lt;/code>本质上也是一个OC对象，它内部也有个&lt;code>isa指针&lt;/code>，&lt;code>block&lt;/code>是封装了函数调用以及函数调用环境的OC对象。</description></item><item><title>安装包瘦身</title><link>/oc/ipa/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/ipa/</guid><description>安装包瘦身</description></item><item><title>定时器</title><link>/oc/nstimer/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/nstimer/</guid><description>NSTimer、CADisplayLink定时器</description></item><item><title>数据持久化、缓存</title><link>/oc/data-store/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/data-store/</guid><description>首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。</description></item><item><title>App Lanuch</title><link>/oc/app-lanuch/</link><pubDate>Mon, 13 Jun 2022 20:55:37 +0100</pubDate><guid>/oc/app-lanuch/</guid><description>APP启动介绍与优化</description></item></channel></rss>