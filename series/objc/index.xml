<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Objc on a half fish</title><link>/series/objc/</link><description>Recent content in Objc on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Mon, 14 Nov 2022 16:17:51 +0800</lastBuildDate><atom:link href="/series/objc/index.xml" rel="self" type="application/rss+xml"/><item><title>Togged Pointer</title><link>/oc/togged-pointer/</link><pubDate>Mon, 14 Nov 2022 16:17:51 +0800</pubDate><guid>/oc/togged-pointer/</guid><description>对 NSNumber、NSString、NSDate 优化。
当以上类型对象需要存储的数据没有超出固定分配的字节，该对象可以被看作是简单数据类型；而当对象需要存储的数据超过了固定字节，该对象就会变成真正的对象。</description></item><item><title>Keywords</title><link>/oc/keywords/</link><pubDate>Mon, 14 Nov 2022 16:16:52 +0800</pubDate><guid>/oc/keywords/</guid><description>strong / weak / copy(ARC环境)</description></item><item><title>Runloop</title><link>/oc/runloop/</link><pubDate>Mon, 14 Nov 2022 16:12:19 +0800</pubDate><guid>/oc/runloop/</guid><description>RunLoop的简介、作用> RunLoop的简介、作用 # 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 RunLoop可以简单理解为，让程序保持运行的一个while循环，这个循环内监听各种事件（如触摸事件、performSelector、定时器NSTimer等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）</description></item><item><title>Objc Instance</title><link>/oc/objc-instance/</link><pubDate>Mon, 14 Nov 2022 16:10:35 +0800</pubDate><guid>/oc/objc-instance/</guid><description>oc对象 在内存中存储的东西 instance isa, _property(value) class isa, property, function, protocol, _property, superclass meta-class isa, superclass, class function instance对象（实例对象）> instance对象（实例对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; instance对象在内存中存储的信息包括> instance对象在内存中存储的信息包括 # isa指针 其他成员变量（这里指的是变量的值，比如变量age = 4，存储这个4) class对象（类对象）> class对象（类对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; // objClass1 ~ objClass5 都是NSObject的class对象（类对象） // 他们是同一个对象，每个类在内存中有且只有一个class对象 Class objClass1 = [obj1 class]; Class objClass2 = [obj2 class]; Class objClass3 = [NSObject class]; Class objClass4 = object_getClass(obj1); Class objClass5 = object_getClass(obj2); class对象在内存中存储的信息包括> class对象在内存中存储的信息包括 # isa指针 superclass指针 类的属性信息（@property）、类的对象方法信息（instance method） 类的协议信息（protocol）、类的成员变量信息（ivar，这里主要是变量名不会发生改变的信息，变量类型） meta-class对象（元类对象）> meta-class对象（元类对象） # // objMetaClass 是NSObject的meta-class对象（元类对象） // 每个类在内存中有且只有一个meta-class对象 Class objMetaClass = object_getClass([NSObject class]); // runtime api meta-class对象和class对象的内存结构是一样的，只是用途不一样> meta-class对象和class对象的内存结构是一样的，只是用途不一样 # isa指针 superclass指针 类的类方法信息（class method） &amp;hellip; 注意> 注意 # //objectClass是class对象，并不是meta-class对象 Class objClass = [[NSObject class] class]; // 查看Class是否是meta-class #import &amp;lt;objc/runtime.</description></item><item><title>Objective-C的本质</title><link>/oc/objc/</link><pubDate>Mon, 14 Nov 2022 16:09:26 +0800</pubDate><guid>/oc/objc/</guid><description>Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。 Objective-C被翻译的过程 graph LR; A[OC]-->B[C\C++]; B-->C[汇编语言]; C-->D[机器语言] Objective-C代码转换为C、C++代码</description></item><item><title>KVO (Key-Value Observing)</title><link>/oc/kvo/</link><pubDate>Mon, 14 Nov 2022 16:08:48 +0800</pubDate><guid>/oc/kvo/</guid><description>KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 可以用于监听某个对象属性值的改
// 如何设置属性的KVO @property (nonatomic, strong) Person *person1; - (void)viewDidLoad { [super viewDidLoad]; _person1 = [[Person alloc] init]; _person1.</description></item><item><title>KVC (Key-Value Coding)</title><link>/oc/kvc/</link><pubDate>Mon, 14 Nov 2022 16:08:03 +0800</pubDate><guid>/oc/kvc/</guid><description>KVC主要方法> KVC主要方法 # - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (id)valueForKey:(NSString *)key; setValue: forKey: 的原理> setValue: forKey: 的原理 # valueForKey: 的原理> valueForKey: 的原理 # 使用KVC修改是否会触发KVO？（设置了监听）> 使用KVC修改是否会触发KVO？（设置了监听） # 使用KVC，不管是修改成员变量还是属性的值都会触发KVO。</description></item><item><title>Isa</title><link>/oc/isa/</link><pubDate>Mon, 14 Nov 2022 16:07:25 +0800</pubDate><guid>/oc/isa/</guid><description>oc为什么要存在isa> oc为什么要存在isa # isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。</description></item><item><title>Copy &amp; MutableCopy</title><link>/oc/copy-mutablecopy/</link><pubDate>Mon, 14 Nov 2022 16:06:23 +0800</pubDate><guid>/oc/copy-mutablecopy/</guid><description> copy 是复制出不可变对象 mutableCopy 是复制出可变对象； 复制出来的对象互不影响。 copy 复制不可变对象属于浅拷贝（浅拷贝就只是地址拷贝） copy 复制可变对象属于深拷贝（需要复制出一份不可变对象，以免之前可变对象变更影响复制出来的对象） mutableCopy 属于深拷贝（重新申请一份内存和指针） - (void)viewDidLoad { [super viewDidLoad]; NSArray * arr = @[@1, @2]; NSArray *arrCopy = [arr copy]; NSMutableArray * arrMCopy = [arr mutableCopy]; [arrMCopy addObject:@3]; NSLog(@&amp;#34;%p, %p, %p&amp;#34;, arr, arrCopy, arrMCopy); NSMutableArray * marr = [NSMutableArray arrayWithArray:arr]; NSArray *marrCopy = [marr copy]; NSMutableArray * marrMCopy = [marr mutableCopy]; NSLog(@&amp;#34;%p, %p, %p&amp;#34;, marr, marrCopy, marrMCopy); } copy mutableCopy NSString NSString NSMutableString NSMutableString NSString NSMutableString NSArray NSArray NSMutableArray NSMutableArray NSArray NSMutableArray NSDictionary NSDictionary NSMutableDictionary NSMutableDictionary NSDictionary NSMutableDictionary</description></item><item><title>Category</title><link>/oc/category/</link><pubDate>Mon, 14 Nov 2022 14:48:46 +0800</pubDate><guid>/oc/category/</guid><description>category定义在objc-runtime-new.h中，结构如下：
所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点> 知识点 # 后编译的先调用> 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。</description></item><item><title>+initialize</title><link>/oc/initialize/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/initialize/</guid><description>initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序> initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码> initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !</description></item><item><title>+load</title><link>/oc/load/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/load/</guid><description>+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序> load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）> 阅读源码（objc4） # objc-os.</description></item><item><title>AssociationObject</title><link>/oc/association-object/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/association-object/</guid><description>AssociationObject关联对象的原理> AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有
AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap&amp;gt; class ObjectAssociationMap: public std::map&amp;lt;void *, ObjcAssociationMap&amp;gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构> 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用> AssociationObject关联对象的使用 # 关联对象常用API> 关联对象常用API # 添加关联对象</description></item><item><title>AutoreleasePool</title><link>/oc/autorelease-pool/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/autorelease-pool/</guid><description>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构> AutoreleasePoolPage内部结构 # 每个 AutoreleasePoolPage 对象占用 4096 字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 autorelease 对象的地址 所有的 AutoreleasePoolPage 对象通过双向链表的形式连接在一起 @autoreleasepool作用原理> @autoreleasepool作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。</description></item><item><title>Block</title><link>/oc/block/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/block/</guid><description>Block的本质> Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。
block的底层结构> block的底层结构 # block的变量捕获（capture）> block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</description></item><item><title>安装包瘦身</title><link>/oc/ipa/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/ipa/</guid><description>资源（图片、音频、视频等）> 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.</description></item><item><title>定时器</title><link>/oc/nstimer/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/nstimer/</guid><description>NSTimer、CADisplayLink定时器> NSTimer、CADisplayLink定时器 # CADisplayLink使用
@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用</description></item><item><title>数据持久化、缓存</title><link>/oc/data-store/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/oc/data-store/</guid><description>首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。
应用沙盒文件夹> 应用沙盒文件夹 # Application（应用程序包）: 包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。</description></item><item><title>App Lanuch</title><link>/oc/app-lanuch/</link><pubDate>Mon, 13 Jun 2022 20:55:37 +0100</pubDate><guid>/oc/app-lanuch/</guid><description>APP启动的分类> APP启动的分类 # 冷启动> 冷启动 # 冷启动（Cold Launch）：从零开始启动APP</description></item></channel></rss>