<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IOS on a half fish</title><link>/series/ios/</link><description>Recent content in IOS on a half fish</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 30 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="/series/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>iOS Runloop</title><link>/posts/runloop/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/runloop/</guid><description>整理中&amp;hellip;> 整理中&amp;hellip; # RunLoop与线程> RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。
void const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。</description></item><item><title>iOS签名机制</title><link>/posts/ios-signing/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/ios-signing/</guid><description>要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。
在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密
加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。
非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。
公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？
混合密码系统(Hybrid Cryptosystem)> 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。
单向散列函数> 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。
特点
根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）</description></item><item><title>pthread / NSThread</title><link>/posts/pthred-nsthread/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/pthred-nsthread/</guid><description>pthread> pthread # 导入头文件> 导入头文件 # #import &amp;lt;pthread.h&amp;gt; 创建 pthread_t 对象以及使用> 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(&amp;amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@&amp;#34;%@&amp;#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明</description></item><item><title>Target-Action组件化方案CTMediator</title><link>/posts/center-core-mode/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/center-core-mode/</guid><description> 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤> 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处> 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方> 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多&amp;hellip;</description></item><item><title>生物认证 TouchID/FaceID</title><link>/posts/authentication-biometrics/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/authentication-biometrics/</guid><description>事前准备> 事前准备 # 添加权限请求描述: e.g. &amp;ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者&amp;rdquo;
Privacy - Face ID Usage Description OR
NSFaceIDUsageDescription 引入相关的库
LocalAuthentication 引入头文件
#import &amp;lt;LocalAuthentication/LocalAuthentication.h&amp;gt; 使用> 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.</description></item><item><title>链接与符号 Link&amp;Symbol</title><link>/posts/link-symbol/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/link-symbol/</guid><description>Mach-O> Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。
Mach-O文件的分类
Executable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成> Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)</description></item><item><title>高性能的AutoLayout</title><link>/posts/high-performance-autolayout/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/high-performance-autolayout/</guid><description>以下是看完 WWDC18: High Performance Auto Layout 的简单总结。
避免操作updateConstants()> 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。
func updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系> 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。</description></item></channel></rss>