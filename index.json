[{"content":"","date":"2022-11-16","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平\n","date":"2022-11-16","permalink":"/","section":"WUYUEZONG","summary":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平","title":"WUYUEZONG"},{"content":"","date":"2022-11-16","permalink":"/tags/%E6%80%9D%E8%80%83/","section":"Tags","summary":"","title":"思考"},{"content":"","date":"2022-11-16","permalink":"/tags/%E7%89%87%E5%88%BB/","section":"Tags","summary":"","title":"片刻"},{"content":"片刻，顾名思义这里是片刻，某一刻想起的事情想记录的话，在那一片刻，如果可以，它会被记录在这里。\n2022-11-22\n风口！机会！太想追求这些了。盲目的追求，导致心境浮躁。\n应该每个人都有一个发财梦。\n越来越难，集中精神做一件小事。\n以前以为抖音可以让我更快更方便的了解一些事，现在回想，都是每天重复的东西，而且片面，反而影响个人的专注力，对知识点的系统认知缺乏。需要控制。\n看长文越来越难了。这一点很不好。\n2022-11-21\n一早起来。生气了，奇奇怪怪，像个小孩。\n2022-11-18\n听说老家那边风控了，晚上得打个电话。\n我炒牛肉给你吃！\n吃了！味道可以\n2022-11-17\n那么希望你可以佐证分析，不要看什么就是什么\n希望你知道能接受什么不能接受什么，都要有想法，不是一股脑看啥啥不行，看啥啥喜欢。\n致，思考。\n1\n最近我俩都挺想买车，实际上她比我更想，恨不得立马就有，而我还好，毕竟怎么样都是生活，她知道我喜欢极氪，但可能不是她的意向车型，所以隔三差五给我说极氪的坏消息，我想她大概的意思是：“听我的就好，想什么极氪”。\n有时候觉得她挺聪明的，这种聪明大多像小孩的机灵，令人不知所措，好玩又有点无可奈何。\n无论怎样，没有令人信服的理由是不能赞同的。\n2\n我俩都是大小孩，思考、行为都没有让谁信服，所以会有很多争吵，不过这个争吵也会马上过去，有可能就是下一秒，这么想来似乎有点可笑，感觉像是时间到了要吵，时间到了不吵。😄\non Unsplash 3\n她\n：我好饿呀\n：满脑子吃的东西\n：我怎么这么优秀呢\n2022-11-16\n每天逼自己写点东西，有利于梳理大脑的思维逻辑，长时间训练它可以变得更活跃以及灵敏。\n情绪易怒是自我管理失败。\n我猜测，大脑也有某种肌肉记忆每每出现类似情况时，它会下意识反应出你以前的情绪状态，那么如何预防下次的冲动？我感觉可以去接受更多期望的一面，也是让大脑形成肌肉记忆，让经验控制住它。\n","date":"2022-11-16","permalink":"/posts/moments/","section":"Posts","summary":"片刻所想，可以简单，又或者囫囵，都可以被记忆","title":"片刻"},{"content":"","date":"2022-11-16","permalink":"/tags/%E8%AE%B0%E4%BA%8B/","section":"Tags","summary":"","title":"记事"},{"content":"","date":"2022-11-15","permalink":"/oc/","section":"Objective-C","summary":"学习Objective-C的相关笔记！","title":"Objective-C"},{"content":" Objective-C学习手册，这个是我个人学习OC语言的记录笔记，内容可能有些零散。\n这些就是一点开发中的学习\n","date":"2022-11-15","permalink":"/ios/","section":"IOS","summary":"Objective-C学习手册，这个是我个人学习OC语言的记录笔记，内容可能有些零散。\n这些就是一点开发中的学习","title":"IOS"},{"content":"特斯拉一直是我比较看好的品牌，它创新，开创，激进鲜明的个性，典型的一个有干劲的\u0026quot;年轻人\u0026quot;， 从一开始就收割了一票追从者，也包括我。车的设计造型也刚好长在我审美点上。虽然都是是毛坯房，但这种简约仍然是一种受众方向，以及独创的中控大屏，当时来看真是让人耳目一新，试图改变人与车的交互方式，事实证明这方面它做到了，现在大家都爱大屏😄。\n回归正题\n我很纳闷为什么大家的焦点都放在刹车失灵，这次的现象我看到的是，车主想停，并且速度也降得差不多要停了，突然，又驶回马路，并发了疯一样的加速。整个过程，我很难想象车主会出于何种目的才会做这样疯狂的事情，首先这样报复社会的行为需要付出多严重的法律后果就不用说了，买了Model Y，并且家里还有店铺，我想也是个殷实的家庭。那为什么要疯狂加速汽车？汽车故障是我能想到的唯一解释，软件程序虽然是死的，但是环境因素是变的，程序交付到用户去使用，总会有这样那样的BUG。\n2022-11-16\n道不同不相为谋，思想上的差异真令人头大，你既不能左右他人思想，且不能手段行事，此刻没有宽阔的兼容，只会自讨没趣，学会包容才为上上之策，以对方的角度看待问题，如果发现新的思想，那么是受益的，假若仍是咬牙切齿，深呼吸，平心静气。\n","date":"2022-11-15","permalink":"/posts/tsl-event-1105/","section":"Posts","summary":"特斯拉一直是我比较看好的品牌，它创新，开创，激进鲜明的个性，典型的一个有干劲的\u0026quot;年轻人\u0026quot;， 从一开始就收割了一票追从者，也包括我。车的设计造型也刚好长在我审美点上。虽然都是是毛坯房，但这种简约仍然是一种受众方向，以及独创的中控大屏，当时来看真是让人耳目一新，试图改变人与车的交互方式，事实证明这方面它做到了，现在大家都爱大屏😄。\n回归正题\n我很纳闷为什么大家的焦点都放在刹车失灵，这次的现象我看到的是，车主想停，并且速度也降得差不多要停了，突然，又驶回马路，并发了疯一样的加速。整个过程，我很难想象车主会出于何种目的才会做这样疯狂的事情，首先这样报复社会的行为需要付出多严重的法律后果就不用说了，买了Model Y，并且家里还有店铺，我想也是个殷实的家庭。那为什么要疯狂加速汽车？汽车故障是我能想到的唯一解释，软件程序虽然是死的，但是环境因素是变的，程序交付到用户去使用，总会有这样那样的BUG。","title":"关于潮州特斯拉车主11月05日2死3伤的看法"},{"content":"","date":"2022-11-15","permalink":"/tags/%E6%BD%AE%E5%B7%9E%E7%89%B9%E6%96%AF%E6%8B%89%E8%BD%A6%E4%B8%BB/","section":"Tags","summary":"","title":"潮州特斯拉车主"},{"content":"","date":"2022-11-15","permalink":"/tags/%E7%89%B9%E6%96%AF%E6%8B%89/","section":"Tags","summary":"","title":"特斯拉"},{"content":"","date":"2022-11-15","permalink":"/rn/","section":"React Native","summary":"","title":"React Native"},{"content":"","date":"2022-11-14","permalink":"/tags/ios/","section":"Tags","summary":"","title":"iOS"},{"content":"Mach-O\u003e Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。\nMach-O文件的分类\nExecutable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成\u003e Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)\nHeader\u003e Header # 指明了 CPU 架构、大小端序、文件类型、Load Commands 个数等一些基本信息，Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境，64位架构为例， Header结构定义如下\nstruct mach_header_64 { uint32_t magic; /* mach magic number identifier 魔数，用于快速确认该文件用于64位还是32位 */ cpu_type_t cputype; /* cpu specifier，CPU**类型，比如 arm */ cpu_subtype_t cpusubtype; /* machine specifier，对应的具体类型，比如arm64、armv7 */ uint32_t filetype; /* type of file，文件类型，比如可执行文件、库文件、Dsym文件，demo中是2 `MH_EXECUTE`，代表可执行文件*/ uint32_t ncmds; /* number of load commands 加载命令条数 */ uint32_t sizeofcmds; /* the size of all the load commands 所有加载命令的大小 */ uint32_t flags; /* flags 标志位 */ uint32_t reserved; /* reserved 保留字段 */ }; filetype\nOBJECT，指的是 .o 文件或者 .a 文件； EXECUTE，指的是 IPA 拆包后的文件； DYLIB，指的是 .dylib 或 .framework 文件； DYLINKER，指的是动态链接器； DSYM，指的是保存有符号信息用于分析闪退信息的文件。 待更新\u0026hellip; 感觉还没学会😭\nLLVM-NM\u003e LLVM-NM # 参考 了解Mach-O文件 2\n","date":"2022-11-14","permalink":"/ios/link-and-symbol/","section":"IOS","summary":"Mach-O\u003e Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。","title":"Link and Symbol"},{"content":"","date":"2022-11-14","permalink":"/tags/mach-o/","section":"Tags","summary":"","title":"Mach-O"},{"content":"","date":"2022-11-14","permalink":"/tags/autolayout/","section":"Tags","summary":"","title":"AutoLayout"},{"content":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。\n避免操作updateConstants()\u003e 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。\nfunc updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系\u003e 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。\n无需视图时使用hideen属性，而不是删除约束\u003e 无需视图时使用hideen属性，而不是删除约束 # 通过激活或停用改变视图，而不是修改约束。\u003e 通过激活或停用改变视图，而不是修改约束。 # UILabe、UIImageView、自动测量尺寸并不会消耗多少性能。 如果需要频繁计算视图尺寸或已经知道该视图尺寸可以重写属性，提高部分性能。 override var intrinsicContentSize: CGSize { return CGSize(width: UIView.noIntrinsicMetric, height: UIView.noIntrinsicMetric) } 想了解的更多可以看 WWDC18: High Performance Auto Layout 相关视频、资料。\n","date":"2022-11-14","permalink":"/ios/high-performance-autolayout/","section":"IOS","summary":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。","title":"High Performance Autolayout"},{"content":"","date":"2022-11-14","permalink":"/tags/wwdc/","section":"Tags","summary":"","title":"WWDC"},{"content":"","date":"2022-11-14","permalink":"/tags/ctmediator/","section":"Tags","summary":"","title":"CTMediator"},{"content":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","date":"2022-11-14","permalink":"/ios/center-core-mode/","section":"IOS","summary":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","title":"Target-Action组件化方案CTMediator"},{"content":"","date":"2022-11-14","permalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"中间人模式"},{"content":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;\nPrivacy - Face ID Usage Description OR\nNSFaceIDUsageDescription 引入相关的库\nLocalAuthentication 引入头文件\n#import \u0026lt;LocalAuthentication/LocalAuthentication.h\u0026gt; 使用\u003e 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.localizedFallbackTitle = @\u0026#34;localizedFallbackTitle\u0026#34;; NSError *error; LAPolicy policy = LAPolicyDeviceOwnerAuthenticationWithBiometrics; if ([context canEvaluatePolicy:policy error:\u0026amp;error]) { [context evaluatePolicy:policy localizedReason:@\u0026#34;通过Home键验证已有指纹\u0026#34; reply:^(BOOL success, NSError * _Nullable error) { if (success) { // success MNLog(self, @\u0026#34; successed!!!\u0026#34;); } else if (error) { MNLog(self, @\u0026#34; face error.code = %@\u0026#34;, error); switch (error.code) { case LAErrorAuthenticationFailed: break; default: break; } } else { // other MNLog(self, @\u0026#34; face id the other reason!!!\u0026#34;); } }]; } else { // error MNLog(self, @\u0026#34;还没有设置id, %@\u0026#34;, error); } } ","date":"2022-11-14","permalink":"/ios/authentication-biometrics/","section":"IOS","summary":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;","title":"Authentication Biometrics"},{"content":"","date":"2022-11-14","permalink":"/tags/faceid/","section":"Tags","summary":"","title":"FaceID"},{"content":"","date":"2022-11-14","permalink":"/tags/touchid/","section":"Tags","summary":"","title":"TouchID"},{"content":"","date":"2022-11-14","permalink":"/series/objc/","section":"Series","summary":"","title":"Objc"},{"content":"","date":"2022-11-14","permalink":"/tags/oc/","section":"Tags","summary":"","title":"OC"},{"content":"","date":"2022-11-14","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"对 NSNumber、NSString、NSDate 优化。\n当以上类型对象需要存储的数据没有超出固定分配的字节，该对象可以被看作是简单数据类型；而当对象需要存储的数据超过了固定字节，该对象就会变成真正的对象。\n","date":"2022-11-14","permalink":"/oc/togged-pointer/","section":"Objective-C","summary":"对 NSNumber、NSString、NSDate 优化。\n当以上类型对象需要存储的数据没有超出固定分配的字节，该对象可以被看作是简单数据类型；而当对象需要存储的数据超过了固定字节，该对象就会变成真正的对象。","title":"Togged Pointer"},{"content":"","date":"2022-11-14","permalink":"/tags/copy/","section":"Tags","summary":"","title":"Copy"},{"content":"strong / weak / copy(ARC环境)\nAutomatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code, the object graphs, and the relationships between objects in your application.\nAutomatic Reference Counting(ARC)技术是用于OC对象的内存管理。即在适当的时候对OC对象retain和release操作。 strong是强引用，会持有对象，引用计数器会+1\u003e strong是强引用，会持有对象，引用计数器会+1 # strong是为了告诉编译器（xcode），被strong修饰的对象是强引用，需要retain操作，引用计数器会+1，默认情况下声明变量都是隐式strong申明。\n默认情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; NSArray *strArr = testArr; testArr = nil; NSLog(@\u0026#34;print str is %@\u0026#34;, strArr); // 打印结果 2021-05-30 15:33:14.931372+0800 Strong\u0026amp;Weak[3480:197342] print str is ( a, b ) __strong修饰情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; __strong NSArray * strongStrArr = testArr; testArr = nil; NSLog(@\u0026#34;print strongStr is %@\u0026#34;, strongStrArr); // 打印结果 2021-05-30 15:37:30.308564+0800 Strong\u0026amp;Weak[3551:201548] print strongStr is ( a, b ) __weak修饰情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; __weak NSArray * weakStrArr = testArr; testArr = nil; NSLog(@\u0026#34;print weakStr is %@\u0026#34;, weakStrArr); // 打印结果 2021-05-30 15:39:38.772768+0800 Strong\u0026amp;Weak[3579:203646] print weakStr is (null) 小结\u003e 小结 # 对比以上结果，可以看出不使用__strong修饰和使用__strong结果一样，说明oc默认情况下声明变量都是__strong，因为weak修饰引用计数器不会+1，所修饰的对象可能随时被释放。\nweak是弱引用，不会持有对象，引用计数器不会+1\u003e weak是弱引用，不会持有对象，引用计数器不会+1 # 常用于修饰UI控件、delegate\n声明为weak的指针，weak指针指向的对象一旦被释放，weak的指针都将被赋值为nil，防止野指针。\ncopy分为浅拷贝、深拷贝\u003e copy分为浅拷贝、深拷贝 # 修饰NSString、block\nstackblock如果不copy的话，stackblock是存放在栈里面的，他的生命周期会随着函数的结束而出栈的，copy之后会转变为mallocblock放在堆里面。\nassign简单赋值，不改变引用计数。\u003e assign简单赋值，不改变引用计数。 # 基础数据类型（NSInteger、CGFloat） C数据类型（int、float、double、char等） 枚举、结构体等非OC对象 ","date":"2022-11-14","permalink":"/oc/keywords/","section":"Objective-C","summary":"strong / weak / copy(ARC环境)","title":"Keywords"},{"content":"","date":"2022-11-14","permalink":"/tags/strong/","section":"Tags","summary":"","title":"STRONG"},{"content":"","date":"2022-11-14","permalink":"/tags/weak/","section":"Tags","summary":"","title":"WEAK"},{"content":"","date":"2022-11-14","permalink":"/tags/runloop/","section":"Tags","summary":"","title":"Runloop"},{"content":"RunLoop的简介、作用\u003e RunLoop的简介、作用 # 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 RunLoop可以简单理解为，让程序保持运行的一个while循环，这个循环内监听各种事件（如触摸事件、performSelector、定时器NSTimer等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）\n不管RunLoop有多复杂，其本质就是：一个循环，有事件的时候处理事件，无事件的时候休眠（这里的睡眠是指用户态切换到内核态，这样的休眠线程是被挂起的，不会再占用cpu资源）。 RunLoop与线程\u003e RunLoop与线程 # 一个线程只有一个RunLoop对象（一一对应关系） 主线程的RunLoop默认已经创建好了，而子线程的需要手动创建。 RunLoop在第一次获取时创建，在线程结束时销毁。 RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。\nvoid const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) { if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); } __CFLock(\u0026amp;loopsLock); if (!__CFRunLoops) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, \u0026amp;kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); #pragma GCC diagnostic push #pragma GCC diagnostic ignored \u0026#34;-Wdeprecated\u0026#34; if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)\u0026amp;__CFRunLoops)) { #pragma GCC diagnostic pop CFRelease(dict); } CFRelease(mainLoop); } CFRunLoopRef newLoop = NULL; CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { newLoop = __CFRunLoopCreate(t); cf_trace(KDEBUG_EVENT_CFRL_LIFETIME|DBG_FUNC_START, newLoop, NULL, NULL, NULL); CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } __CFUnlock(\u0026amp;loopsLock); // don\u0026#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it if (newLoop) { CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) { #if _POSIX_THREADS _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); #else _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, \u0026amp;__CFFinalizeRunLoop); #endif } } return loop; } RunLoop的组成\u003e RunLoop的组成 # 一个 RunLoop 主要由：CFRunLoopMode / CFRunLoopSourceRef / CFRunLoopObserverRef / CFRunLoopTimerRef 组成。 RunLoop 可以拥有多种Mode，Mode中包含 Source / Observer / Timer。\nCFRunLoopMode（RunLoop的运行模式）共五类\u003e CFRunLoopMode（RunLoop的运行模式）共五类 # kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode 界面跟踪Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响 UIInitializationRunLoopMode 在刚启动App时第进入的第一个Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode 接受系统事件的内部Mode，通常用不到 kCFRunLoopCommonModes 这是一个占位用的Mode，不是一种真正的Mode，可以简单理解为 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode 的结合 CFRunLoopSource（输入源/事件源）\u003e CFRunLoopSource（输入源/事件源） # 这里有两个源：_sources0 / _sources1\n_sources0 即非基于 port 的，也就是用户触发事件，需要手动唤醒线程。将当前线程从 \u0026lsquo;内核态切换到用户态\u0026rsquo; \u0026lsquo;CPU的两种工作状态，内核态可以调度所有的资源，用户态则只可以调度用户工作界面\u0026rsquo; _sources1 基于 port 的，包含一个 mach_port 和一个回调，可以监听系统端口和通过内核态和其他线程发送消息，能主动唤醒 RunLoop，接收分发系统事件，具备唤醒线程能力。\nCFRunLoopTimer（定时源）\u003e CFRunLoopTimer（定时源） # 基于时间的触发器，基本上说的就是 NSTimer。在预设的时间点唤醒 RunLoop 执行回调。因为它是基于 RunLoop 的，因此它不是实时的（就是 NSTimer 是不准确的。 因为 RunLoop 只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致 Timer 本次延时，或者少执行一次）\nCFRunLoopObserver（观察者）\u003e CFRunLoopObserver（观察者） # 可以对 RunLoop 不同状态下进行监听，从而对当前 RunLoop 工作状态进行优化。\nkCFRunLoopEntry RunLoop准备启动 kCFRunLoopBeforeTimers RunLoop将要处理一些Timer相关事件 kCFRunLoopBeforeSources RunLoop将要处理一些Source事件 kCFRunLoopBeforeWaiting RunLoop将要进行休眠状态，即将由用户态切换到内核态 kCFRunLoopAfterWaiting RunLoop被唤醒，即从内核态切换到用户态后 kCFRunLoopExit RunLoop退出 kCFRunLoopAllActivities 监听所有状态活动 如何设置监听?\nRunLoop运行机制\u003e RunLoop运行机制 # 1️⃣ 调用 Observer 监听方法状态为 kCFRunLoopEntry 2️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeTimers 3️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeSources 4️⃣ 处理 Blocks：__CFRunLoopDoBlocks 5️⃣ 处理 sources0，如果被处理过则再次处理 Blocks ⁉️ 判断是否存在 sources1，如果存在 7️⃣，如果不存在 6️⃣ 6️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeWaiting，并随时等待被 sources1 / dipatch / timer / source0 / 手动唤醒 唤醒，如有，则会：调用 Observer 监听方法状态为 kCFRunLoopAfterWaiting 继续 7️⃣ 7️⃣ 处理 timers 8️⃣ 处理 GCD Main 9️⃣ 处理 sources1 🔟 处理 Blocks ⁉️ 是否还有需要处理的任务？是跳转到 2️⃣ 重新开始， 否则：调用 Observer 监听方法状态为 kCFRunLoopExit 主线程\u003e 主线程 # 自己能够保活，因为底层判断是根据 modes 是否为空来决定线程是否休眠（销毁），如果是主线程则是个例外，直接返回不为空。非主线程则是根据 _sources0 _sources1 _timers 中是否有数据来判断。 源码如是\n// expects rl and rlm locked static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) { CHECK_FOR_FORK(); if (NULL == rlm) return true; #if TARGET_OS_WIN32 if (0 != rlm-\u0026gt;_msgQMask) return false; #endif #if __HAS_DISPATCH__ Boolean libdispatchQSafe = pthread_main_np() == 1 \u0026amp;\u0026amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe \u0026amp;\u0026amp; (CFRunLoopGetMain() == rl) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)) return false; // represents the libdispatch main queue #endif if (NULL != rlm-\u0026gt;_sources0 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources0)) return false; if (NULL != rlm-\u0026gt;_sources1 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources1)) return false; if (NULL != rlm-\u0026gt;_timers \u0026amp;\u0026amp; 0 \u0026lt; CFArrayGetCount(rlm-\u0026gt;_timers)) return false; struct _block_item *item = rl-\u0026gt;_blocks_head; while (item) { struct _block_item *curr = item; item = item-\u0026gt;_next; Boolean doit = false; if (_kCFRuntimeIDCFString == CFGetTypeID(curr-\u0026gt;_mode)) { doit = CFEqual(curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFEqual(curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } else { doit = CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } if (doit) return false; } return true; } 所以如何进行线程保活?\n只需要在 _sources0 _sources1 _timers 中添加事件，线程就能处于活跃状态。\nRunLoop线程保活\u003e RunLoop线程保活 # 某个操作如果需要频繁在子线程中进行操作，可以延长该线程的生命周期，而不需要频繁创建新的线程来工作。\n创建一个线程，并在该线程的runloop中添加source使得线程停留。\n_thread = [[YZThread alloc] initWithBlock:^{ NSLog(@\u0026#34;thread is begin\u0026#34;); CFRunLoopSourceContext context = {0}; CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, \u0026amp;context); CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode); CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false); NSLog(@\u0026#34; -------- thread is end -------- \u0026#34;); }]; [_thread start]; 在子线程中做相应操作\n- (void)excutedInBlock:(LongtimeThreadBlock)block { if (!block || !_thread) return; [self performSelector:@selector(__excutedDosome:) onThread:_thread withObject:block waitUntilDone:NO]; } - (void)__excutedDosome:(LongtimeThreadBlock)block { block(); } 结束线程\n- (void)stop { if (!_thread) return; // waitUnitDone, 这里要设置YES，防止self被提前释放。 [self performSelector:@selector(__stop) onThread:_thread withObject:nil waitUntilDone:YES]; } - (void)__stop { CFRunLoopStop(CFRunLoopGetCurrent()); self.thread = nil; } 运用\n@implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; _thread = [[LongtimeThread alloc] init]; } - (void)touchesBegan:(NSSet\u0026lt;UITouch *\u0026gt; *)touches withEvent:(UIEvent *)event { [_thread excutedInBlock:^{ NSLog(@\u0026#34;do something in thread.\u0026#34;); }]; } @end CFRunLoop存在于Foundation框架中，使用的是纯C函数实现，相对于NSRunloop，这些C函数API都是线程安全🔐的。 RunLoop的应用\u003e RunLoop的应用 # 定时器（Timer）、PerformSelector GCD Async Main Queue 事件响应、手势识别、界面刷新 网络请求 AutoreleasePool 卡顿监听 NSTimer的失效\u003e NSTimer的失效 # NSTimer默认创建事件表，对应的RunLoop，默认是NSDefaultRunLoopMode，所以在滑动事件上该模式会被暂停。计时器就不会工作。\n__block int count = 0; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer *timer) { NSLog(@\u0026#34;counting is %d\u0026#34;, ++count); }]; 只需把NSTimer放在RunLoop的NSRunLoopCommonModes模式下，滑动事件就不会影响该NSTimer的工作。\n__block int count = 0; NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@\u0026#34;counting is %d\u0026#34;, ++count); }]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 参考\u003e 参考 # 1 2 3 理解 OC 中 RunLoop ","date":"2022-11-14","permalink":"/oc/runloop/","section":"Objective-C","summary":"RunLoop的简介、作用\u003e RunLoop的简介、作用 # 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 RunLoop可以简单理解为，让程序保持运行的一个while循环，这个循环内监听各种事件（如触摸事件、performSelector、定时器NSTimer等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）","title":"Runloop"},{"content":"","date":"2022-11-14","permalink":"/tags/objc-instance/","section":"Tags","summary":"","title":"Objc Instance"},{"content":" oc对象 在内存中存储的东西 instance isa, _property(value) class isa, property, function, protocol, _property, superclass meta-class isa, superclass, class function instance对象（实例对象）\u003e instance对象（实例对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; instance对象在内存中存储的信息包括\u003e instance对象在内存中存储的信息包括 # isa指针 其他成员变量（这里指的是变量的值，比如变量age = 4，存储这个4) class对象（类对象）\u003e class对象（类对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; // objClass1 ~ objClass5 都是NSObject的class对象（类对象） // 他们是同一个对象，每个类在内存中有且只有一个class对象 Class objClass1 = [obj1 class]; Class objClass2 = [obj2 class]; Class objClass3 = [NSObject class]; Class objClass4 = object_getClass(obj1); Class objClass5 = object_getClass(obj2); class对象在内存中存储的信息包括\u003e class对象在内存中存储的信息包括 # isa指针 superclass指针 类的属性信息（@property）、类的对象方法信息（instance method） 类的协议信息（protocol）、类的成员变量信息（ivar，这里主要是变量名不会发生改变的信息，变量类型） meta-class对象（元类对象）\u003e meta-class对象（元类对象） # // objMetaClass 是NSObject的meta-class对象（元类对象） // 每个类在内存中有且只有一个meta-class对象 Class objMetaClass = object_getClass([NSObject class]); // runtime api meta-class对象和class对象的内存结构是一样的，只是用途不一样\u003e meta-class对象和class对象的内存结构是一样的，只是用途不一样 # isa指针 superclass指针 类的类方法信息（class method） \u0026hellip; 注意\u003e 注意 # //objectClass是class对象，并不是meta-class对象 Class objClass = [[NSObject class] class]; // 查看Class是否是meta-class #import \u0026lt;objc/runtime.h\u0026gt; BOOL result = class_isMetaClass([NSObject class]); isa指针\n","date":"2022-11-14","permalink":"/oc/objc-instance/","section":"Objective-C","summary":"oc对象 在内存中存储的东西 instance isa, _property(value) class isa, property, function, protocol, _property, superclass meta-class isa, superclass, class function instance对象（实例对象）\u003e instance对象（实例对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; instance对象在内存中存储的信息包括\u003e instance对象在内存中存储的信息包括 # isa指针 其他成员变量（这里指的是变量的值，比如变量age = 4，存储这个4) class对象（类对象）\u003e class对象（类对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; // objClass1 ~ objClass5 都是NSObject的class对象（类对象） // 他们是同一个对象，每个类在内存中有且只有一个class对象 Class objClass1 = [obj1 class]; Class objClass2 = [obj2 class]; Class objClass3 = [NSObject class]; Class objClass4 = object_getClass(obj1); Class objClass5 = object_getClass(obj2); class对象在内存中存储的信息包括\u003e class对象在内存中存储的信息包括 # isa指针 superclass指针 类的属性信息（@property）、类的对象方法信息（instance method） 类的协议信息（protocol）、类的成员变量信息（ivar，这里主要是变量名不会发生改变的信息，变量类型） meta-class对象（元类对象）\u003e meta-class对象（元类对象） # // objMetaClass 是NSObject的meta-class对象（元类对象） // 每个类在内存中有且只有一个meta-class对象 Class objMetaClass = object_getClass([NSObject class]); // runtime api meta-class对象和class对象的内存结构是一样的，只是用途不一样\u003e meta-class对象和class对象的内存结构是一样的，只是用途不一样 # isa指针 superclass指针 类的类方法信息（class method） \u0026hellip; 注意\u003e 注意 # //objectClass是class对象，并不是meta-class对象 Class objClass = [[NSObject class] class]; // 查看Class是否是meta-class #import \u0026lt;objc/runtime.","title":"Objc Instance"},{"content":"","date":"2022-11-14","permalink":"/tags/objc/","section":"Tags","summary":"","title":"Objc"},{"content":" Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。 Objective-C被翻译的过程 graph LR; A[OC]--\u003eB[C\\C++]; B--\u003eC[汇编语言]; C--\u003eD[机器语言] Objective-C代码转换为C、C++代码\n// 终端命令 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.c -o main.cpp xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc “oc源文件” -o “输出cpp文件” 一个OC对象在内存中是如何布局的？\u003e 一个OC对象在内存中是如何布局的？ # // alloc 申请一块内存空间，init 初始化一个类的实例对象 NSObject *obj = [[NSObject alloc] init]; OC中对象至少会被分配16个字节的空间（64位）；32位则是8个字节\nC OC 32Bit 64Bit bool BOOL(64) 1 1 char int8_t, BOOL(32) 1 1 unsigned char boolean 1 1 short int16_t 2 2 unsigned short unichar 2 2 int int32_t,NSInteger,boolean 4 4 unsigned int boolean_t,NSUInteger 4 4 long NSInteger 4 8 unsigned long NSUInteger 4 8 long long int64_t 8 8 float CGFloat(32) 4 4 double CGFloat(64) 8 8 参考\u003e 参考 # 1、OC基本数据类型\n关于NSObject对象的内存布局，看我就够了！\n实时查看内存数据\u003e 实时查看内存数据 # DeBug \u0026gt; DeBug Workflow \u0026gt; View Memory，Shift + Command + M\n创建一个实例对象，至少需要多少内存？\u003e 创建一个实例对象，至少需要多少内存？ # 一个对象至少需要8个字节\n#import \u0026lt;objc/runtime.h\u0026gt; class_getInstanceSize([NSObject class]); 创建一个实例对象，实际分配了多少内存？\u003e 创建一个实例对象，实际分配了多少内存？ # 64位系统至少会分配16个字节，32位则是8个字节。\n#import \u0026lt;malloc/malloc.h\u0026gt; NSObject *obj = [[NSObject alloc] init]; malloc_size((__bridge const void *)obj); 常用LLDB指令\u003e 常用LLDB指令 # print、p： 打印 po：打印对象\n读取内存 Memory read/数量格式字节数 内存地址 x/数量格式字节数 内存地址 💡 例如：x/3xw 0x10010\n格式 x是16进制，f是浮点数，d是10进制 字节大小 b：byte 1字节 h：half wrod 2字节 w： word 4字节 g：giant word 8字节 修改内存中的值 memory write 内存地址 数值：memory write 0x0000010 10 ","date":"2022-11-14","permalink":"/oc/objc/","section":"Objective-C","summary":"Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。 Objective-C被翻译的过程 graph LR; A[OC]--\u003eB[C\\C++]; B--\u003eC[汇编语言]; C--\u003eD[机器语言] Objective-C代码转换为C、C++代码","title":"Objective-C的本质"},{"content":"","date":"2022-11-14","permalink":"/tags/kvo/","section":"Tags","summary":"","title":"KVO"},{"content":" KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 可以用于监听某个对象属性值的改\n// 如何设置属性的KVO @property (nonatomic, strong) Person *person1; - (void)viewDidLoad { [super viewDidLoad]; _person1 = [[Person alloc] init]; _person1.age = 32; // 需要返回的数据，新的值 ｜ 旧的值 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; // 对person1属性age设置监听，附带信息：@\u0026#34;附加信息\u0026#34; [self.person1 addObserver:self forKeyPath:@\u0026#34;age\u0026#34; options:options context:@\u0026#34;附加信息\u0026#34;]; } // person1.ag改变时进行调用这里 -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change context:(void *)context { NSLog(@\u0026#34;keyPath: %@, object: %@;\\nchange: %@, context: %@\u0026#34;, keyPath, object, change, context); } // 监听者销毁时移除相应的监听 -(void)dealloc { [_person1 removeObserver:self forKeyPath:@\u0026#34;age\u0026#34;]; } KVO的本质（内部实现）\u003e KVO的本质（内部实现） # 打印对象isa地址、name类名\u003e 打印对象isa地址、name类名 # 在设置监听前后打印person1，2的isa地址。发现person1在设置完监听后地址发生了改变；在设置监听前后打印person1，2的类名。发现person1在设置完监听后改变为：NSKVONotifying_Person；\n// person1-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person1-\u0026gt;isa: %p\u0026#34;, object_getClass(_person1)); // person2-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person2-\u0026gt;isa: %p\u0026#34;, object_getClass(_person2)); // person1 class name: Person NSLog(@\u0026#34;person1 class name: %p\u0026#34;, object_getClass(object_getClass(_person1))); // person2 class name: Person NSLog(@\u0026#34;person2 class name: %p\u0026#34;, object_getClass(object_getClass(_person2))); NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [self.person1 addObserver:self forKeyPath:@\u0026#34;age\u0026#34; options:options context:@\u0026#34;附加信息\u0026#34;]; // person1-\u0026gt;isa: 0x6000022a03f0 NSLog(@\u0026#34;person1-\u0026gt;isa: %p\u0026#34;, object_getClass(_person1)); // person2-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person2-\u0026gt;isa: %p\u0026#34;, object_getClass(_person2)); // person1 class name: NSKVONotifying_Person NSLog(@\u0026#34;person1 class name: %p\u0026#34;, object_getClass(object_getClass(_person1))); // person2 class name: Person NSLog(@\u0026#34;person2 class name: %p\u0026#34;, object_getClass(object_getClass(_person2))); // person1 class`s class name: Person NSLog(@\u0026#34;person1 class`s class name: %@\u0026#34;, object_getClass(object_getClass(person1)).superclass); 小结\u003e 小结 # 可以看出，程序在runtime的时候动态生成了 NSKVONotifying_Person ，NSKVONotifying_Person 继承于 Person，当改变 age 的值时，即调用 setAge: 方法。NSKVONotifying_Person 重写了 setAge：并做了其他事情。具体做了那些事可以猜测：\n- (void)setAge:(int)age { [_person1 willChangeValueForKey:@\u0026#34;age\u0026#34;]; [super setAge:age]; [_person1 didChangeValueForKey:@\u0026#34;age\u0026#34;]; } didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法\n即：KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 如何手动触发KVO？\u003e 如何手动触发KVO？ # 手动调用willChangeValueForKey: 和didChangeValueForKey: 。只调用didChangeValueForKey: 是无法触发的。\n使用场景\u003e 使用场景 # 实现上下拉刷新控件 content offset webview 混合排版 content size 监听模型属性实时更新UI NSOperation NSoperationQueue RAC ","date":"2022-11-14","permalink":"/oc/kvo/","section":"Objective-C","summary":"KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 可以用于监听某个对象属性值的改\n// 如何设置属性的KVO @property (nonatomic, strong) Person *person1; - (void)viewDidLoad { [super viewDidLoad]; _person1 = [[Person alloc] init]; _person1.","title":"KVO (Key-Value Observing)"},{"content":"","date":"2022-11-14","permalink":"/tags/kvc/","section":"Tags","summary":"","title":"KVC"},{"content":"KVC主要方法\u003e KVC主要方法 # - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (id)valueForKey:(NSString *)key; setValue: forKey: 的原理\u003e setValue: forKey: 的原理 # valueForKey: 的原理\u003e valueForKey: 的原理 # 使用KVC修改是否会触发KVO？（设置了监听）\u003e 使用KVC修改是否会触发KVO？（设置了监听） # 使用KVC，不管是修改成员变量还是属性的值都会触发KVO。\n","date":"2022-11-14","permalink":"/oc/kvc/","section":"Objective-C","summary":"KVC主要方法\u003e KVC主要方法 # - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (id)valueForKey:(NSString *)key; setValue: forKey: 的原理\u003e setValue: forKey: 的原理 # valueForKey: 的原理\u003e valueForKey: 的原理 # 使用KVC修改是否会触发KVO？（设置了监听）\u003e 使用KVC修改是否会触发KVO？（设置了监听） # 使用KVC，不管是修改成员变量还是属性的值都会触发KVO。","title":"KVC (Key-Value Coding)"},{"content":" oc为什么要存在isa\u003e oc为什么要存在isa # isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。\n什么事消息机制？怎么理解消息机制？\u003e 什么事消息机制？怎么理解消息机制？ # 当对象调用方法时，[objc class] 理论上其实是调用 objc_msgSend(objc-\u0026gt;isa, @selector(class))方法通知objc去调用class方法。\nisa指针指向关系图\u003e isa指针指向关系图 # instance实例对象的isa指针指向class类对象\u003e instance实例对象的isa指针指向class类对象 # 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现并调用。\nclass类对象的isa指向meta-class元类对象\u003e class类对象的isa指向meta-class元类对象 # 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现并调用。\ninstance的isa指向class class的isa指向meta-class meta-class的isa指向基类（NSObject）的meta-class class的superclass指向父类的class，如果没有父类，superclass的指针为nil meta-class的superclas指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹： isa找到class，如果方法不存在，就通过superclass找到父类的class，直到找到为止，如果最后没有找到，就会报错：unrecognized selector class调用类方法轨迹： isa找到meta-class，方法不存在，就通过superclass找父类，如果一直到基类的mete-class都没找到，则会找到基类的class，如果有则调用对象方法，没有则：unrecognized selector 从64位开始，isa指向的地址的需要一次位运算（\u0026amp; ISA_MASK），才能计算真实地址。 #if __arm64__ #define ISA_MASK 0x0000000ffffffff8ULL #elif __x86_64__ #define ISA_MASK 0x00007fffffffffff8ULL #endif NSObject *obj = [[NSObject alloc] init]; p/x obj-\u0026gt;isa // 打印输出obj的isa地址 class类对象、meta-class元类对象的本质结构都是struct objc_class struct objc_class 结构\u003e struct objc_class 结构 # struct objc_class { Class isa; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息 }； class_rw_t *data = bits.data() // return bits \u0026amp; FAST_DATA_MASK struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间大小 #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; }; struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t *method; property_list_t *properties; const protocol_list_t *protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; }; ","date":"2022-11-14","permalink":"/oc/isa/","section":"Objective-C","summary":"oc为什么要存在isa\u003e oc为什么要存在isa # isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。","title":"Isa"},{"content":"","date":"2022-11-14","permalink":"/tags/isa/","section":"Tags","summary":"","title":"ISA"},{"content":" copy 是复制出不可变对象 mutableCopy 是复制出可变对象； 复制出来的对象互不影响。 copy 复制不可变对象属于浅拷贝（浅拷贝就只是地址拷贝） copy 复制可变对象属于深拷贝（需要复制出一份不可变对象，以免之前可变对象变更影响复制出来的对象） mutableCopy 属于深拷贝（重新申请一份内存和指针） - (void)viewDidLoad { [super viewDidLoad]; NSArray * arr = @[@1, @2]; NSArray *arrCopy = [arr copy]; NSMutableArray * arrMCopy = [arr mutableCopy]; [arrMCopy addObject:@3]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, arr, arrCopy, arrMCopy); NSMutableArray * marr = [NSMutableArray arrayWithArray:arr]; NSArray *marrCopy = [marr copy]; NSMutableArray * marrMCopy = [marr mutableCopy]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, marr, marrCopy, marrMCopy); } copy mutableCopy NSString NSString NSMutableString NSMutableString NSString NSMutableString NSArray NSArray NSMutableArray NSMutableArray NSArray NSMutableArray NSDictionary NSDictionary NSMutableDictionary NSMutableDictionary NSDictionary NSMutableDictionary ","date":"2022-11-14","permalink":"/oc/copy-mutablecopy/","section":"Objective-C","summary":" copy 是复制出不可变对象 mutableCopy 是复制出可变对象； 复制出来的对象互不影响。 copy 复制不可变对象属于浅拷贝（浅拷贝就只是地址拷贝） copy 复制可变对象属于深拷贝（需要复制出一份不可变对象，以免之前可变对象变更影响复制出来的对象） mutableCopy 属于深拷贝（重新申请一份内存和指针） - (void)viewDidLoad { [super viewDidLoad]; NSArray * arr = @[@1, @2]; NSArray *arrCopy = [arr copy]; NSMutableArray * arrMCopy = [arr mutableCopy]; [arrMCopy addObject:@3]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, arr, arrCopy, arrMCopy); NSMutableArray * marr = [NSMutableArray arrayWithArray:arr]; NSArray *marrCopy = [marr copy]; NSMutableArray * marrMCopy = [marr mutableCopy]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, marr, marrCopy, marrMCopy); } copy mutableCopy NSString NSString NSMutableString NSMutableString NSString NSMutableString NSArray NSArray NSMutableArray NSMutableArray NSArray NSMutableArray NSDictionary NSDictionary NSMutableDictionary NSMutableDictionary NSDictionary NSMutableDictionary ","title":"Copy \u0026 MutableCopy"},{"content":"","date":"2022-11-14","permalink":"/tags/mutablecopy/","section":"Tags","summary":"","title":"MutableCopy"},{"content":"","date":"2022-11-14","permalink":"/tags/category/","section":"Tags","summary":"","title":"Category"},{"content":"category定义在objc-runtime-new.h中，结构如下：\n所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点\u003e 知识点 # 后编译的先调用\u003e 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。\nXcode中控制编译顺序\u003e Xcode中控制编译顺序 # Category和Class Extension的区别是什么？\u003e Category和Class Extension的区别是什么？ # Class Extension在编译的时候，它的数据就已经包含在类信息中，Category是在运行时，才会将数据合并到类信息中。\n源码解读顺序\u003e 源码解读顺序 # objc-os.mm\n_objc_init map_images map_images_nolock objc-runtime-new.mm\n_read_images remethodizeClass attachCategories attachLists realloc、memmove、 memcpy 其他可阅读\u003e 其他可阅读 # OC 底层探索 - Category 和 Extension\nCategory的使用\u003e Category的使用 # 新建文件时选择Category类型\n#import \u0026#34;类名.h\u0026#34; @interface 类名 (类别名) // 在此处声明方法 @end #import \u0026#34;类名+类别名.h\u0026#34; @implementation 类名 (类别名) // 在此处实现声明的方法 @end Extension（扩展）\u003e Extension（扩展） # 一般的时候，Extension都是写在.m文件中，不单独建立一个扩展文件，且必须写在@implementation的上方，否则编译会报错。\n扩展文件为单一的.h文件 命名为\u0026quot;类名_类别名.h\u0026quot; #import \u0026#34;类名.h\u0026#34; @interface 类名 () // 在此添加私有成员变量、属性、声明方法 @end ","date":"2022-11-14","permalink":"/oc/category/","section":"Objective-C","summary":"category定义在objc-runtime-new.h中，结构如下：\n所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点\u003e 知识点 # 后编译的先调用\u003e 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。","title":"Category"},{"content":"","date":"2022-11-13","permalink":"/tags/app/","section":"Tags","summary":"","title":"app"},{"content":"","date":"2022-11-13","permalink":"/series/app/","section":"Series","summary":"","title":"App"},{"content":"","date":"2022-11-13","permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes"},{"content":" 碎片笔记本\n使用说明\u003e 使用说明 # 您可以纯粹的记录笔记，或者是把笔记和标签关联，比如这篇笔记\n它关联了状态标签\n默认状态是：🟡待办 选中状态是：🟢已完成 现在就可以尝试一下左上角的按钮，点点看😊\n如果您有一个待办事项，使用这个标签可轻松标记状态，当然您可以自定义，新建任何事件的两面性，或者只是新建个默认标签。\n笔记\n可以置顶🔝 可以编辑✒️ 可以删除🚮 也可以分享📟 只需长按列表某个笔记即可呼出菜单!!!\nEnjoy~\n隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 碎片笔记本 （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"2022-11-13","permalink":"/apps/notes/","section":"App","summary":"碎片笔记本，简单的记个笔记～","title":"Notes: 碎片笔记本使用手册"},{"content":"","date":"2022-11-13","permalink":"/tags/upaper/","section":"Tags","summary":"","title":"Upaper"},{"content":"隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 Upaper （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"2022-11-13","permalink":"/apps/upaper/","section":"App","summary":"方便简单的找到一个壁纸～","title":"Upaper: 高清壁纸"},{"content":"这里会展示我自己应用的相关信息\n","date":"2022-11-13","permalink":"/apps/","section":"App","summary":"这里会展示我自己应用的相关信息","title":"App"},{"content":"","date":"2022-11-13","permalink":"/tags/resume/","section":"Tags","summary":"","title":"Resume"},{"content":"","date":"2022-11-13","permalink":"/tags/worknote/","section":"Tags","summary":"","title":"WorkNote"},{"content":"","date":"2022-11-13","permalink":"/works/","section":"Works","summary":"","title":"Works"},{"content":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。\n@interface WZPageContentViewController : UIViewController @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDataSource\u0026gt; dataSource; @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDelegate\u0026gt; delegate; @property (strong, nonatomic, readonly) UIPageViewController *pageController; @property (strong, nonatomic, readonly) __kindof UIViewController *selectedController; @property (assign, nonatomic, readonly) NSInteger selectedIndex; @property(nonatomic) WZPageMenuItemStyle *selectedStyle; @property(nonatomic) WZPageMenuItemStyle *normalStyle; /// 是否展示分割线 @property(nonatomic) BOOL showDividingLine; /// 是否展示位置指示器 @property(nonatomic) BOOL showIndicator; - (void)reloadDataAt:(NSInteger)index; /// 刷新菜单栏 - (void)reloadMenus; - (void)registerClass:(Class)aClass identifier:(nonnull NSString *)identifier; - (void)registerNib:(UINib *)nib identifier:(NSString *)identifier; @end 设计结果肯定是以业务为依托，搭建基础框架，然后在条条框框里填写需求。所以先看一下代理设置了些啥，最后再拆解整个结构。\nWZPageContentViewControllerDataSource\u003e WZPageContentViewControllerDataSource # 首先他需要一个标题数据源；- (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; 然后给到对应数据源的页面；- (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; 如果你只需要这样的基础页面，那你完成设置了。因为内部已经实现了基础样式，选中的标题高亮，粗体。帮你缓存已经加载过的页面，同时给到对应appear disappear 正常 UIViewController 的生命周期这也是 UIPageViewController 自带的功能。\n@protocol WZPageContentViewControllerDataSource \u0026lt;NSObject\u0026gt; @required /// 返回菜单栏标题数组 - (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; /// 返回对应 index 的 Controller 该方法会缓存ViewController /// /// title 为 KEY /// - (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; @optional /// only can disable `UIPageViewControllerTransitionStylePageCurl` style gestrue /// default is `false` - (BOOL)enablePageCurlGesture; /// default is `UIPageViewControllerTransitionStyleScroll` - (UIPageViewControllerTransitionStyle)pageStyle; /// 对应 cell 的宽度 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; /// 标题栏的高度控制 - (CGFloat)heightOfMenuContainer; /// default is top /// /// - WZPageContentMenuPositionTop /// - WZPageContentMenuPositionBottom /// - (WZPageContentMenuPosition)menuPositionType; /// register a class or nib first. this method will replace titles /// /// - registerClass:identifier: /// /// - registerNib:identifier: - (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; @end 稍微进行一点自定义\npage的动画相关目前是开放的，我想有时间完善可能会关闭它，可以更纯粹些。\n- (BOOL)enablePageCurlGesture; - (UIPageViewControllerTransitionStyle)pageStyle; 定义每个标题的宽度；\n这里有个小技巧可以帮助你实现如果只有一个或两个标题时又要居中对齐的需求。 设置collection的左右间距和标题宽度，使它们之和占满屏幕 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; 既然 collection 是那么把 Cell 的权限交给你，在这之前请注册你的 Cell，可以在 WZPageContentViewController 头文件找到对应的方法。\n- (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; WZPageContentViewControllerDelegate\u003e WZPageContentViewControllerDelegate # 这里也给到了些简单好用的方法。\n@protocol WZPageContentViewControllerDelegate \u0026lt;NSObject\u0026gt; @optional /// 将要点击index, 此时 `selectedIndex` 还没有变更 - (void)pageContent:(WZPageContentViewController*)content willSelectedAt:(NSInteger)index; /// 点击MenuItem触发的事件： 已经点击index, 此时 `selectedIndex` 已变更 - (void)pageContent:(WZPageContentViewController*)content didSelectedAt:(NSInteger)index; /// 是否需要响应对应的坐标的按钮，默认为true /// /// return false 将不会响应 `willSelectedAt:` `didSelectedAt:` /// - (BOOL)pageContent:(WZPageContentViewController *)content shouldSelectAt:(NSInteger)index; @end 结构\u003e 结构 # 拆解一下结构。是很简单的一个结构，完成所有也只是三四百行。所以造东西主要还是思路问题。\n","date":"2022-11-13","permalink":"/works/06/","section":"Works","summary":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。","title":"WZPageViewController"},{"content":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息\nSN：可以在回调中判断当前是哪台设备（多设备情况下） 升级/切换信息：设备重启后校验版本或ID判断成功与否 回调记录：回调过长（多）大概率设备没有重启，或其他错误，判断为超时，停止计时器 定时器\u003e 定时器 # 需要持续获取设备信息，那么定时器必不可少，当然它的任务必须在异步执行，防止堵塞主线。\n调用设备状态 如果有状态直接输出给回调 如果没有状态，那么设备大概率是断开了，在升级或重启，这个时候需要请求设备算法包信息，不过不需要频繁请求，可以在非主线程中使用同步堵塞调用。一旦设备响应，比对版本信息判断是否升级成功。 以上，升级过程即封装完毕，只需在对应页面启动定时器并实现回调。\n回调\u003e 回调 # 在回调时给出相应页面所需参数即可。\n","date":"2022-11-13","permalink":"/works/07/","section":"Works","summary":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息","title":"封装AI算法升级或切换"},{"content":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。\n一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。\n至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。\n所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。\n另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。\n想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。\n豁然开朗！😊\n用原数据对比简直简单…😓！！！\n","date":"2022-11-13","permalink":"/works/02/","section":"Works","summary":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。\n一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。\n至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。\n所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。","title":"时长云存逻辑梳理优化"},{"content":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。\n","date":"2022-11-13","permalink":"/works/05/","section":"Works","summary":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。","title":"第三方登陆会请求两次的问题"},{"content":" 所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.yzong@outlook.com 个人技能\u003e 个人技能 # 6年iOS开发经验(Objective-C / Swift)； 能够独立开发应用，有一定的架构思维； 对内存管理、多线程编程、runtime、runloop、性能优化、AudioUnit等技术有一定的了解； 熟练使用xib、storyboard或代码自动布局； 乐于接受新事物新语言，并有足够的学习动力； 熟练使用MacOS、Xcode开发工具、证书生成、应用上架发布等； svn、git代码管理； 能够简单使用ReactNative、Flutter写界面； 拥有个人博客、Gitbook 有一定的审美能力； 工作经历\u003e 工作经历 # 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今\u003e 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今 # 负责公司iOS应用开发、上线、维护以及定制APP工作。\n工作中使用的是OC语言，主要完成app和摄像头的交互工作，摄像头新增功能的适配。比如，摄像头新增了人形检测，app则需要提供摄像头人形检测的开关控制，等等以及其他方面的控制项。\n云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07\u003e 云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07 # 独立负责公司iOS应用开发、上线、维护的工作。\n工作中使用Swift语言进行开发，处理过iOS系统版本间的适配，APP使用到IM聊天，语音录制播放，视频播放，以及部分热门的第三方库。\n开发初期主要是全局的对应用需求梳理，然后调研热门的第三方库的适用性。复杂页面用代码，简单页面基本都是xib或者storyboard；例如应用中使用到的图表，起初使用的是第三方库Charts，后期因为项目开发基本完毕，觉得项目完全用不上这样复杂的图表，于是自己编写重构，可以实现各种自定义，样式也是随心所欲。\n对每个功能模块进行新建文件夹管理，继承一些负责管理公共功能的父类，例如继承UIViewController，管理所有子类的通用属性、方法。\n应用首页也经过两次改版，一开始是常规的图文列表，这样的列表因为图片高度不固定文字长短不固定，要做的就是把每个cell高度提前计算好，保证流畅度，较好的方式是和后台讨论，事先存储图片需要展示的高度。不过，因为接口在开发小程序时就定下了，所以只能由前端处理高度，缓存已经加载过的高度，提高流畅性；改版后首页改成了堆叠卡片的样式，这个样式的麻烦点就在于卡片坐标的计算。\n对于第三方SDK，则是认真阅读文档，想要实现自己的功能点就基本没啥问题了。\n后期对APP做的最多的就是之前实现得不好的方法重构抽取，对部分业务逻辑重新梳理较好的实现。\n上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02\u003e 上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02 # IOS开发工程师，但是是在项目中期加入，所做的工作则是新业务的开发、维护、升级、上线等日常开发工作。\n工作中使用的是Objective-C语言开发。使我更加了解了应用的生命周期，内存释放机制；熟悉了一些热门的第三方库，提高了业务的开发效率，在阅读大神源码时，也学习了相关代码风格，抽象方法。愈发熟练UIKit，以及自定义视图；涉及图表的地方，使我更加熟练UIBezierpath。\n项目介绍\u003e 项目介绍 # 蛮牛摄像机\u003e 蛮牛摄像机 # 该项目是物联网项目，主要是和摄像头通讯，远程控制摄像头，查看摄像头画面、对讲等功能。\n下拉刷新，上拉加载MJRefresh； 二维码生成与识别； YUV视频帧渲染； AudioUnit音频单元控制； AFNetworking网络请求； 多线程 Braineex脑洞\u003e Braineex脑洞 # 该APP是针对家长与学生群体，发布与接受各种工作的兼职平台，有同时具备分享与聊天的社交系统\n网络请求模块使用的是Moya第三方库； 对象管理使用的是HandyJSON第三方库； 下拉刷新，上拉加载MJRefresh； 二维码生成与识别； 图片加载与缓存使用的是Kingfisher； 集成了环信IM聊天SDK； 集成了JPUSH极光推送SDK； 支持微信小程序、链接等分享，QQ链接分享； 高德商圈API； 微信支付； 支持简单的富文本编辑、显示； 支持视频上传、播放； 易掌握\u003e 易掌握 # 该APP是针对用于企业的ERP管理系统，用户可以在该APP上提交报销单据、加班条、请假申请等服务，亦可以直观的知道单据提交状态，审批状态\n网络请求模块使用的是AFNetworking第三方库； 本地数据管理使用的是FMDB第三方库； 支持离线推送； 支持微信分享； 支持文件上传、OCR识别； ","date":"2022-11-13","permalink":"/works/resume/","section":"Works","summary":"所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.","title":"简历2022"},{"content":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。\n","date":"2022-11-13","permalink":"/works/01/","section":"Works","summary":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。","title":"通过控制线程并发数量来优化首页在多设备情况下的表现"},{"content":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….\n","date":"2022-11-13","permalink":"/works/03/","section":"Works","summary":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….","title":"项目定制优化"},{"content":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。\n","date":"2022-11-13","permalink":"/works/04/","section":"Works","summary":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。","title":"首页替换第三方组件为系统组件"},{"content":"@synthesize是给属性添加别名，并生成get、set方法（默认使用）\n@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.m文件中属性age的引用方式就是__age, 或self.age; @synthesize age = __age; { NSLog(@\u0026#34;age is %d\u0026#34;, __age); } // set - (void)setAge:(int)age { __age = age; } // get - (int)getAge { return __age; } // 不添加该语句，则系统默认生成 @synthesize age = _age; // 提示 等同于 @synthesize age = age; 也就是该默认的 _age 为 age； @synthesize age; @end @dynamic是告诉编译器不要生成getter、setter方法。\n@interface ViewController : UIViewController @property (assign, nonatomic) int height; @end @implementation ViewController @dynamic height; { self.height = 20; NSLog(@\u0026#34;height is %d\u0026#34;, self.height); } @end // 运行，直接报错 2021-06-01 14:11:01.503408+0800 Unit[3654:233676] *** Terminating app due to uncaught exception \u0026#39;NSInvalidArgumentException\u0026#39;, reason: \u0026#39;-[ViewController setHeight:]: unrecognized selector sent to instance 0x7fd827105730\u0026#39; Terminating app due to uncaught exception \u0026#39;NSInvalidArgumentException\u0026#39;, reason: \u0026#39;-[ViewController height]: unrecognized selector sent to instance 0x7ff842309b40\u0026#39; ","date":"2022-06-30","permalink":"/oc/synthesize-dynamic/","section":"Objective-C","summary":"@synthesize是给属性添加别名，并生成get、set方法（默认使用）\n@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.","title":"@synthesize, @dynamic"},{"content":" initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序\u003e initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码\u003e initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !student { //Person类没有初始化 if !person { objc_msgSend([Person class],@seletor(initialize)) } objc_msgSend([Student class],@seletor(initialize)) } } 阅读源码（objc4）\u003e 阅读源码（objc4） # objc-msg-arm64.s objc_msgSend objc-runtime-new.mm class_getInstanceMethod lookUpImpOrNil lookUpImpOrForward _class_initialize callInitialize objc_msgSend(cls, SEL_initialize) ","date":"2022-06-30","permalink":"/oc/initialize/","section":"Objective-C","summary":"initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序\u003e initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码\u003e initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !","title":"+initialize"},{"content":" +load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序\u003e load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）\u003e 阅读源码（objc4） # objc-os.mm _objc_init load_images prepare_load_methods schedule_class_load add_class_to_loadable_list add_category_to_loadable_list call_load_methods call_class_loads call_category_loads *(load_method)(cls, SEL_load) +load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用 ","date":"2022-06-30","permalink":"/oc/load/","section":"Objective-C","summary":"+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序\u003e load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）\u003e 阅读源码（objc4） # objc-os.","title":"+load"},{"content":"","date":"2022-06-30","permalink":"/tags/associationobject/","section":"Tags","summary":"","title":"AssociationObject"},{"content":"AssociationObject关联对象的原理\u003e AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有\nAssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map\u0026lt;disguised_ptr_t, ObjectAssociationMap\u0026gt; class ObjectAssociationMap: public std::map\u0026lt;void *, ObjcAssociationMap\u0026gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构\u003e 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用\u003e AssociationObject关联对象的使用 # 关联对象常用API\u003e 关联对象常用API # 添加关联对象\nvoid objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) 获取关联对象\nid objc_getAssociatedObject(id object, const void * key) 移除所有关联对象\nvoid objc_removeAssociatedObjects(id object) 关联对象方法Key参数的常见用法\u003e 关联对象方法Key参数的常见用法 # static void *MyKey = \u0026amp;MyKey; objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, MyKey) static char MyKey; objc_setAssociatedObject(obj, \u0026amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, \u0026amp;MyKey) // 使用属性名作为key objc_setAssociatedObject(obj, @\u0026#34;property\u0026#34;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC); objc_getAssociatedObject(obj, @\u0026#34;property\u0026#34;); // 使用get方法的@selecor作为key（推荐） objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, @selector(getter)) 关联对象方法中 “objc_AssociationPolicy” 说明\u003e 关联对象方法中 “objc_AssociationPolicy” 说明 # objc_AssociationPolicy 对应修饰符 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_COPY copy atomic OBJC_ASSOCIATION_RETAIN strong atomic OBJC_ASSOCIATION_COPY_NONATOMIC copy nonatomic OBJC_ASSOCIATION_RETAIN_NONATOMIC strong nonatomic 通过关联对象实现分类（Category）属性的get、set方法。\u003e 通过关联对象实现分类（Category）属性的get、set方法。 # #import \u0026#34;Person+Test.h\u0026#34; #import \u0026lt;objc/runtime.h\u0026gt; @implementation Person(Test) - (void)setAge:(int)age { objc_setAssociatedObject(self, @selector(age), @(age), OBJC_ASSOCIATION_COPY_NONATOMIC); } - (int)age { return [objc_getAssociatedObject(self, _cmd) intValue]; } @end ","date":"2022-06-30","permalink":"/oc/association-object/","section":"Objective-C","summary":"AssociationObject关联对象的原理\u003e AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有\nAssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map\u0026lt;disguised_ptr_t, ObjectAssociationMap\u0026gt; class ObjectAssociationMap: public std::map\u0026lt;void *, ObjcAssociationMap\u0026gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构\u003e 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用\u003e AssociationObject关联对象的使用 # 关联对象常用API\u003e 关联对象常用API # 添加关联对象","title":"AssociationObject"},{"content":"","date":"2022-06-30","permalink":"/tags/autoreleasepool/","section":"Tags","summary":"","title":"AutoreleasePool"},{"content":" 自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构\u003e AutoreleasePoolPage内部结构 # 每个 AutoreleasePoolPage 对象占用 4096 字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 autorelease 对象的地址 所有的 AutoreleasePoolPage 对象通过双向链表的形式连接在一起 @autoreleasepool作用原理\u003e @autoreleasepool作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。\n说明\u003e 说明 # 调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址。 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY id *next指向了下一个能存放autorelease对象地址的区域\n","date":"2022-06-30","permalink":"/oc/autorelease-pool/","section":"Objective-C","summary":"自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构\u003e AutoreleasePoolPage内部结构 # 每个 AutoreleasePoolPage 对象占用 4096 字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 autorelease 对象的地址 所有的 AutoreleasePoolPage 对象通过双向链表的形式连接在一起 @autoreleasepool作用原理\u003e @autoreleasepool作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。","title":"AutoreleasePool"},{"content":"","date":"2022-06-30","permalink":"/tags/block/","section":"Tags","summary":"","title":"Block"},{"content":"Block的本质\u003e Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。\nblock的底层结构\u003e block的底层结构 # block的变量捕获（capture）\u003e block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制\n变量类型 是否捕获到block内部 访问方式 auto 修饰符（局部变量） 会捕获 值传递 static 修饰符（局部变量） 会捕获 指针传递 全局变量 不捕获 直接访问 局部变量auto(自动变量)\u003e 局部变量auto(自动变量) # 平时写的局部变量，默认就有auto（自动变量，离开作用域 { } 就会自动销毁），该类型变量一般存储在Stack栈上。 #import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { // 实际上是auto int age = 10, 表示自动释放的局部变量，离开作用域就会被释放。 int age = 10; void(^block)(void) = ^{ NSLog(@\u0026#34;age is %d\u0026#34;, age); }; block(); } return 0; } // 将代码转为编译后代码 int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; int age = 10; void(*block)(void) = ((void (*)())\u0026amp;__main_block_impl_0((void *)__main_block_func_0, \u0026amp;__main_block_desc_0_DATA, age)); ((void (*)(__block_impl *))((__block_impl *)block)-\u0026gt;FuncPtr)((__block_impl *)block); } return 0; } // 找到block最后生成的结构体，这里可以看到age成为该结构体的一个变量。 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int age; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) { impl.isa = \u0026amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 对象类型的auto变量\u003e 对象类型的auto变量 # block内部调用对象时，会自动生成相应的内存管理方法。并在适当的时候retain或relese\n当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用。 调用copy方法将会调用block内部的_Block_object_assign函数，_Block_object_assign会根据auto变量的修饰符（__strong, __weak, __unsafe_unretained）做出相应的操作。形成强引用（retain）或者弱引用。 block从堆上移除，会调用blcok内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose会自动释放引用的auto变量。 局部变量static（静态局部变量）\u003e 局部变量static（静态局部变量） # 修饰符 extern/static/const/UIKIT_EXTERN(OC版extern) 的使用\n静态变量（static 修饰的变量）都在全局数据区分配内存，包括静态全局变量和静态局部变量。直到程序结束运行，它才会被释放。\nstatic int height = 20; // static 局部变量也捕获，但和auto变量不同，static存储的是指针，指向-\u0026gt;height内存地址 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) { impl.isa = \u0026amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; block的类型\u003e block的类型 # block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\nNSGlobalBlock （ _NSConcreteGlobalBlock ） NSStackBlock （ _NSConcreteStackBlock ） NSMallocBlock （ _NSConcreteMallocBlock ） 各类型所处内存位置如图\nblock类型 环境 内存区、释放机制 NSGlobalBlock 没有访问auto变量 全局数据区：程序运行结束才会被释放 NSStackBlock 访问auto变量 栈区：变量在作用域结束就会被释放 NSMallocBlock __NSStackBlock__调用了copy 堆区：需要程序员手动管理内存申请、释放 block的copy\u003e block的copy # block类型 副本源的存储域 复制效果 _NSConcreteStackBlock 栈 从栈复制到堆 _NSConcreteGlobalBlock 程序数据区域 什么也不做 _NSConcreteMallocBlock 堆 引用计数器增加 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况 block作为函数返回值时\ntypedef void (^Block)(void); - (Block)doSomething { Block b = ^{ }; return b; } 将block赋值给__strong指针时\nint a = 10; // b访问了auto变量，理论上是__NSStackBlock__, 但是b 默认被__strong修饰 // 所以ARC中会被copy操作上堆。 // 实际上是 __strong Block b = ... Block b = ^{ NSLog(@\u0026#34;a is %d\u0026#34;, a); }; // weakb 访问了auto变量，所以在栈上__NSStackBlock__ __weak Block weakb = ^{ NSLog(@\u0026#34;a is %d\u0026#34;, a); }; // ^{} 没有访问auto变量，所以为：__NSGlobalBlock__ NSLog(@\u0026#34;b class is %@, and block2 class is %@, weakb class is %@\u0026#34;, [b class], [^{} class], [weakb class]); // 打印输出 b class is __NSMallocBlock__, and block2 class is __NSGlobalBlock__, block3 class is __NSStackBlock__ block作为Cocoa API中方法名含有usingBlock的方法参数时\n[[[NSArray alloc] init] enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { }]; block作为GCD API的方法参数时\n// dispatch_async(dispatch_queue_t _Nonnull queue, \u0026lt;#^(void)block#\u0026gt;) dispatch_async(dispatch_get_main_queue(), ^{ }); MRC下block属性的建议写法\u003e MRC下block属性的建议写法 # @property (copy, nonatomic) void (^block)(void); ARC下block属性的建议写法\u003e ARC下block属性的建议写法 # @property (strong, nonatomic) void (^block)(void); @property (copy, nonatomic) void (^block)(void); __block的本质是什么？\u003e __block的本质是什么？ # __block会将修饰对象封装成__Block_byref_a_0结构体，将该对象作为自己的成员变量，如果是对象类型，同时会生成__Block_byref_id_object_copy方法和__Block_byref_id_object_dispose，对其内存进行管理。\n// 修饰基本数据类型 __block int a = 10; NSLog(@\u0026#34;a is %d\u0026#34;, a); // 转为源码 struct __Block_byref_a_0 { void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; }; // 修饰对象 __block NSObject *obj = [[NSObject alloc] init]; NSLog(@\u0026#34;str is %@\u0026#34;, obj); struct __Block_byref_obj_0 { void *__isa; __Block_byref_obj_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *obj; }; __block的使用\u003e __block的使用 # 编译器会将__block变量包装成一个对象\n__block可以用于解决block内部无法修改auto变量值的问题\u003e __block可以用于解决block内部无法修改auto变量值的问题 # int age = 10; void (^block)(void) = ^{ NSLog(@\u0026#34;age is %d\u0026#34;, age); }; age = 20; block(); // 打印输出 2021-05-30 21:44:34.484323+0800 Strong\u0026amp;Weak[7070:466915] age is 10 这种情况，block捕获age，并将age的值赋值给了block对象中的age。所以之后改变age，也不改变block中的age。通过__block修饰，则会生成一个__Block_byref_age_1结构体\n__block int age = 10; struct __Block_byref_age_1 { void *__isa; __Block_byref_age_1 *__forwarding; // 指向自己的指针 int __flags; int __size; int age; }; // 此时age = 20，在源码中是，第一个age（__Block_byref_age_1） // 相当于age.age,将值赋值给age对象中的age。 // age.age指向的地址没有改变 (age.__forwarding-\u0026gt;age) = 20; // 所以打印输出自然是20 2021-05-30 22:03:02.218831+0800 Strong\u0026amp;Weak[7264:480507] age is 20 __block不能修饰全局变量、静态变量（static）\u003e __block不能修饰全局变量、静态变量（static） # __block的内存管理\u003e __block的内存管理 # 当block在栈上时，并不会对__block变量产生强引用 当block被copy到堆时 会调用block内部的copy函数 copy函数内部会调用_Block_object_assign函数 _Block_object_assign函数会对__block变量形成强引用（retain） 当block从堆中移除时 会调用block内部的dispose函数 dispose函数内部会调用_Block_object_dispose函数 _Block_object_dispose函数会自动释放引用的__block变量（release） __block的__forwarding指针\u003e __block的__forwarding指针 # 循环引用\u003e 循环引用 # 循环引用的产生\u003e 循环引用的产生 # 对象持有block，而block持有对象就会造成，双方都无法释放，导致循环应用。 对象持有block，block持有__block变量，__block持有对象也会造成循环引用 循环引用的解决\u003e 循环引用的解决 # 用__weak、__unsafe_unretained解决 用__block解决（必须要调用block） 解决循环引用问题 - MRC\u003e 解决循环引用问题 - MRC # 问题s\u003e 问题s # Q：为什么捕获age（auto 自由变量）？\n**A：**局部自由变量在离开作用域时就会被释放，如果block在其他地方调用，此时，之前的变量已经被释放，所以需要事先保存下来，以防数据丢失。\nQ：以下代码的输出分别是什么？\n#import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { // 实际上是auto int age = 10, 表示自动释放的局部变量，离开作用域就会被释放。 int age = 10; static int height = 20; void(^block)(void) = ^{ NSLog(@\u0026#34;age is %d and height is %d\u0026#34;, age, height); }; age = 1; height = 2; block(); } return 0; } A：\nage is 10 and height is 2 age = 10 时，已经被存储到block中，之后改变 age 并不会影响 block 中的 age。block 中 height 存储的时指向 height 的指针，所以在调用时取到的是 height 对应地址的值。\nQ：block在修改NSMutableArray，需不需要添加__block？\nA：不需要，NSMutableArray本身是个对象，会被block强引用，block没有释放，NSMutableArray也不会被释放，加__block属于多此一举，凭空增加内存。\nQ：block的属性修饰词为什么是copy？使用block有哪些使用注意？\nA：block一旦没有进行copy操作，就不会在堆上；使用注意：循环引用问题\nQ：__block的作用是什么？有什么使用注意点？\nA：__block可以用于解决block内部无法修改auto变量值的问题，__block不能修饰全局变量、静态变量（static）。\n","date":"2022-06-30","permalink":"/oc/block/","section":"Objective-C","summary":"Block的本质\u003e Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。\nblock的底层结构\u003e block的底层结构 # block的变量捕获（capture）\u003e block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制","title":"Block"},{"content":"","date":"2022-06-30","permalink":"/tags/cache/","section":"Tags","summary":"","title":"Cache"},{"content":"","date":"2022-06-30","permalink":"/tags/data-storage/","section":"Tags","summary":"","title":"Data Storage"},{"content":"","date":"2022-06-30","permalink":"/tags/flexbox/","section":"Tags","summary":"","title":"Flexbox"},{"content":"","date":"2022-06-30","permalink":"/tags/ios%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/","section":"Tags","summary":"","title":"iOS签名机制"},{"content":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。\n公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？\n混合密码系统(Hybrid Cryptosystem)\u003e 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。\n单向散列函数\u003e 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。\n特点\n根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）\n如何防止数据被篡改\u003e 如何防止数据被篡改 # 本地模型 网络模型 https://www.realvnc.com/en/connect/download/vnc/ 数字签名\u003e 数字签名 # 了解了单向散列函数，就可以理解数字签名，就可以解答之前 \u0026lsquo;遗留的问题\u0026rsquo; \u0026lsquo;B接收到的消息，真的就是A发送的吗？\u0026rsquo;。数字签名就是消息发送者（A）通过私钥加密消息的散列值的到的结果。接受者则（B）可以通过，A的公钥解密签名的到散列值，同时计算的到收到的消息的散列值，如果相等，则确认是（A）发送的消息。\n要注意的是，数字签名不能保证消息的机密性，它是一种验证手段，可能确保消息的来源和内容的真实性（验证散列值）。\n对于主动攻击者，还存在下面的模型的问题：主动攻击者可能伪造公钥，让发送者误以为是接受者的公钥。\n那如何验证公钥的合法性？\n证书(Certificate)\u003e 证书(Certificate) # 公钥证书（Public-key Certificate，PKC），认证机构（Certificate Authority，CA）施加数字签名。通过国际性组织、政府设立的组织、通过提供认证服务来盈利的企业或个人提供认证服务，也就是发送者，和接收者的第三方担保，它可以确保公钥的合法性。 iOS签名机制\u003e iOS签名机制 # iOS的签名机制，可以保证安装到用户手机上的APP都是经过Apple官方允许的。 不管是真机调试，还是发布APP，开发者都需要经过一系列复杂的步骤\n生成 CertificateSigningRequest.certSigningRequest 文件 获得 ios_development.cer\\ios_distribution.cer 证书文件 注册device、添加App ID 获得*.mobileprovision文件 （描述文件） 通过原理来翻译，则是：\n获得Mac电脑公钥 通过Mac公钥，向Apple申请加密，为公钥（证书） 添加设备，账号 向Apple申请将设备账号包装并生成新公钥（描述文件） XCode自动签名已经完成了以上所有步骤。\n.certSigningRequest、.cer、.mobileprovision文件究竟里面包含了什么？有何用处\n","date":"2022-06-30","permalink":"/ios/ios-signing/","section":"IOS","summary":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。","title":"iOS签名机制"},{"content":"","date":"2022-06-30","permalink":"/tags/ipa/","section":"Tags","summary":"","title":"IPA"},{"content":"","date":"2022-06-30","permalink":"/tags/nstimer/","section":"Tags","summary":"","title":"NSTimer"},{"content":"","date":"2022-06-30","permalink":"/series/oc/","section":"Series","summary":"","title":"OC"},{"content":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.h\u0026gt; 创建 pthread_t 对象以及使用\u003e 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(\u0026amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明\nint pthread_create(pthread_t _Nullable * _Nonnull __restrict, const pthread_attr_t * _Nullable __restrict, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable __restrict); 表示线程对象，指向线程标识符的指针 \u0026amp;thread 表示线程属性，可赋值 NULL 表示函数指针，在 thread 线程中要执行的任务 表示函数参数 pthread 其他相关方法\u003e pthread 其他相关方法 # pthread_create() 创建一个线程 pthread_exit() 终止当前线程 pthread_cancel() 中断另外一个线程的运行 pthread_join() 阻塞当前的线程，直到另外一个线程运行结束 pthread_attr_init() 初始化线程的属性 pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合） pthread_attr_getdetachstate() 获取脱离状态的属性 pthread_attr_destroy() 删除线程的属性 pthread_kill() 向线程发送一个信号 NSThread\u003e NSThread # NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread 。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。\n创建、启动线程\u003e 创建、启动线程 # // 1. 创建线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; // 2. 启动线程 [thread start]; // 线程一启动，就会在线程thread中执行self的run方法 // 新线程调用方法，里边为需要执行的任务 - (void)run { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); } 待更新\u0026hellip; 暂时不想更新😭\n","date":"2022-06-30","permalink":"/ios/pthred-nsthread/","section":"IOS","summary":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.","title":"pthread / NSThread"},{"content":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。\nFlex Direction\u003e Flex Direction # 在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\ncolumn | 从上到下 row | 从左到右 column-reverse | 从下到上 row-reverse | 从右到左 Layout Direction\u003e Layout Direction # ltr | 从左到右 rtl | 从右到左 justifyContent\u003e justifyContent # 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有：\nflex-start flex-end space-between space-around space-evenly Align Items\u003e Align Items # 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有\nstretch | 填满次轴 flex-start flex-end center baseline Align Self\u003e Align Self # 作用同 Align Items，但是只作用于被定义的对象，不影响容器子对象。\nAlign Content\u003e Align Content # 适用于被折行的子视图，即，设置属性flexWrap时（Wrap）。效果同justifyContent，是次轴上的justifyContent。\nflex-start flex-end space-between space-around space-evenly Flex Wrap\u003e Flex Wrap # wrap no-wrap Flex Basis, Grow, and Shrink\u003e Flex Basis, Grow, and Shrink # flexBasis: 视图在主轴上的宽度（auto，int） flexGrow: 视图在主轴上的生长能力（int），grow较大则会填充容器。 flexShrink: 视图在主轴上的缩小能力（int），shrink较大视图则会根据basis或width的值显示。\n","date":"2022-06-30","permalink":"/rn/flex-layout/","section":"React Native","summary":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。","title":"React Native Flexbox"},{"content":"","date":"2022-06-30","permalink":"/series/rn/","section":"Series","summary":"","title":"RN"},{"content":"","date":"2022-06-30","permalink":"/tags/%E5%8A%A0%E5%AF%86/","section":"Tags","summary":"","title":"加密"},{"content":" 资源（图片、音频、视频等）\u003e 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.com/tinymind/LSUnusedResources 可执行文件瘦身\u003e 可执行文件瘦身 # 编译器优化 Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -\u0026gt; Code -\u0026gt; Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 ","date":"2022-06-30","permalink":"/oc/ipa/","section":"Objective-C","summary":"资源（图片、音频、视频等）\u003e 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.","title":"安装包瘦身"},{"content":"NSTimer、CADisplayLink定时器\u003e NSTimer、CADisplayLink定时器 # CADisplayLink使用\n@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用\n@interface TMViewController () @property (strong, nonatomic) NSTimer * timer; @end - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:(id)target selector:@selector(linkTest) userInfo:nil repeats:YES]; } - (void)dealloc { [_timer invalidate]; } 以上方式如果将target传为self，则会造成self对timer的强引用，timer又对self强引用，双方释放不了，造成循环引用。\n解决方法\u003e 解决方法 # 创建一个不依赖于self的timer - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@\u0026#34;执行任务\u0026#34;); }]; [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_timer invalidate]; } 添加中间对象（NSProxy），弱引用self然后将消息转发给self。 - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[TMProxy initWithTarget:self] selector:@selector(linkTest) userInfo:nil repeats:YES]; } - (void)dealloc { [_timer invalidate]; } // TMProxy实现 @interface TMProxy () @property (weak, nonatomic) id target; @end @implementation TMProxy + (TMProxy *)initWithTarget:(id)target { TMProxy *proxy = [TMProxy alloc]; proxy.target = target; return proxy; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { return [_target methodSignatureForSelector:sel]; } - (void)forwardInvocation:(NSInvocation *)invocation { [invocation invokeWithTarget:_target]; } @end GCD定时器\u003e GCD定时器 # 由于NSTimer是依赖于RunLoop进行工作的，而RunLoop内部除了需要执行NSTimer事务，同时也可能处理其他事务，所以RunLoop进行计时会又不准确的情况。而GCD不依赖于RunLoop，GCD定时器属于系统层面。所以GCD定时器能够相对准确。\n创建GCD定时器\u003e 创建GCD定时器 # @interface ViewController () @property (strong, nonatomic) dispatch_source_t timer; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0); dispatch_source_set_event_handler(timer, ^{ NSLog(@\u0026#34;gcd timer counting.\u0026#34;); }); dispatch_resume(timer); // 防止timer被释放。 _timer = timer; } @end ","date":"2022-06-30","permalink":"/oc/nstimer/","section":"Objective-C","summary":"NSTimer、CADisplayLink定时器\u003e NSTimer、CADisplayLink定时器 # CADisplayLink使用\n@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用","title":"定时器"},{"content":"在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n查看详情 CPU和GPU\u003e CPU和GPU # CPU（Central Processing Unit，中央处理器）\n对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）\nGPU（Graphics Processing Unit，图形处理器）\n纹理的渲染\n在iOS中是双缓冲机制，有前帧缓存、后帧缓存\n屏幕成像原理\u003e 屏幕成像原理 # 硬件时钟会定时发出垂直同步信号（VSync）\nCPU和GPU需要在这个时间间隔把这一帧处理、缓存、并渲染到屏幕上。\n卡顿产生的原因\u003e 卡顿产生的原因 # 卡顿检测\u003e 卡顿检测 # 平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作\n可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的\n耗电优化\u003e 耗电优化 # 耗电来源\u003e 耗电来源 # CPU处理，Processing\n网络，Networking\n定位，Location\n图像，Graphics\n优化\u003e 优化 # 尽可能降低CPU、GPU功耗\n少用定时器\n优化I/O操作\u003e 优化I/O操作 # 尽量不要频繁写入小数据，最好批量一次性写入\n读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问\n数据量比较大的，建议使用数据库（比如SQLite、CoreData）\n网络优化\u003e 网络优化 # 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化\u003e 定位优化 # 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化\u003e 硬件检测优化 # 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件\n","date":"2022-06-30","permalink":"/oc/performance-optimization/","section":"Objective-C","summary":"在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n查看详情 CPU和GPU\u003e CPU和GPU # CPU（Central Processing Unit，中央处理器）","title":"性能优化"},{"content":"进入 ViewController2\n+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController\n-[ViewController2 viewWillDisappear:] -[ViewController viewWillAppear:] -[ViewController2 viewDidDisappear:] -[ViewController viewDidAppear:] -[ViewController2 dealloc] 当添加了一个子视图时(Storyboard) - 进入\n+[ViewController2 initialize] +[TestView2 initialize] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[TestView2 layoutSubviews] -[TestView2 drawRect:] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 当添加了一个子视图时(Storyboard) - 返回\n-[ViewController2 viewWillDisappear:] -[ViewController viewWillAppear:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[ViewController2 viewDidDisappear:] -[ViewController viewDidAppear:] -[ViewController2 dealloc] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] 单独拆分View2的生命周期\u003e 单独拆分View2的生命周期 # +[TestView2 initialize] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[TestView2 layoutSubviews] -[TestView2 drawRect:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] 给 View2 动态添加一个子视图时\n+[TestView initialize] -[TestView willMoveToWindow:] -[TestView willMoveToSuperview: -[TestView didMoveToWindow] -[TestView didMoveToSuperview] -[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 修改子视图 frame 时\n-[TestView willMoveToWindow:] -[TestView willMoveToSuperview:] -[TestView didMoveToWindow] -[TestView didMoveToSuperview] -[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 简化对View2子视图的操作\u003e 简化对View2子视图的操作 # 被添加时\n+[TestView initialize] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 被修改时 frame 时\n-[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] ","date":"2022-06-30","permalink":"/oc/uiviewcontroller-life-cycle/","section":"Objective-C","summary":"进入 ViewController2\n+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController","title":"探究UIViewController生命周期"},{"content":"首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。\n应用沙盒文件夹\u003e 应用沙盒文件夹 # Application（应用程序包）: 包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。\nDocuments: 文档目录，要保存程序生成的数据，会自动备份到iCloud中。保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录。⚠️ 不要保存从网络上下载的文件，否则会无法上架。\nLibrary：\n用户偏好，使用NSUserDefault直接读写。 如果想数据及时写入磁盘，还需要调用同步方法。 保存临时文件，“后续需要使用”，例如：缓存图片，离线数据（地图数据） 系统不会清理cache目录中的文件，所以要求程序开发时，必须提供cache目录的清理解决方案。 Caches: 存放体积大而又不需要备份的数据 Preference: 保存应用的所有偏好设置，iCloud会备份设置信息。 Tmp: 临时文件，系统会自动清理。重启时会清理。保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。\n存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除。 保存临时文件，“后续无需使用” tmp目录中的文件，系统会自动清理。 重启手机，tmp目录会被清空。 系统磁盘空间不足时，系统也会自动清理。 iOS应用可执行文件里面都有什么？\n静态库 iOS APP可执行文件的组成\n","date":"2022-06-30","permalink":"/oc/data-store/","section":"Objective-C","summary":"首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。\n应用沙盒文件夹\u003e 应用沙盒文件夹 # Application（应用程序包）: 包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。","title":"数据持久化、缓存"},{"content":"","date":"2022-06-30","permalink":"/tags/%E7%BA%BF%E7%A8%8B/","section":"Tags","summary":"","title":"线程"},{"content":"","date":"2022-06-13","permalink":"/tags/app-lanuch/","section":"Tags","summary":"","title":"App Lanuch"},{"content":"APP启动的分类\u003e APP启动的分类 # 冷启动\u003e 冷启动 # 冷启动（Cold Launch）：从零开始启动APP\n热启动\u003e 热启动 # 热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP\n💡 APP启动优化主要是针对冷启动进行优化的 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -\u0026gt; Run -\u0026gt; Arguments）\nDYLD_PRINT_STATISTICS设置为1\n如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1\n冷启动的三个阶段\u003e 冷启动的三个阶段 # dyld runtime main dyld\u003e dyld # dyld，即dynamic link editor，Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）\ndyld做的事情\u003e dyld做的事情 # 装载APP的可执行文件，同时会递归加载所有依赖的动态库 当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理 APP启动时，runtime做的事情\u003e APP启动时，runtime做的事情 # 调用map_images进行可执行文件内容的解析和处理 在load_iamges中调用call_load_methods，调用所有Class和Category的+load方法 进行各种objc结构的初始化（注册Objc类、初始化类对象等等） 调用C++静态初始化器和__attribute__((constructor))修饰的函数 到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP \u0026hellip;）都已经按格式成功加载到内存中，被runtime所管理\nmain\u003e main # APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库 并由runtime负责加载成objc定义的结构 所有初始化工作结束后，dyld就会调用main函数 接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法 启动优化按不同的阶段\u003e 启动优化按不同的阶段 # dyld\u003e dyld # 减少动态库、合并一些动态库（定期清理不必要的动态库） 减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类） 减少C++虚函数数量 Swift尽量使用struct runtime\u003e runtime # 用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load\nmain\u003e main # 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中 按需加载 ","date":"2022-06-13","permalink":"/oc/app-lanuch/","section":"Objective-C","summary":"APP启动的分类\u003e APP启动的分类 # 冷启动\u003e 冷启动 # 冷启动（Cold Launch）：从零开始启动APP","title":"App Lanuch"},{"content":"","date":"2022-06-13","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001-01-01","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"}]