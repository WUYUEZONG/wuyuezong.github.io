[{"content":"交流\nQQ【Mac窗口手势交流群】： 470741842\nTelgram\n窗口手势\u003e 窗口手势 # 如果您使用妙控鼠标，您可以通过一根手指（触控板则是双指），在窗口的标题栏操作以达到对应的效果。但是所有手势对本应用无效，原因是本应用不是一个可激活窗口，不会占用您的顶部菜单栏，当你点击窗口以外区域，应用窗口会自动消失。\n下载\u003e 下载 # 去123云盘下载 去Gitee下载 去GitHub下载 安装\u003e 安装 # 将下载的文件夹中Magic-Ges-Lite.app文件拖动到应用程序文件夹即可完成安装 如果您遇到“无法打开”？ 去：设置 \u0026mdash; 隐私与安全性 \u0026mdash; 仍要打开 就可以继续使用了。 开启辅助功能\u003e 开启辅助功能 # 软件中会使用到macOS相关的辅助功能API，所以需要您的辅助功能权限，才能相应的完成对其他窗口的设置。\n如何开启辅助功能？\n找到设置辅助功能页面：设置 \u0026mdash; 隐私与安全性 \u0026mdash; 辅助功能\n您也可以通过软件的弹窗直达设置页面\n然后，通过 \u0026quot;+\u0026quot; 添加软件，或者将应用拖入。并开启开关。然后重新打开软件。 如果软件中显示已开启状态，则说明您操作成功。 开启自启\u003e 开启自启 # 设置开机自启，重启系统后无需手动开启，以便您可以随时使用手势。当然，这不是强制要求的，开启与否取决于您的喜好。\n长按手势\u003e 长按手势 # 当做出滑动手势后，不松开，一定时间后该手势会变为长按手势，相应的则会触发长按的相关事件。您可以设置该时长。\n手势灵敏度\u003e 手势灵敏度 # 如果您设置该项，一定程度能过滤很小幅度滑动的操作，但是如果能觉得这个过滤是不对的，请调整至高\n手势介绍\u003e 手势介绍 # 快速滑动\n当鼠标悬停于窗口顶部，向下快速滑动，触发窗口最小化 当鼠标悬停于窗口顶部，向上快速滑动，触发窗口最大化 当鼠标悬停于窗口顶部，向左快速滑动，触发窗口对齐占屏幕左边 当鼠标悬停于窗口顶部，向右快速滑动，触发窗口对齐占屏幕右边 快速滑动，后稍等松手\n当鼠标悬停于窗口顶部，向下滑动并保持一定时间松开，将触发关闭窗口 当鼠标悬停于窗口顶部，向上滑动并保持一定时间松开，将触发点按全屏按钮，在窗口全屏时则退出全屏 当鼠标悬停于窗口顶部，向左滑动并保持一定时间松开，窗口占屏幕左边7/8 当鼠标悬停于窗口顶部，向右滑动并保持一定时间松开，窗口占屏幕右边7/8 停止或退出应用\u003e 停止或退出应用 # 您可以在状态栏找到如下图标进行控制。 关于\u003e 关于 # 项目地址\nGitHub\nGitee\n代码尚未开源，也没有做好准备，暂且提供安装包供喜欢的人使用。\n联系我\nGitHub@WUYUEZONG\n邮件@WUYUEZONG\nBUGs反馈 - GitHub\nBUGs反馈 - Gitee\n交流\nQQ【Mac窗口手势交流群】： 470741842\nTelgram\n捐赠\u003e 捐赠 # 这个东西挺重要的😄\n更新\u003e 更新 # 1.0.2 预发布\u003e 1.0.2 预发布 # 2022-12-14\n修复退出全屏残影问题； 操作提示HUD添加可选项； 更精准找到对应窗口 1.0.1\u003e 1.0.1 # 2022-12-13\n修复已知BUG\n1.0\u003e 1.0 # 2022-12-12\n第一个版本发布\n","date":"2022-12-12","permalink":"/apps/magic-gesture/","section":"App","summary":"简单的增强你的妙控鼠标、触控板，使它们更好用","title":"Magic Gesture"},{"content":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平\n","date":"2022-12-12","permalink":"/","section":"WUYUEZONG","summary":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平","title":"WUYUEZONG"},{"content":"","date":"2022-12-02","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2022-12-02","permalink":"/tags/%E5%85%B3%E4%BA%8E/","section":"Tags","summary":"","title":"关于"},{"content":"关于网站\u003e 关于网站 # 本站是基于 Hugo \u0026amp; blowfish 并依托于 GitHub Pages 搭建的。\n如果你也想拥有一个自己的网站可以点开上面👆的链接找到教程。\n其实，这个网站成形确实经历了一些时间，中途经过 Notion、 GitBook、 Hexo 最终当我看到 blowfish 的模版案例一下就被惊艳到，才确定使用这个框架。 Notion 是我最开始使用的笔记软件，简洁高效，一行一行定义文本（内容）很有意思，\u0026quot;/\u0026quot; 很简单就能呼出所有组件，但主题这种东西总觉得差点意思。一段时间不记笔记了，然后又开始记笔记发现 GitBook 是长在我审美点上的笔记本，所以开始使用 GitBook 和 Notion 一样的输入形式，还能同步github确实非常不错，可惜的是，浏览器输入时时不时抽风吃字，以及迷一样的访问连通性，还是让我放弃了。不能一件导出 .md 让我迁移笔记又痛苦了一番。\n之后找到个人建站，感觉 Hexo 使用的人挺多的，主题也丰富，最后还是沦陷在 blowfish 石榴裙下，现在用着感觉自定义也方便的，目前打算自己配一套黑色的主题，在完善中\u0026hellip;\n关于我\u003e 关于我 # 普普通通iOS程序员 简历2022 2022-11-13\u0026middot;1 分钟 Resume 为什么叫 \u0026ldquo;a half fish\u0026rdquo; ?\u003e 为什么叫 \u0026ldquo;a half fish\u0026rdquo; ? # 经常很多知识学得不深，在笔记里可能也有体现。希望勉励自己吧。\n致谢\u003e 致谢 # 字体\n仓耳今楷04-W02 ｜ 所有的正文及标题字体\nNickainley-Normal ｜ 我的签名\nUbuntuMono ｜ 代码字体\n","date":"2022-12-02","permalink":"/about/","section":"WUYUEZONG","summary":"关于这个网站，关于我，一些要说明的事。","title":"关于"},{"content":"","date":"2022-12-02","permalink":"/tags/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"Tags","summary":"","title":"关于我"},{"content":"","date":"2022-12-02","permalink":"/tags/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"关于网站"},{"content":"别看未来，做好当下。\n改变不了别人，可以试图说服自己改变自己。\n这种情况，大多是自己思考得太长远了。在人生中，工作会持续很长一段时间。如果期望过高或心思太重，就容易失望或焦虑。\n从我的经验来看，不喜欢工作的大多数是人际关系出了问题。对有些人而言，不管他们做什么工作，他们都讨厌工作，这也许是与人交往上出现了问题。\n遇到不懂的事，就说‘我不懂，麻烦你了，请教教我’。\n遇到不明白的地方，就说‘我不明白，请你告诉我，我会学习’。\n遇到做不了的事情，就说‘我做不了，请告诉我如何做’。\n坦率的性格大概是我追求的东西，面对任何事。（勇敢）\n人生不必太用力。\n虽说是鸡汤文学，但很多事情还是需要被时常提起才有记忆。鸡汤文学它没有错，这主要取决于你的选择是否敢于实践。\n","date":"2022-12-01","permalink":"/posts/everythingworth/","section":"Posts","summary":"《人间值得》 \u0026mdash; 读书笔记。人生不必太用力，坦率地接受每一天","title":"人间值得"},{"content":"","date":"2022-12-01","permalink":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"读书笔记"},{"content":"基本类型\u003e 基本类型 # Int\nDouble\nSwift能够安全的存储15～16位数的Double类型，例如：\n// _ 数字中 _ 会被自动忽略 let a: Double = 123_456_789_012_345 Decimal\n精度要求较高时使用，比如涉及金钱。\nSwift能够安全的存储38～39位数的Decimal类型，初始化时注意，通过Int\\Double转换过来可能会有误差，通过String则更为精准。\nString\nBool\nTuple\nlet allen = (name: \u0026#34;allen\u0026#34;, height: 170) let (_, height) = allen print(\u0026#34;allen height\u0026#34;, height) ","date":"2022-11-29","permalink":"/swift/","section":"Swift","summary":"基本类型\u003e 基本类型 # Int\nDouble","title":"Swift"},{"content":"LLVM中间代码\u003e LLVM中间代码 # llvm\nObjective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation\n可以使用以下命令行指令生成中间代码\nclang -emit-llvm -S main.m 符号 说明 @ 全局变量 % 局部变量 alloca 在当前执行的函数的堆栈中分配内存，当该函数返回到其调用者时，将自动释放内存 i32 32位4字节的整数 align 对齐 load 读出 store 写入 icmp 两个整数值比较，返回布尔值 br 选择分支，根据条件来转向label，不根据条件跳转的话类似 goto label 代码标签 call 调用函数 ","date":"2022-11-24","permalink":"/ios/llvm/","section":"IOS","summary":"LLVM中间代码\u003e LLVM中间代码 # llvm\nObjective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation","title":"Llvm"},{"content":"共用体\u003e 共用体 # 位域\n// 位域 struct HGBitFiled { uintptr_t tall:1; uintptr_t rich:1; uintptr_t handsome:1; }; 将两个个BOOl类型存储在一个二进制数上。\nhandsome tall // 设定tall handsome初始值。 #define IS_TALL_MASK (1\u0026lt;\u0026lt;0) #define IS_HANDSOME_MASK (1\u0026lt;\u0026lt;1) // 定义共用体 union { char bits; //位域，只是说明作用，说明tall站1位，handsome站1位 struct { char tall:1; char handsome:1; }; } _isTallHandsom; // 通过位运算实现方法。 - (void)setTall:(BOOL)tall { if (tall) { // _isTallHandsom.bits = 0b00000001 = true _isTallHandsom.bits |= IS_TALL_MASK; } else { // 1. ～ 取反：0b11111110 \u0026amp; 0b00000001 = 0b00000000 = false _isTallHandsom.bits \u0026amp;= ~IS_TALL_MASK; } } - (BOOL)isTall { return (_isTallHandsom.bits \u0026amp; IS_TALL_MASK); } - (void)setHandsome:(BOOL)handsome { if (handsome) { _isTallHandsom.bits |= IS_HANDSOME_MASK; } else { _isTallHandsom.bits \u0026amp;= ~IS_HANDSOME_MASK; } } - (BOOL)isHandsome { return (_isTallHandsom.bits \u0026amp; IS_HANDSOME_MASK); } // 使用 [self setTall:YES]; [self setHandsome:NO]; NSLog(@\u0026#34;tall is %d, handsome is %d\u0026#34;, [self isTall], [self isHandsome]); ","date":"2022-11-24","permalink":"/study/symbiont/","section":"学习","summary":"共用体\u003e 共用体 # 位域\n// 位域 struct HGBitFiled { uintptr_t tall:1; uintptr_t rich:1; uintptr_t handsome:1; }; 将两个个BOOl类型存储在一个二进制数上。","title":"Symbiont"},{"content":"位运算（\u0026amp; | ^ ~ \u0026laquo; \u0026raquo;）\n\u0026amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如\n1 0 0 1 1 \u0026amp; 1 1 0 0 1 ---------------- 1 0 0 0 1 | 或运算 两个位都是 0 时，结果才为 0，否则为 1，如\n1 0 0 1 1 | 1 1 0 0 1 ---------------- 1 1 0 1 1 ^ 异或运算，两个位相同则为 0，不同则为 1，如\n1 0 0 1 1 ^ 1 1 0 0 1 ---------------- 0 1 0 1 0 ~ 取反运算，0 则变为 1，1 则变为 0，如\n~ 1 0 0 1 1 ---------------- 0 1 1 0 0 \u0026laquo; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如\nint a = 8; a \u0026lt;\u0026lt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0100 0000 \u0026raquo; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如\nunsigned int a = 8; a \u0026gt;\u0026gt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0000 0001 int a = -8; a \u0026gt;\u0026gt; 3; 移位前：1111 1111 1111 1111 1111 1111 1111 1000 移位前：1111 1111 1111 1111 1111 1111 1111 1111 参考阅读\u003e 参考阅读 # 位运算有什么奇技淫巧？\n应用\u003e 应用 # 多选枚举\n// 定义MYEnum枚举 typedef enum { EnumTypeNone = 0, EnumType01 = 1\u0026lt;\u0026lt;0, EnumType02 = 1\u0026lt;\u0026lt;1, EnumType03 = 1\u0026lt;\u0026lt;2 } MYEnum; // 声明MYEnum类型的枚举 MYEnum type = EnumType01 | EnumType02; // 使用MYEnum枚举 - (NSArray *)getEnumCounts:(MYEnum) enumType { NSMutableArray * arr = [[NSMutableArray alloc] init]; if (enumType \u0026amp; EnumType01) { [arr addObject:@(EnumType01)]; } if (enumType \u0026amp; EnumType02) { [arr addObject:@(EnumType02)]; } if (enumType \u0026amp; EnumType03) { [arr addObject:@(EnumType03)]; } return arr; } ","date":"2022-11-24","permalink":"/study/bit-operation/","section":"学习","summary":"位运算","title":"Bit Operation"},{"content":"","date":"2022-11-23","permalink":"/tags/array/","section":"Tags","summary":"","title":"Array"},{"content":"通过设计一个可变数组，来学习数组\n1. 完成基础的封装\u003e 1. 完成基础的封装 # 新建类Array\n声明data, size用于内部管理数据，并将其私有化，防止外部修改数据。\n实现基本个构造函数Array(int capacity){}可以自定义数组大小，实现一个无参构造函数Array(){}方便直接创建capacity=10的对象。\n根据经验提供一些简便方法\ngetSize()获取当前数组个数；\ngetCapacity()获取当前数组容量；\nisEmpty()判断数组是否为空；\npublic class Array { private int[] data; private int size; // 构造函数 public Array(int capacity) { data = new int[capacity]; size = 0; } // 无参构造函数，默认capacity=10 public Array() { this(10); } // 获取数组个数 public int getSize() { return size; } // 获取数组容量 public int getCapacity() { return data.length; } // 返回数组是否为空 public boolean isEmpty() { return size == 0; } } 2. 向数组中添加元素\u003e 2. 向数组中添加元素 # 提供向数组中添加元素的接口，使得可以方便的在数组的任意位置添加元素。那我们如何做？\n这里我们只考虑容量足够的情况，后面再完善整个逻辑。可以想象，插入的过程，首先需要其他数据向后位移，以保证插入的位置可以有空间存放新数据。\npublic class Array { ... // 向数组指定位置添加元素 public add(int index, int e) { // 将想要插入的位置开始的元素都向后位移一位 for (int i = size - 1; i \u0026gt;= index; i++) data[i+1] = data[i]; // 插入元素后对应的个数需要加1 size++; } } 然后，这里可以提供一些简便方法，比如，从第一个位置插入，从最后一个位置插入。\n","date":"2022-11-23","permalink":"/data-structure/array/","section":"Data Structure","summary":"设计一个可变数组","title":"设计一个可变数组"},{"content":"","date":"2022-11-23","permalink":"/data-structure/","section":"Data Structure","summary":"","title":"Data Structure"},{"content":" APP IOS 数据结构 React Native ","date":"2022-11-23","permalink":"/study/","section":"学习","summary":"学习相关资料整理～","title":"学习"},{"content":"","date":"2022-11-23","permalink":"/tags/macos/","section":"Tags","summary":"","title":"Macos"},{"content":"查看当前鼠标速度\ndefaults read -g com.apple.mouse.scaling 更改鼠标速度， 10 表示要设置的速度，可以根据自己手感设置，重启生效。\ndefaults write -g com.apple.mouse.scaling 10 如果设置完去系统设置中修改鼠标速度，则命令设置的速度会失效 ","date":"2022-11-23","permalink":"/posts/change-macos-mouse-speed/","section":"Posts","summary":"通过终端更改Macos鼠标的速度","title":"通过终端更改Macos鼠标的速度"},{"content":"","date":"2022-11-23","permalink":"/tags/%E9%BC%A0%E6%A0%87/","section":"Tags","summary":"","title":"鼠标"},{"content":"","date":"2022-11-23","permalink":"/tags/available/","section":"Tags","summary":"","title":"Available"},{"content":"废弃了一个 API\u003e 废弃了一个 API # @available(*, deprecated, renamed: \u0026#34;newMethod(number:)\u0026#34;, message: \u0026#34;不要再使用该方法了\u0026#34;) func oldMethod(value: Int) { print(value) } func newMethod(number: Int) { print(\u0026#34;值为：\\(number)\u0026#34;) } @available\u003e @available # @available 有这么几种声明：\n约束平台和版本\n@available(platform version , platform version ..., *) platform 是指平台，可以是 iOS, macCatalyst, macOS / OSX, tvOS, watchOS 等。 更多可以查看 version 是指版本 , 分隔多个版本化平台 * 表示该 API 可用于所有其他平台。 举例\n@available(iOS 14, *) class AppIntro { } 在调用的时候，我们需要通过 #available\nif #available(iOS 14, *) { let appIntro = AppIntro() } else { // .. 14以下的版本调用 } 当然我们也可以指定多个平台：\n@available(iOS 14, macOS 11.0, *) class AppIntro { } 约束swift版本\n@available(swift version) 比如需要 Swift 5.5 或更高版本才能使用 oldMethod：\n@available(swift 5.5) func oldMethod(value: Int) { print(value) } 约束指定平台的 introduced, deprecated, obsoleted 和 unavailable\n// With introduced, deprecated, and/or obsoleted @available(platform | * , introduced: version , deprecated: version , obsoleted: version , renamed: \u0026#34;...\u0026#34; , message: \u0026#34;...\u0026#34;) // With unavailable @available(platform | *, unavailable , renamed: \u0026#34;...\u0026#34; , message: \u0026#34;...\u0026#34;) platform：平台名称 introduced：开始引进的版本号 deprecated：从指定平台开始过期的版本 obsoleted：从指定平台开始废弃的版本（注意弃用的区别，deprecated 是还可以继续使用，只不过是不推荐了，obsoleted 是调用就会编译错误） message：给出一些附加信息 renamed：重命名后的新名称 unavailable：指定平台上是无效的 这些参数可以相互组合使用。下面列举几个常用案例：\n@available(iOS 13, *) @available(tvOS, unavailable) @available(macCatalyst, unavailable) func handleShakeGesture() { … } ","date":"2022-11-23","permalink":"/ios/available-attribute/","section":"IOS","summary":"@available与调用方进行沟通","title":"Available Attribute"},{"content":"","date":"2022-11-23","permalink":"/tags/rn/","section":"Tags","summary":"","title":"RN"},{"content":"","date":"2022-11-23","permalink":"/series/rn/","section":"Series","summary":"","title":"RN"},{"content":"","date":"2022-11-23","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2022-11-23","permalink":"/tags/use-effect/","section":"Tags","summary":"","title":"Use Effect"},{"content":"useEffect\u003e useEffect # 使用 Effect Hook useEffect 类似一个 class 的生命周期； UI每次需要更新会调用 useEffect； 所以需要防止 useEffect 中重复刷新，添加参数让 useEffect 对比，使 useEffect 自动对比需不需要执行； 一个方法内可以有多个 useEffect。 // navigation 控制是否需要执行这个 useEffect useEffect(() =\u0026gt; { navigation.setOptions({headerShown: false}); }, [navigation]); // page 控制是否需要执行这个 useEffect useEffect(() =\u0026gt; { fetchPhotoListWith(page) }, [page]); // 或者多个参数 控制是否需要执行这个 useEffect // 如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。 useEffect(() =\u0026gt; { navigation.setOptions({headerShown: false}); fetchPhotoListWith(page) }, [navigation, page]); ","date":"2022-11-23","permalink":"/rn/use-effect/","section":"React Native","summary":"UseEffect简单介绍","title":"Use Effect"},{"content":"","date":"2022-11-16","permalink":"/tags/%E6%80%9D%E8%80%83/","section":"Tags","summary":"","title":"思考"},{"content":"","date":"2022-11-16","permalink":"/tags/%E7%89%87%E5%88%BB/","section":"Tags","summary":"","title":"片刻"},{"content":"片刻，顾名思义这里是片刻，某一刻想起的事情想记录的话，在那一片刻，如果可以，它会被记录在这里。\n2022-12-01\n对于Mac鼠标或触摸板的用户 Swish是强烈推荐的一款通过手势简化操作的应用。\n2022-11-29\n昨夜·雨🌧️\n昨天又吵了一架，从上车开始就念叨我，因为下了些雨🌧️，突然冒出一句：“要是有车就好了”，我附和一声，接着大概是雨水溅到她衣服上，于是开始抱怨起来，一抱怨我的脾气就上来了，越想越不是滋味，怎么还苦了你了？越想就越不对付，电动车油门拧死，恨不得拧断，一路横冲直撞，见缝插针、一度想前面哪个急刹车，直接怼上去。快到家的时候雨🌧️大了。略带生气且怕再次激怒我的说：“雨大了…雨大了…”。气急败坏的我也没顾上什么急刹停一侧，她下车，我咒骂一声，扬长而去。\n她的版本：\n昨晚我公司红绿灯路口等他来接我，黑夜里天空洒下蒙蒙细雨，在街口的路边灯光下清晰可见，等了一会儿，他骑车车过来了。我看到他时他穿着一件黄色的雨衣骑车车到我面前，后座已经被雨水弄湿了，他把伞拿给我让我用雨伞把车水上的水擦去，但是雨伞的材质怎么可能把雨水擦干净呢？我心里想着但是没有说出来，那时候担心他又突然暴躁自己开车走了。我随便擦了下就把水坐上去了，坐上去的时候我的衣服已经湿了。坐上车他把车子骑了起来，他那件水衣是上的水全部洒在我的衣服上，把我的衣服弄湿了，雨衣还随意的往我身上刮，他也不知道吧整理下雨衣，和他说了以后还吼我说怎么不知道自己拉着雨衣。我一边拿着伞还要把他身上的雨衣拉住不要让他乱飞。那时候雨也不是很大，我没有撑伞，我就说你为什么要穿雨衣，把我的衣服都弄湿了。然后我想了下有车下雨的时就不会那么麻烦了，就说出一句：“要是有车就好了”，他就把电动车油门拧死，恨不得拧断，一路横冲直撞，见缝插针。快到家的时候雨大了，我略带生气但是担心他发疯，就说了雨大了，雨大了。他一个急刹车就把车子停了下来，我就下车了。走回家的时候，雨特别大，撑着伞雨水还是把我的衣服打湿了，旁边的车子用遇到水的时候依旧没有减速，把水溅到我的身上。我一路上被雨淋着，躲着路上来往的车辆，艰难的走回了家。\n到家的时候，我来没来得及把湿透的衣服换下，他就大声要求我把门口的鞋子先收整好，完全不顾我的感受。他就是一个被家里宠坏的小孩，现在很自私，对于别人的困境没有任何同理心，只优先考虑自己的自私鬼，只会想是不是又打击到他的自尊。接着大声和我讲离婚，我一直没有说话不理他，真的是很搞笑。\n2022-11-25\n上大学的时候应该迅速找到一件自己喜欢做的事，并专心去做，这很大程度决定了你未来混得好不好。\n2022-11-24\n要有独立思考的能力。\n重学数据结构，希望坚持学完，并有所理解。\n其实很多事做了不一定有用，但是做了，就有机会可以用。\n勤奋这件事情100%不会吃亏，保底都是一定的运动量或者少许的知识积累。有方向的勤奋最为明智。\n2022-11-22\n自己的事情自己不积极，那也不能指望别人积极给你做吧。\n2022-11-22\n风口！机会！太想追求这些了。盲目的追求，导致心境浮躁。\n应该每个人都有一个发财梦。\n越来越难，集中精神做一件小事。\n以前以为抖音可以让我更快更方便的了解一些事，现在回想，都是每天重复的东西，而且片面，反而影响个人的专注力，对知识点的系统认知缺乏。需要控制。\n看长文越来越难了。这一点很不好。\n2022-11-21\n一早起来。生气了，奇奇怪怪，像个小孩。\n2022-11-18\n听说老家那边风控了，晚上得打个电话。\n我炒牛肉给你吃！\n吃了！味道可以\n2022-11-17\n那么希望你可以佐证分析，不要看什么就是什么\n希望你知道能接受什么不能接受什么，都要有想法，不是一股脑看啥啥不行，看啥啥喜欢。\n致，思考。\n1\n最近我俩都挺想买车，实际上她比我更想，恨不得立马就有，而我还好，毕竟怎么样都是生活，她知道我喜欢极氪，但可能不是她的意向车型，所以隔三差五给我说极氪的坏消息，我想她大概的意思是：“听我的就好，想什么极氪”。\n有时候觉得她挺聪明的，这种聪明大多像小孩的机灵，令人不知所措，好玩又有点无可奈何。\n无论怎样，没有令人信服的理由是不能赞同的。\n2\n我俩都是大小孩，思考、行为都没有让谁信服，所以会有很多争吵，不过这个争吵也会马上过去，有可能就是下一秒，这么想来似乎有点可笑，感觉像是时间到了要吵，时间到了不吵。😄\non Unsplash 3\n她\n：我好饿呀\n：满脑子吃的东西\n：我怎么这么优秀呢\n2022-11-16\n每天逼自己写点东西，有利于梳理大脑的思维逻辑，长时间训练它可以变得更活跃以及灵敏。\n情绪易怒是自我管理失败。\n我猜测，大脑也有某种肌肉记忆每每出现类似情况时，它会下意识反应出你以前的情绪状态，那么如何预防下次的冲动？我感觉可以去接受更多期望的一面，也是让大脑形成肌肉记忆，让经验控制住它。\n","date":"2022-11-16","permalink":"/posts/moments/","section":"Posts","summary":"片刻所想，可以简单，又或者囫囵，都可以被记忆","title":"片刻"},{"content":"","date":"2022-11-16","permalink":"/tags/%E8%AE%B0%E4%BA%8B/","section":"Tags","summary":"","title":"记事"},{"content":"","date":"2022-11-15","permalink":"/oc/","section":"Objective-C","summary":"学习Objective-C的相关笔记！","title":"Objective-C"},{"content":" Objective-C学习手册，这个是我个人学习OC语言的记录笔记，内容可能有些零散。\nSwift\n这些就是一点开发中的学习\n","date":"2022-11-15","permalink":"/ios/","section":"IOS","summary":"Objective-C学习手册，这个是我个人学习OC语言的记录笔记，内容可能有些零散。\nSwift\n这些就是一点开发中的学习","title":"IOS"},{"content":"","date":"2022-11-15","permalink":"/rn/","section":"React Native","summary":"","title":"React Native"},{"content":"","date":"2022-11-14","permalink":"/tags/ios/","section":"Tags","summary":"","title":"iOS"},{"content":"版本管理\u003e 版本管理 # 多环境配置中，我们首先得清楚PROJECT / TARGET / SCHEME三者的含义 PROJECT\n包含了项目所有代码、资源文件、所有信息，就是一个完整的项目；\nTARGET\n对指定代码和资源的具体构建方式，即，一个target对应一份info.plist和xcconfig文件。\nSCHEME\n是对指定target的环境配置。例如，Run时使用Debug配置文件还是用Release配置文件等等。\nxcconfig是什么？\u003e xcconfig是什么？ # xcconfig就是target的另一种配置文件。即下面视图的内容，在xcconfig中可以对一下内容修改或者合并。\n所以，创建多个target，自然可以控制多个应用版本；\n多个target需要注意的是，你需要维护多个info.plist以及target中的设置（Build Setting等）\n不过target有个好处就是能控制文件是否参与编译。\n如果，多版本中，只是对target中设置有所区别，那么使用xcconfig文件来控制版本是更为方便的，无需维护多个info.plist，不同设置使用不同xcconfig文件即可。\n不同需求，可根据情况实现。\nMach-O\u003e Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。\nMach-O文件的分类\nExecutable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成\u003e Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)\nHeader\u003e Header # 指明了 CPU 架构、大小端序、文件类型、Load Commands 个数等一些基本信息，Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境，64位架构为例， Header结构定义如下\nstruct mach_header_64 { uint32_t magic; /* mach magic number identifier 魔数，用于快速确认该文件用于64位还是32位 */ cpu_type_t cputype; /* cpu specifier，CPU**类型，比如 arm */ cpu_subtype_t cpusubtype; /* machine specifier，对应的具体类型，比如arm64、armv7 */ uint32_t filetype; /* type of file，文件类型，比如可执行文件、库文件、Dsym文件，demo中是2 `MH_EXECUTE`，代表可执行文件*/ uint32_t ncmds; /* number of load commands 加载命令条数 */ uint32_t sizeofcmds; /* the size of all the load commands 所有加载命令的大小 */ uint32_t flags; /* flags 标志位 */ uint32_t reserved; /* reserved 保留字段 */ }; filetype\nOBJECT，指的是 .o 文件或者 .a 文件； EXECUTE，指的是 IPA 拆包后的文件； DYLIB，指的是 .dylib 或 .framework 文件； DYLINKER，指的是动态链接器； DSYM，指的是保存有符号信息用于分析闪退信息的文件。 LLVM-NM\u003e LLVM-NM # 待更新\u0026hellip;\n参考 了解Mach-O文件 2\n","date":"2022-11-14","permalink":"/ios/link-and-symbol/","section":"IOS","summary":"版本管理\u003e 版本管理 # 多环境配置中，我们首先得清楚PROJECT / TARGET / SCHEME三者的含义 PROJECT","title":"Link and Symbol"},{"content":"","date":"2022-11-14","permalink":"/tags/mach-o/","section":"Tags","summary":"","title":"Mach-O"},{"content":"","date":"2022-11-14","permalink":"/tags/autolayout/","section":"Tags","summary":"","title":"AutoLayout"},{"content":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。\n避免操作updateConstants()\u003e 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。\nfunc updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系\u003e 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。\n无需视图时使用hideen属性，而不是删除约束\u003e 无需视图时使用hideen属性，而不是删除约束 # 通过激活或停用改变视图，而不是修改约束。\u003e 通过激活或停用改变视图，而不是修改约束。 # UILabe、UIImageView、自动测量尺寸并不会消耗多少性能。 如果需要频繁计算视图尺寸或已经知道该视图尺寸可以重写属性，提高部分性能。 override var intrinsicContentSize: CGSize { return CGSize(width: UIView.noIntrinsicMetric, height: UIView.noIntrinsicMetric) } 想了解的更多可以看 WWDC18: High Performance Auto Layout 相关视频、资料。\n","date":"2022-11-14","permalink":"/ios/high-performance-autolayout/","section":"IOS","summary":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。","title":"High Performance Autolayout"},{"content":"","date":"2022-11-14","permalink":"/tags/wwdc/","section":"Tags","summary":"","title":"WWDC"},{"content":"","date":"2022-11-14","permalink":"/tags/ctmediator/","section":"Tags","summary":"","title":"CTMediator"},{"content":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","date":"2022-11-14","permalink":"/ios/center-core-mode/","section":"IOS","summary":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","title":"Target-Action组件化方案CTMediator"},{"content":"","date":"2022-11-14","permalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"中间人模式"},{"content":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;\nPrivacy - Face ID Usage Description OR\nNSFaceIDUsageDescription 引入相关的库\nLocalAuthentication 引入头文件\n#import \u0026lt;LocalAuthentication/LocalAuthentication.h\u0026gt; 使用\u003e 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.localizedFallbackTitle = @\u0026#34;localizedFallbackTitle\u0026#34;; NSError *error; LAPolicy policy = LAPolicyDeviceOwnerAuthenticationWithBiometrics; if ([context canEvaluatePolicy:policy error:\u0026amp;error]) { [context evaluatePolicy:policy localizedReason:@\u0026#34;通过Home键验证已有指纹\u0026#34; reply:^(BOOL success, NSError * _Nullable error) { if (success) { // success MNLog(self, @\u0026#34; successed!!!\u0026#34;); } else if (error) { MNLog(self, @\u0026#34; face error.code = %@\u0026#34;, error); switch (error.code) { case LAErrorAuthenticationFailed: break; default: break; } } else { // other MNLog(self, @\u0026#34; face id the other reason!!!\u0026#34;); } }]; } else { // error MNLog(self, @\u0026#34;还没有设置id, %@\u0026#34;, error); } } ","date":"2022-11-14","permalink":"/ios/authentication-biometrics/","section":"IOS","summary":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;","title":"Authentication Biometrics"},{"content":"","date":"2022-11-14","permalink":"/tags/faceid/","section":"Tags","summary":"","title":"FaceID"},{"content":"","date":"2022-11-14","permalink":"/tags/touchid/","section":"Tags","summary":"","title":"TouchID"},{"content":"","date":"2022-11-14","permalink":"/series/objc/","section":"Series","summary":"","title":"Objc"},{"content":"","date":"2022-11-14","permalink":"/tags/oc/","section":"Tags","summary":"","title":"OC"},{"content":"对 NSNumber、NSString、NSDate 优化。\n当以上类型对象需要存储的数据没有超出固定分配的字节，该对象可以被看作是简单数据类型；而当对象需要存储的数据超过了固定字节，该对象就会变成真正的对象。\n","date":"2022-11-14","permalink":"/oc/togged-pointer/","section":"Objective-C","summary":"对 \u003ccode\u003eNSNumber、NSString、NSDate\u003c/code\u003e 优化。","title":"Togged Pointer"},{"content":"","date":"2022-11-14","permalink":"/tags/copy/","section":"Tags","summary":"","title":"Copy"},{"content":"strong / weak / copy(ARC环境)\nAutomatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code, the object graphs, and the relationships between objects in your application.\nAutomatic Reference Counting(ARC)技术是用于OC对象的内存管理。即在适当的时候对OC对象retain和release操作。 strong是强引用，会持有对象，引用计数器会+1\u003e strong是强引用，会持有对象，引用计数器会+1 # strong是为了告诉编译器（xcode），被strong修饰的对象是强引用，需要retain操作，引用计数器会+1，默认情况下声明变量都是隐式strong申明。\n默认情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; NSArray *strArr = testArr; testArr = nil; NSLog(@\u0026#34;print str is %@\u0026#34;, strArr); // 打印结果 2021-05-30 15:33:14.931372+0800 Strong\u0026amp;Weak[3480:197342] print str is ( a, b ) __strong修饰情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; __strong NSArray * strongStrArr = testArr; testArr = nil; NSLog(@\u0026#34;print strongStr is %@\u0026#34;, strongStrArr); // 打印结果 2021-05-30 15:37:30.308564+0800 Strong\u0026amp;Weak[3551:201548] print strongStr is ( a, b ) __weak修饰情况下strArr引用testArr打印输出\nNSArray *testArr = @[@\u0026#34;a\u0026#34;, @\u0026#34;b\u0026#34;]; __weak NSArray * weakStrArr = testArr; testArr = nil; NSLog(@\u0026#34;print weakStr is %@\u0026#34;, weakStrArr); // 打印结果 2021-05-30 15:39:38.772768+0800 Strong\u0026amp;Weak[3579:203646] print weakStr is (null) 小结\u003e 小结 # 对比以上结果，可以看出不使用__strong修饰和使用__strong结果一样，说明oc默认情况下声明变量都是__strong，因为weak修饰引用计数器不会+1，所修饰的对象可能随时被释放。\nweak是弱引用，不会持有对象，引用计数器不会+1\u003e weak是弱引用，不会持有对象，引用计数器不会+1 # 常用于修饰UI控件、delegate\n声明为weak的指针，weak指针指向的对象一旦被释放，weak的指针都将被赋值为nil，防止野指针。\ncopy分为浅拷贝、深拷贝\u003e copy分为浅拷贝、深拷贝 # 修饰NSString、block\nstackblock如果不copy的话，stackblock是存放在栈里面的，他的生命周期会随着函数的结束而出栈的，copy之后会转变为mallocblock放在堆里面。\nassign简单赋值，不改变引用计数。\u003e assign简单赋值，不改变引用计数。 # 基础数据类型（NSInteger、CGFloat） C数据类型（int、float、double、char等） 枚举、结构体等非OC对象 ","date":"2022-11-14","permalink":"/oc/keywords/","section":"Objective-C","summary":"Automatic Reference Counting(ARC)技术是用于OC对象的内存管理。即在适当的时候对OC对象retain和release操作。","title":"Keywords"},{"content":"","date":"2022-11-14","permalink":"/tags/strong/","section":"Tags","summary":"","title":"STRONG"},{"content":"","date":"2022-11-14","permalink":"/tags/weak/","section":"Tags","summary":"","title":"WEAK"},{"content":"","date":"2022-11-14","permalink":"/tags/runtime/","section":"Tags","summary":"","title":"Runtime"},{"content":"知识关联\nBit Operation 2022-11-24\u0026middot;2 分钟 Symbiont 2022-11-24\u0026middot;1 分钟 isa指针\u003e isa指针 # 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。\nunion isa_t { Class cls; uintptr_t bits; struct { uintptr_t nonpointer :1; uintptr_t has_assoc :1; uintptr_t has_cxx_dtor :1; uintptr_t shiftcls :1; uintptr_t magic :1; uintptr_t weakly_referenced :1; uintptr_t deallocating :1; uintptr_t extra_rc :1; uintptr_t has_sidetable_rc :1; } } nonpointer\u003e nonpointer # 0，代表普通的指针，存储着Class、Meta-Class对象的内存地址 1，代表优化过，使用位域存储更多的信息 has_assoc\u003e has_assoc # 是否有设置过关联对象，如果没有，释放时会更快 has_cxx_dtor\u003e has_cxx_dtor # 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快 shiftcls\u003e shiftcls # 存储着Class、Meta-Class对象的内存地址信息 magic\u003e magic # 用于在调试时分辨对象是否未完成初始化 weakly_referenced\u003e weakly_referenced # 是否有被弱引用指向过，如果没有，释放时会更快 deallocating\u003e deallocating # 对象是否正在释放 extra_rc\u003e extra_rc # 里面存储的值是引用计数器减1 has_sidetable_rc\u003e has_sidetable_rc # 引用计数器是否过大无法存储在isa中 如果为1，那么引用计数会存储在一个叫SideTable的类的属性中 Class的结构\u003e Class的结构 # class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 method_t是对方法\\函数的封装 **IMP**代表函数的具体实现 **SEL**代表方法\\函数名，一般叫做选择器，底层结构跟**char ***类似 可以通过@selector()和sel_registerName()获得 可以通过sel_getName()和NSStringFromSelector()转成字符串 不同类中相同名字的方法，所对应的方法选择器是相同的 types包含了函数返回值、参数编码的字符串 iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码\nObjC中的TypeEncodings\n方法缓存\u003e 方法缓存 # Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。\n缓存查找\nobjc-cache.mm bucket_t * cache_t::find(cache_key_t k, id receiver) 散列表（哈希表）\u003e 散列表（哈希表） # 数组提前申请固定空间，通过某个key运算得到index，然后然后将值存储到对应index，如果该index有值，index-1操作，直到有空间，满了之后清空扩容。【牺牲内存（空间）换取时间】\nOC中调用方法其实都是执行objc_msgSend\u003e OC中调用方法其实都是执行objc_msgSend # 💡 objc_msgSend**执行流程** 消息发送\u003e 消息发送 # receiver通过isa指针找到receiverClass receiverClass通过superclass指针找到superClass 如果是从class_rw_t中查找方法 已经排序的，二分查找 没有排序的，遍历查找 动态方法解析\u003e 动态方法解析 # 开发者可以实现以下方法，来动态添加方法实现 +resolveInstanceMethod: +resolveClassMethod: 💡 这两个方法可以去动态的添加方法的实现。 添加实现\n+ (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == sel_registerName(\u0026#34;test\u0026#34;)) { class_addMethod([MainViewController class], @selector(test), IMP(test2), \u0026#34;v@:\u0026#34;); return YES; } return [super resolveInstanceMethod: sel]; } 动态解析过后，会重新走“消息发送”的流程 “从receiverClass的cache中查找方法”这一步开始执行 消息转发\u003e 消息转发 # 当对象（receiver）通过isa在类对象中没有找到要调用的方法，并且在父类也没有找到，而且在动态解析方法中也没有实现，或者没有返回nil，则会进入消息转发。\n消息转发首先会调用\n// (id) forwardingTargetForSelector:(SEL)aSelector -(id) forwardingTargetForSelector:(SEL)aSelector { if (aSelector == sel_registerName(\u0026#34;tryAtRuntimeImplementationThisFunc:\u0026#34;)) { // 转发给谁？ return [[Person alloc] init]; //return nil; } return [super forwardingTargetForSelector:aSelector]; } 如果此时返回转发对象，则在该对象的类对象内存中找到同名的方法进行调用。\n如果返回nil，则继续后面的流程；\n💡 1. 设定需要转发的方法类型 **// Person中的方法** //[NSMethodSignature signatureWithObjCTypes:\u0026#34;i17@0:8c16\u0026#34;] - (int)tryAtRuntimeImplementationThisFunc:(char)c; // i 代表返回类型； // 17代表所占内存总数； // @ 代表对象参数：self // 0 代表从0位开始 // self 站8个字节 // ：代表方法名参数：SEL // 8 从第8未开始 // SEL 占8个字节 // c 代表char类型 // 16 从16位开始 // char字节 // 实现 - (int)tryAtRuntimeImplementationThisFunc:(char)c { NSLog(@\u0026#34;消息转发成功，原值为：A，修改后：%c\u0026#34;, c); return 10; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == @selector(tryAtRuntimeImplementationThisFunc:)) { // 设定需要转发的方法类型 //[NSMethodSignature signatureWithObjCTypes:\u0026#34;i17@0:8c16\u0026#34;]; return [NSMethodSignature signatureWithObjCTypes:\u0026#34;i@:c\u0026#34;]; } return [super methodSignatureForSelector:aSelector]; } 💡 2. **修改**参数、**获取**参数、**确定转发对象** - (void)forwardInvocation:(NSInvocation *)anInvocation { if (anInvocation.selector == @selector(tryAtRuntimeImplementationThisFunc:)) { // 修改参数，方法参数有前两个默认参数self，_cmd,第2位才是我们自己定义的参数 char ar = \u0026#39;B\u0026#39;; // [anInvocation getArgument:\u0026amp;ar atIndex:2]; // ar = ; // 修改参数的值 [anInvocation setArgument:\u0026amp;ar atIndex:2]; // 将消息转发给谁，并调用。确定target，就会去该instance对象的class类对象内存中找到同名的方法 // 只需确保该对象的方法名是相通的，参数类型、返回值均可修改。 [anInvocation invokeWithTarget:[[Person alloc] init]]; int i; // 确定好哪个target，就可以找对对应的方法的返回值。 [anInvocation getReturnValue:\u0026amp;i]; NSLog(@\u0026#34;打印转发后的方法的返回值：%d\u0026#34;, i); } } // 打印输出 2021-06-01 12:21:25.686874+0800 Unit[3278:175185] 消息转发成功，原值为：A，修改后：B 2021-06-01 12:21:25.686976+0800 Unit[3278:175185] 打印转发后的方法的返回值：10 super关键字\u003e super关键字 # { [super class]; // 翻译为源码 ((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\u0026#34;Student\u0026#34;))}, sel_registerName(\u0026#34;class\u0026#34;)); } 可知: super的本质是struct objc_super\nstruct objc_super { id receiver; Class cls; // the class to search } // {(id)self, (id)class_getSuperclass(objc_getClass(\u0026#34;Student\u0026#34;))} 所以发送消息的**receiver**本质还是**self** 结论：super本质还是当前类一个包含了父类对象信息的特殊实例对象，只是当super调用方法时，直接是从父类开始查找。\n// 所以： [super class]; // 打印结果：仍未当前类，同 **[self class];** 奇怪的面试题\u003e 奇怪的面试题 # 以下代码能不能执行成功？如果能执行结果是什么？\n@interface Person : NSObject - (void)print; @property (copy, nonatomic) NSString* name; @end @implementation Person - (void)print { NSLog(@\u0026#34;name is %@\u0026#34;, self.name); } @end - (void)viewDidLoad { [super viewDidLoad]; id cls = [Person class]; void *obj = \u0026amp;cls; [(__bridge id)obj print]; } // 打印结果 2021-06-01 17:22:43.388674+0800 Unit[4571:357882] name is \u0026lt;ViewController: 0x7f8923407af0\u0026gt; 理解：是否能运行成功？能。\n- (void)viewDidLoad { [super viewDidLoad]; // cls 是Person类对象，obj则是Person类对象的地址 // 也就是Person实例对象isa \u0026amp; ISA_MASK的结果 // 即：[[Person alloc] init]-\u0026gt;isa \u0026amp; ISA_MASK id cls = [Person class]; void *obj = \u0026amp;cls; // 如同Perosn实例对象通过isa调用print，所以可以运行成功 [(__bridge id)obj print]; } 理解：打印的结果是什么？\n首先一个Person实例对象的存储结构。\nstruct Person_0 { Class isa; NSString * _name; } **self.name的本质是什么？**\n本质是isa高位地址后8个字节。所以有了isa的地址，在找到它前面的8个字节，系统就认为它是name。\n此时内存中的结构\ncls前面是\n[super viewDidLoad]; // super 的本质结构 struct objc_super { id receiver; Class cls; // the class to search } // 所以取得前8个字节, 是 receiver , 而 receiver 本质就是 self // 打印结果 2021-06-01 17:22:43.388674+0800 Unit[4571:357882] name is \u0026lt;ViewController: 0x7f8923407af0\u0026gt; 此时如果cls前面数据不是正好8个字节，就会访问错误，报错EXC_BAD_ACCESS。\nLlvm 2022-11-24\u0026middot;1 分钟 Runtime API\u003e Runtime API # 通过类名获取类对象\u003e 通过类名获取类对象 # /** * 通过类名获取类对象 */ - (void)objc_getClassMethods_API_0 { /** Class objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES); } */ Class cls1 = objc_getClass(\u0026#34;ViewController\u0026#34;); /** Class objc_lookUpClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, NO class handler return look_up_class(aClassName, NO, NO); } */ Class cls2 = objc_lookUpClass(\u0026#34;ViewController\u0026#34;); Class cls3 = objc_getRequiredClass(\u0026#34;ViewController\u0026#34;); Class cls4 = objc_getClass(\u0026#34;ViewController1\u0026#34;); Class cls5 = objc_lookUpClass(\u0026#34;ViewController1\u0026#34;); /** 使用 objc_getRequiredClass(const char * _Nonnull name) 必须传入有效的类名，否则会崩溃 底层实现也是objc_getClass(),如果找不到类，就报错。 Class objc_getRequiredClass(const char *aClassName) { Class cls = objc_getClass(aClassName); if (!cls) _objc_fatal(\u0026#34;link error: class \u0026#39;%s\u0026#39; not found.\u0026#34;, aClassName); return cls; } */ // Class cls6 = objc_getRequiredClass(\u0026#34;ViewController1\u0026#34;); NSLog(@\u0026#34;cls1 is %@\u0026#34;, cls1); NSLog(@\u0026#34;cls2 is %@\u0026#34;, cls2); NSLog(@\u0026#34;cls3 is %@\u0026#34;, cls3); NSLog(@\u0026#34;cls4 is %@\u0026#34;, cls4); NSLog(@\u0026#34;cls5 is %@\u0026#34;, cls5); // NSLog(@\u0026#34;cls6 is %@\u0026#34;, cls6); } // 打印输出 2021-06-02 13:21:48.507819+0800 RuntimeAPI[1839:100002] cls1 is ViewController 2021-06-02 13:21:48.507909+0800 RuntimeAPI[1839:100002] cls2 is ViewController 2021-06-02 13:21:48.507994+0800 RuntimeAPI[1839:100002] cls3 is ViewController 2021-06-02 13:21:48.508072+0800 RuntimeAPI[1839:100002] cls4 is (null) 2021-06-02 13:21:48.508148+0800 RuntimeAPI[1839:100002] cls5 is (null) objc_getClass()、objc_lookUpClass()，找不类会返回nil，objc_getRequiredClass()找不到类则会直接报错。\n通过实例对象获取类对象，通过类对象获取元类对象\u003e 通过实例对象获取类对象，通过类对象获取元类对象 # { /// 通过实例对象获取类对象 ViewController *obj = [[ViewController alloc] init]; // 获取类对象 Class cls7 = object_getClass(obj); NSLog(@\u0026#34;cls7 is obj`s class %@, %p, is metaclass %d\u0026#34;, cls7, cls7, class_isMetaClass(cls7)); /// 通过类名获取元类对象 Class cls8 = objc_getMetaClass(\u0026#34;ViewController\u0026#34;); NSLog(@\u0026#34;cls8 is ViewController`s metaclass %@, %p, is metaclass %d\u0026#34;, cls8, cls8, class_isMetaClass(cls8)); /// 通过类对象获取元类对象 Class cls9 = object_getClass(cls7); NSLog(@\u0026#34;cls9 is obj`s metaclass %@, %p, is metaclass %d\u0026#34;, cls9, cls9, class_isMetaClass(cls9)); } // 打印结果 cls7 is obj`s class ViewController, 0x10519c560, is metaclass 0 cls8 is ViewController`s metaclass ViewController, 0x10519c588, is metaclass 1 cls9 is obj`s metaclass ViewController, 0x10519c588, is metaclass 1 通过类对象获取父类类对象\u003e 通过类对象获取父类类对象 # /** * Runtime api: 获取类对象的父类对象; */ - (void)get_superclass_runtime_api { Class cls = class_getSuperclass([ViewController class]); NSLog(@\u0026#34;ViewController`s superclass is %@\u0026#34;, cls); } 改变实例对象的类型\u003e 改变实例对象的类型 # /** * runtime时改变实例对象的类型； */ - (void)changeInstance_obj_classType { ViewController *obj = [[ViewController alloc] init]; Class oldClass = object_setClass(obj, [UIViewController class]); NSLog(@\u0026#34;oldClass is %@, obj is %@\u0026#34;, oldClass, obj); } // 打印结果 oldClass is ViewController, obj is \u0026lt;UIViewController: 0x7fc201005ce0\u0026gt; 动态创建一个类\u003e 动态创建一个类 # void forNewClass(id self, SEL _cmd) { NSLog(@\u0026#34;this is a runtime added method\u0026#34;); } /** * runtime时创建一个类； */ - (void) createClassWithRuntime { // 创建继承UIViewController的子类YZ_ViewController Class NewClass = objc_allocateClassPair([UIViewController class], \u0026#34;YZ_ViewController\u0026#34;, 0); // 给YZ_ViewController类添加成员变量：someName class_addIvar(NewClass, \u0026#34;someName\u0026#34;, 8, 1, @encode(NSString *)); // 给YZ_ViewController类添加成员变量：age class_addIvar(NewClass, \u0026#34;age\u0026#34;, 4, 1, @encode(int)); // 注册该类，否则无法使用 objc_registerClassPair(NewClass); // 给该类添加方法 class_addMethod(NewClass, @selector(runtimeLog), (IMP)forNewClass, \u0026#34;v@:\u0026#34;); id newObj = [NewClass new]; [newObj setValue:@\u0026#34;newObj`s someName\u0026#34; forKey:@\u0026#34;someName\u0026#34;]; [newObj setValue:@20 forKey:@\u0026#34;age\u0026#34;]; [newObj runtimeLog]; NSLog(@\u0026#34;newClass is %@, and newObj someName is %@\u0026#34;, NewClass, [newObj valueForKey:@\u0026#34;someName\u0026#34;]); NSLog(@\u0026#34;newObj age is %d\u0026#34;, [[newObj valueForKey:@\u0026#34;age\u0026#34;] intValue]); //objc_disposeClassPair(NewClass); } 获取一个实例变量信息\u003e 获取一个实例变量信息 # - (void)getInstanceVarsInfos { Ivar varInfo = class_getInstanceVariable([ViewController class], \u0026#34;_title\u0026#34;); NSLog(@\u0026#34;name is %s, type of encoding is %s\u0026#34;, ivar_getName(varInfo), ivar_getTypeEncoding(varInfo)); } // 打印结果 name is _title, type of encoding is @\u0026#34;NSString\u0026#34; 拷贝实例变量列表（最后需要调用free释放）\u003e 拷贝实例变量列表（最后需要调用free释放） # - (void)copyVarsList { // 拷贝实例变量列表（最后需要调用free释放） unsigned int counts; Ivar *vars = class_copyIvarList([UILabel class], \u0026amp;counts); for (int i = 0; i \u0026lt; counts; i++) { Ivar var = vars[i]; NSLog(@\u0026#34;%s ---- %s\u0026#34;, ivar_getName(var), ivar_getTypeEncoding(var)); } free(vars); } ... 2021-06-05 10:04:05.380205+0800 RuntimeAPI[1397:35429] _adjustsFontForContentSizeCategory ---- B 2021-06-05 10:04:05.380399+0800 RuntimeAPI[1397:35429] _preferredMaxLayoutWidth ---- d 2021-06-05 10:04:05.380523+0800 RuntimeAPI[1397:35429] _multilineContextWidth ---- d 2021-06-05 10:04:05.380701+0800 RuntimeAPI[1397:35429] _fontForShortcutBaselineCalculation ---- @\u0026#34;UIFont\u0026#34; 2021-06-05 10:04:05.380841+0800 RuntimeAPI[1397:35429] __visualStyle ---- @\u0026#34;_UILabelVisualStyle\u0026#34; ... 将方法实现进行交换\u003e 将方法实现进行交换 # - (void)runtimeExchangeMethods { Method mExchange01 = class_getInstanceMethod([ViewController class], @selector(methodForExchange01)); Method mExchange02 = class_getInstanceMethod([ViewController class], @selector(methodForExchange02)); method_exchangeImplementations(mExchange01 , mExchange02); [self methodForExchange01]; [self methodForExchange02]; } // 打印结果 2021-06-05 10:14:56.327340+0800 RuntimeAPI[1508:44243] -[ViewController methodForExchange02] 2021-06-05 10:14:56.327434+0800 RuntimeAPI[1508:44243] -[ViewController methodForExchange01] ","date":"2022-11-14","permalink":"/oc/runtime/","section":"Objective-C","summary":"Runtime","title":"Runtime"},{"content":"","date":"2022-11-14","permalink":"/tags/runloop/","section":"Tags","summary":"","title":"Runloop"},{"content":"RunLoop的简介、作用\u003e RunLoop的简介、作用 # 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 RunLoop可以简单理解为，让程序保持运行的一个while循环，这个循环内监听各种事件（如触摸事件、performSelector、定时器NSTimer等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）\n不管RunLoop有多复杂，其本质就是：一个循环，有事件的时候处理事件，无事件的时候休眠（这里的睡眠是指用户态切换到内核态，这样的休眠线程是被挂起的，不会再占用cpu资源）。 RunLoop与线程\u003e RunLoop与线程 # 一个线程只有一个RunLoop对象（一一对应关系） 主线程的RunLoop默认已经创建好了，而子线程的需要手动创建。 RunLoop在第一次获取时创建，在线程结束时销毁。 RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。\nvoid const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) { if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); } __CFLock(\u0026amp;loopsLock); if (!__CFRunLoops) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, \u0026amp;kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); #pragma GCC diagnostic push #pragma GCC diagnostic ignored \u0026#34;-Wdeprecated\u0026#34; if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)\u0026amp;__CFRunLoops)) { #pragma GCC diagnostic pop CFRelease(dict); } CFRelease(mainLoop); } CFRunLoopRef newLoop = NULL; CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { newLoop = __CFRunLoopCreate(t); cf_trace(KDEBUG_EVENT_CFRL_LIFETIME|DBG_FUNC_START, newLoop, NULL, NULL, NULL); CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } __CFUnlock(\u0026amp;loopsLock); // don\u0026#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it if (newLoop) { CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) { #if _POSIX_THREADS _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); #else _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, \u0026amp;__CFFinalizeRunLoop); #endif } } return loop; } RunLoop的组成\u003e RunLoop的组成 # 一个 RunLoop 主要由：CFRunLoopMode / CFRunLoopSourceRef / CFRunLoopObserverRef / CFRunLoopTimerRef 组成。 RunLoop 可以拥有多种Mode，Mode中包含 Source / Observer / Timer。\nCFRunLoopMode（RunLoop的运行模式）共五类\u003e CFRunLoopMode（RunLoop的运行模式）共五类 # kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode 界面跟踪Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响 UIInitializationRunLoopMode 在刚启动App时第进入的第一个Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode 接受系统事件的内部Mode，通常用不到 kCFRunLoopCommonModes 这是一个占位用的Mode，不是一种真正的Mode，可以简单理解为 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode 的结合 CFRunLoopSource（输入源/事件源）\u003e CFRunLoopSource（输入源/事件源） # 这里有两个源：_sources0 / _sources1\n_sources0 即非基于 port 的，也就是用户触发事件，需要手动唤醒线程。将当前线程从 \u0026lsquo;内核态切换到用户态\u0026rsquo; \u0026lsquo;CPU的两种工作状态，内核态可以调度所有的资源，用户态则只可以调度用户工作界面\u0026rsquo; _sources1 基于 port 的，包含一个 mach_port 和一个回调，可以监听系统端口和通过内核态和其他线程发送消息，能主动唤醒 RunLoop，接收分发系统事件，具备唤醒线程能力。\nCFRunLoopTimer（定时源）\u003e CFRunLoopTimer（定时源） # 基于时间的触发器，基本上说的就是 NSTimer。在预设的时间点唤醒 RunLoop 执行回调。因为它是基于 RunLoop 的，因此它不是实时的（就是 NSTimer 是不准确的。 因为 RunLoop 只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致 Timer 本次延时，或者少执行一次）\nCFRunLoopObserver（观察者）\u003e CFRunLoopObserver（观察者） # 可以对 RunLoop 不同状态下进行监听，从而对当前 RunLoop 工作状态进行优化。\nkCFRunLoopEntry RunLoop准备启动 kCFRunLoopBeforeTimers RunLoop将要处理一些Timer相关事件 kCFRunLoopBeforeSources RunLoop将要处理一些Source事件 kCFRunLoopBeforeWaiting RunLoop将要进行休眠状态，即将由用户态切换到内核态 kCFRunLoopAfterWaiting RunLoop被唤醒，即从内核态切换到用户态后 kCFRunLoopExit RunLoop退出 kCFRunLoopAllActivities 监听所有状态活动 如何设置监听?\nRunLoop运行机制\u003e RunLoop运行机制 # 1️⃣ 调用 Observer 监听方法状态为 kCFRunLoopEntry 2️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeTimers 3️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeSources 4️⃣ 处理 Blocks：__CFRunLoopDoBlocks 5️⃣ 处理 sources0，如果被处理过则再次处理 Blocks ⁉️ 判断是否存在 sources1，如果存在 7️⃣，如果不存在 6️⃣ 6️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeWaiting，并随时等待被 sources1 / dipatch / timer / source0 / 手动唤醒 唤醒，如有，则会：调用 Observer 监听方法状态为 kCFRunLoopAfterWaiting 继续 7️⃣ 7️⃣ 处理 timers 8️⃣ 处理 GCD Main 9️⃣ 处理 sources1 🔟 处理 Blocks ⁉️ 是否还有需要处理的任务？是跳转到 2️⃣ 重新开始， 否则：调用 Observer 监听方法状态为 kCFRunLoopExit 主线程\u003e 主线程 # 自己能够保活，因为底层判断是根据 modes 是否为空来决定线程是否休眠（销毁），如果是主线程则是个例外，直接返回不为空。非主线程则是根据 _sources0 _sources1 _timers 中是否有数据来判断。 源码如是\n// expects rl and rlm locked static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) { CHECK_FOR_FORK(); if (NULL == rlm) return true; #if TARGET_OS_WIN32 if (0 != rlm-\u0026gt;_msgQMask) return false; #endif #if __HAS_DISPATCH__ Boolean libdispatchQSafe = pthread_main_np() == 1 \u0026amp;\u0026amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe \u0026amp;\u0026amp; (CFRunLoopGetMain() == rl) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)) return false; // represents the libdispatch main queue #endif if (NULL != rlm-\u0026gt;_sources0 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources0)) return false; if (NULL != rlm-\u0026gt;_sources1 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources1)) return false; if (NULL != rlm-\u0026gt;_timers \u0026amp;\u0026amp; 0 \u0026lt; CFArrayGetCount(rlm-\u0026gt;_timers)) return false; struct _block_item *item = rl-\u0026gt;_blocks_head; while (item) { struct _block_item *curr = item; item = item-\u0026gt;_next; Boolean doit = false; if (_kCFRuntimeIDCFString == CFGetTypeID(curr-\u0026gt;_mode)) { doit = CFEqual(curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFEqual(curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } else { doit = CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } if (doit) return false; } return true; } 所以如何进行线程保活?\n只需要在 _sources0 _sources1 _timers 中添加事件，线程就能处于活跃状态。\nRunLoop线程保活\u003e RunLoop线程保活 # 某个操作如果需要频繁在子线程中进行操作，可以延长该线程的生命周期，而不需要频繁创建新的线程来工作。\n创建一个线程，并在该线程的runloop中添加source使得线程停留。\n_thread = [[YZThread alloc] initWithBlock:^{ NSLog(@\u0026#34;thread is begin\u0026#34;); CFRunLoopSourceContext context = {0}; CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, \u0026amp;context); CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode); CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false); NSLog(@\u0026#34; -------- thread is end -------- \u0026#34;); }]; [_thread start]; 在子线程中做相应操作\n- (void)excutedInBlock:(LongtimeThreadBlock)block { if (!block || !_thread) return; [self performSelector:@selector(__excutedDosome:) onThread:_thread withObject:block waitUntilDone:NO]; } - (void)__excutedDosome:(LongtimeThreadBlock)block { block(); } 结束线程\n- (void)stop { if (!_thread) return; // waitUnitDone, 这里要设置YES，防止self被提前释放。 [self performSelector:@selector(__stop) onThread:_thread withObject:nil waitUntilDone:YES]; } - (void)__stop { CFRunLoopStop(CFRunLoopGetCurrent()); self.thread = nil; } 运用\n@implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; _thread = [[LongtimeThread alloc] init]; } - (void)touchesBegan:(NSSet\u0026lt;UITouch *\u0026gt; *)touches withEvent:(UIEvent *)event { [_thread excutedInBlock:^{ NSLog(@\u0026#34;do something in thread.\u0026#34;); }]; } @end CFRunLoop存在于Foundation框架中，使用的是纯C函数实现，相对于NSRunloop，这些C函数API都是线程安全🔐的。 RunLoop的应用\u003e RunLoop的应用 # 定时器（Timer）、PerformSelector GCD Async Main Queue 事件响应、手势识别、界面刷新 网络请求 AutoreleasePool 卡顿监听 NSTimer的失效\u003e NSTimer的失效 # NSTimer默认创建事件表，对应的RunLoop，默认是NSDefaultRunLoopMode，所以在滑动事件上该模式会被暂停。计时器就不会工作。\n__block int count = 0; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer *timer) { NSLog(@\u0026#34;counting is %d\u0026#34;, ++count); }]; 只需把NSTimer放在RunLoop的NSRunLoopCommonModes模式下，滑动事件就不会影响该NSTimer的工作。\n__block int count = 0; NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@\u0026#34;counting is %d\u0026#34;, ++count); }]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 参考\u003e 参考 # 1 2 3 理解 OC 中 RunLoop ","date":"2022-11-14","permalink":"/oc/runloop/","section":"Objective-C","summary":"\u003ccode\u003eRunLoop\u003c/code\u003e可以简单理解为，让程序保持运行的一个\u003ccode\u003ewhile\u003c/code\u003e循环，这个循环内监听各种事件（如触摸事件、\u003ccode\u003eperformSelector\u003c/code\u003e、定时器\u003ccode\u003eNSTimer\u003c/code\u003e等），没有事件的时候睡眠，从而有效的利用CPU（只有在有事件的时候才用CPU，没事件的时候睡眠）","title":"Runloop"},{"content":"","date":"2022-11-14","permalink":"/tags/objc-instance/","section":"Tags","summary":"","title":"Objc Instance"},{"content":" oc对象 在内存中存储的东西 instance isa, _property(value) class isa, property, function, protocol, _property, superclass meta-class isa, superclass, class function instance对象（实例对象）\u003e instance对象（实例对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; instance对象在内存中存储的信息包括\u003e instance对象在内存中存储的信息包括 # instance \u0026mdash; isa指针 \u0026mdash; 其他成员变量（这里指的是变量的值，比如变量age = 4，存储这个4） class对象（类对象）\u003e class对象（类对象） # // obj1，obj2 是NSObject的instance对象（实例对象） // 他们不同的两个对象，分别占据着两个不同的内存。 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; // objClass1 ~ objClass5 都是NSObject的class对象（类对象） // 他们是同一个对象，每个类在内存中有且只有一个class对象 Class objClass1 = [obj1 class]; Class objClass2 = [obj2 class]; Class objClass3 = [NSObject class]; Class objClass4 = object_getClass(obj1); Class objClass5 = object_getClass(obj2); class对象在内存中存储的信息包括\u003e class对象在内存中存储的信息包括 # class \u0026mdash; isa指针 \u0026mdash; superclass指针 \u0026mdash; 类的属性信息（@property）、类的对象方法信息（instance method） \u0026mdash; 类的协议信息（protocol）、类的成员变量信息（ivar，这里主要是变量名不会发生改变的信息，变量类型） meta-class对象（元类对象）\u003e meta-class对象（元类对象） # // objMetaClass 是NSObject的meta-class对象（元类对象） // 每个类在内存中有且只有一个meta-class对象 Class objMetaClass = object_getClass([NSObject class]); // runtime api meta-class对象和class对象的内存结构是一样的，只是用途不一样\u003e meta-class对象和class对象的内存结构是一样的，只是用途不一样 # meta-class \u0026mdash; isa指针 \u0026mdash; superclass指针 \u0026mdash; 类的类方法信息（class method） \u0026mdash; \u0026hellip; 注意\u003e 注意 # //objectClass是class对象，并不是meta-class对象 Class objClass = [[NSObject class] class]; // 查看Class是否是meta-class #import \u0026lt;objc/runtime.h\u0026gt; BOOL result = class_isMetaClass([NSObject class]); isa指针\n","date":"2022-11-14","permalink":"/oc/objc-instance/","section":"Objective-C","summary":"实例对象、类对象、元类对象（Instance  Class  Meta-Class）","title":"Objc Instance"},{"content":"","date":"2022-11-14","permalink":"/tags/objc/","section":"Tags","summary":"","title":"Objc"},{"content":" Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。 Objective-C被翻译的过程 graph LR; A[OC]--\u003eB[C\\C++]; B--\u003eC[汇编语言]; C--\u003eD[机器语言] Objective-C代码转换为C、C++代码\n// 终端命令 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.c -o main.cpp xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc “oc源文件” -o “输出cpp文件” 一个OC对象在内存中是如何布局的？\u003e 一个OC对象在内存中是如何布局的？ # // alloc 申请一块内存空间，init 初始化一个类的实例对象 NSObject *obj = [[NSObject alloc] init]; OC中对象至少会被分配16个字节的空间（64位）；32位则是8个字节\nC OC 32Bit 64Bit bool BOOL(64) 1 1 char int8_t, BOOL(32) 1 1 unsigned char boolean 1 1 short int16_t 2 2 unsigned short unichar 2 2 int int32_t,NSInteger,boolean 4 4 unsigned int boolean_t,NSUInteger 4 4 long NSInteger 4 8 unsigned long NSUInteger 4 8 long long int64_t 8 8 float CGFloat(32) 4 4 double CGFloat(64) 8 8 参考\u003e 参考 # 1、OC基本数据类型\n关于NSObject对象的内存布局，看我就够了！\n实时查看内存数据\u003e 实时查看内存数据 # DeBug \u0026gt; DeBug Workflow \u0026gt; View Memory，Shift + Command + M\n创建一个实例对象，至少需要多少内存？\u003e 创建一个实例对象，至少需要多少内存？ # 一个对象至少需要8个字节\n#import \u0026lt;objc/runtime.h\u0026gt; class_getInstanceSize([NSObject class]); 创建一个实例对象，实际分配了多少内存？\u003e 创建一个实例对象，实际分配了多少内存？ # 64位系统至少会分配16个字节，32位则是8个字节。\n#import \u0026lt;malloc/malloc.h\u0026gt; NSObject *obj = [[NSObject alloc] init]; malloc_size((__bridge const void *)obj); 常用LLDB指令\u003e 常用LLDB指令 # print、p： 打印 po：打印对象\n读取内存 Memory read/数量格式字节数 内存地址 x/数量格式字节数 内存地址 💡 例如：x/3xw 0x10010\n格式 x是16进制，f是浮点数，d是10进制 字节大小 b：byte 1字节 h：half wrod 2字节 w： word 4字节 g：giant word 8字节 修改内存中的值 memory write 内存地址 数值：memory write 0x0000010 10 ","date":"2022-11-14","permalink":"/oc/objc/","section":"Objective-C","summary":"Objective-C底层实现其实都是C、C++代码，Objective-C的面向对象都是基于C、C++的数据结构实现的，Objective-C的对象、类主要是基于C、C++的结构体实现的。","title":"Objective-C的本质"},{"content":"","date":"2022-11-14","permalink":"/tags/kvo/","section":"Tags","summary":"","title":"KVO"},{"content":" KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 可以用于监听某个对象属性值的改\n// 如何设置属性的KVO @property (nonatomic, strong) Person *person1; - (void)viewDidLoad { [super viewDidLoad]; _person1 = [[Person alloc] init]; _person1.age = 32; // 需要返回的数据，新的值 ｜ 旧的值 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; // 对person1属性age设置监听，附带信息：@\u0026#34;附加信息\u0026#34; [self.person1 addObserver:self forKeyPath:@\u0026#34;age\u0026#34; options:options context:@\u0026#34;附加信息\u0026#34;]; } // person1.ag改变时进行调用这里 -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change context:(void *)context { NSLog(@\u0026#34;keyPath: %@, object: %@;\\nchange: %@, context: %@\u0026#34;, keyPath, object, change, context); } // 监听者销毁时移除相应的监听 -(void)dealloc { [_person1 removeObserver:self forKeyPath:@\u0026#34;age\u0026#34;]; } KVO的本质（内部实现）\u003e KVO的本质（内部实现） # 打印对象isa地址、name类名\u003e 打印对象isa地址、name类名 # 在设置监听前后打印person1，2的isa地址。发现person1在设置完监听后地址发生了改变；在设置监听前后打印person1，2的类名。发现person1在设置完监听后改变为：NSKVONotifying_Person；\n// person1-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person1-\u0026gt;isa: %p\u0026#34;, object_getClass(_person1)); // person2-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person2-\u0026gt;isa: %p\u0026#34;, object_getClass(_person2)); // person1 class name: Person NSLog(@\u0026#34;person1 class name: %p\u0026#34;, object_getClass(object_getClass(_person1))); // person2 class name: Person NSLog(@\u0026#34;person2 class name: %p\u0026#34;, object_getClass(object_getClass(_person2))); NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [self.person1 addObserver:self forKeyPath:@\u0026#34;age\u0026#34; options:options context:@\u0026#34;附加信息\u0026#34;]; // person1-\u0026gt;isa: 0x6000022a03f0 NSLog(@\u0026#34;person1-\u0026gt;isa: %p\u0026#34;, object_getClass(_person1)); // person2-\u0026gt;isa: 0x10bcb0710 NSLog(@\u0026#34;person2-\u0026gt;isa: %p\u0026#34;, object_getClass(_person2)); // person1 class name: NSKVONotifying_Person NSLog(@\u0026#34;person1 class name: %p\u0026#34;, object_getClass(object_getClass(_person1))); // person2 class name: Person NSLog(@\u0026#34;person2 class name: %p\u0026#34;, object_getClass(object_getClass(_person2))); // person1 class`s class name: Person NSLog(@\u0026#34;person1 class`s class name: %@\u0026#34;, object_getClass(object_getClass(person1)).superclass); 小结\u003e 小结 # 可以看出，程序在runtime的时候动态生成了 NSKVONotifying_Person ，NSKVONotifying_Person 继承于 Person，当改变 age 的值时，即调用 setAge: 方法。NSKVONotifying_Person 重写了 setAge：并做了其他事情。具体做了那些事可以猜测：\n- (void)setAge:(int)age { [_person1 willChangeValueForKey:@\u0026#34;age\u0026#34;]; [super setAge:age]; [_person1 didChangeValueForKey:@\u0026#34;age\u0026#34;]; } didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法\n即：KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。 如何手动触发KVO？\u003e 如何手动触发KVO？ # 手动调用willChangeValueForKey: 和didChangeValueForKey: 。只调用didChangeValueForKey: 是无法触发的。\n使用场景\u003e 使用场景 # 实现上下拉刷新控件 content offset webview 混合排版 content size 监听模型属性实时更新UI NSOperation NSoperationQueue RAC ","date":"2022-11-14","permalink":"/oc/kvo/","section":"Objective-C","summary":"KVO是利用runtime的特性动态生成观察对象类的子类，然后重写被观察对象的属性的set方法。","title":"KVO (Key-Value Observing)"},{"content":"","date":"2022-11-14","permalink":"/tags/kvc/","section":"Tags","summary":"","title":"KVC"},{"content":"KVC主要方法\u003e KVC主要方法 # - (void)setValue:(id)value forKeyPath:(NSString *)keyPath; - (void)setValue:(id)value forKey:(NSString *)key; - (id)valueForKeyPath:(NSString *)keyPath; - (id)valueForKey:(NSString *)key; setValue: forKey: 的原理\u003e setValue: forKey: 的原理 # valueForKey: 的原理\u003e valueForKey: 的原理 # 使用KVC修改是否会触发KVO？（设置了监听）\u003e 使用KVC修改是否会触发KVO？（设置了监听） # 使用KVC，不管是修改成员变量还是属性的值都会触发KVO。\n","date":"2022-11-14","permalink":"/oc/kvc/","section":"Objective-C","summary":"使用KVC，不管是修改成员变量还是属性的值都会触发KVO。","title":"KVC (Key-Value Coding)"},{"content":" oc为什么要存在isa\u003e oc为什么要存在isa # isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。\n什么事消息机制？怎么理解消息机制？\u003e 什么事消息机制？怎么理解消息机制？ # 当对象调用方法时，[objc class] 理论上其实是调用 objc_msgSend(objc-\u0026gt;isa, @selector(class))方法通知objc去调用class方法。\nisa指针指向关系图\u003e isa指针指向关系图 # instance实例对象的isa指针指向class类对象\u003e instance实例对象的isa指针指向class类对象 # 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现并调用。\nclass类对象的isa指向meta-class元类对象\u003e class类对象的isa指向meta-class元类对象 # 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现并调用。\ninstance的isa指向class class的isa指向meta-class meta-class的isa指向基类（NSObject）的meta-class class的superclass指向父类的class，如果没有父类，superclass的指针为nil meta-class的superclas指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹： isa找到class，如果方法不存在，就通过superclass找到父类的class，直到找到为止，如果最后没有找到，就会报错：unrecognized selector class调用类方法轨迹： isa找到meta-class，方法不存在，就通过superclass找父类，如果一直到基类的mete-class都没找到，则会找到基类的class，如果有则调用对象方法，没有则：unrecognized selector 从64位开始，isa指向的地址的需要一次位运算（\u0026amp; ISA_MASK），才能计算真实地址。 #if __arm64__ #define ISA_MASK 0x0000000ffffffff8ULL #elif __x86_64__ #define ISA_MASK 0x00007fffffffffff8ULL #endif NSObject *obj = [[NSObject alloc] init]; p/x obj-\u0026gt;isa // 打印输出obj的isa地址 class类对象、meta-class元类对象的本质结构都是struct objc_class struct objc_class 结构\u003e struct objc_class 结构 # struct objc_class { Class isa; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息 }； class_rw_t *data = bits.data() // return bits \u0026amp; FAST_DATA_MASK struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间大小 #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; }; struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t *method; property_list_t *properties; const protocol_list_t *protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; }; ","date":"2022-11-14","permalink":"/oc/isa/","section":"Objective-C","summary":"isa相当于oc对象中的id，oc是调用方法是通过objc_msgSend(,)消息机制，它要通过isa找到对应的属性、方法、协议等。","title":"Isa"},{"content":"","date":"2022-11-14","permalink":"/tags/isa/","section":"Tags","summary":"","title":"ISA"},{"content":" copy 是复制出不可变对象 mutableCopy 是复制出可变对象； 复制出来的对象互不影响。 copy 复制不可变对象属于浅拷贝（浅拷贝就只是地址拷贝） copy 复制可变对象属于深拷贝（需要复制出一份不可变对象，以免之前可变对象变更影响复制出来的对象） mutableCopy 属于深拷贝（重新申请一份内存和指针） - (void)viewDidLoad { [super viewDidLoad]; NSArray * arr = @[@1, @2]; NSArray *arrCopy = [arr copy]; NSMutableArray * arrMCopy = [arr mutableCopy]; [arrMCopy addObject:@3]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, arr, arrCopy, arrMCopy); NSMutableArray * marr = [NSMutableArray arrayWithArray:arr]; NSArray *marrCopy = [marr copy]; NSMutableArray * marrMCopy = [marr mutableCopy]; NSLog(@\u0026#34;%p, %p, %p\u0026#34;, marr, marrCopy, marrMCopy); } copy mutableCopy NSString NSString NSMutableString NSMutableString NSString NSMutableString NSArray NSArray NSMutableArray NSMutableArray NSArray NSMutableArray NSDictionary NSDictionary NSMutableDictionary NSMutableDictionary NSDictionary NSMutableDictionary ","date":"2022-11-14","permalink":"/oc/copy-mutablecopy/","section":"Objective-C","summary":"Copy \u0026amp; MutableCopy / 浅拷贝和深拷贝的解释","title":"Copy \u0026 MutableCopy"},{"content":"","date":"2022-11-14","permalink":"/tags/mutablecopy/","section":"Tags","summary":"","title":"MutableCopy"},{"content":"","date":"2022-11-14","permalink":"/tags/category/","section":"Tags","summary":"","title":"Category"},{"content":"category定义在objc-runtime-new.h中，结构如下：\n所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点\u003e 知识点 # 后编译的先调用\u003e 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。\nXcode中控制编译顺序\u003e Xcode中控制编译顺序 # Category和Class Extension的区别是什么？\u003e Category和Class Extension的区别是什么？ # Class Extension在编译的时候，它的数据就已经包含在类信息中，Category是在运行时，才会将数据合并到类信息中。\n源码解读顺序\u003e 源码解读顺序 # objc-os.mm\n_objc_init map_images map_images_nolock objc-runtime-new.mm\n_read_images remethodizeClass attachCategories attachLists realloc、memmove、 memcpy 其他可阅读\u003e 其他可阅读 # OC 底层探索 - Category 和 Extension\nCategory的使用\u003e Category的使用 # 新建文件时选择Category类型\n#import \u0026#34;类名.h\u0026#34; @interface 类名 (类别名) // 在此处声明方法 @end #import \u0026#34;类名+类别名.h\u0026#34; @implementation 类名 (类别名) // 在此处实现声明的方法 @end Extension（扩展）\u003e Extension（扩展） # 一般的时候，Extension都是写在.m文件中，不单独建立一个扩展文件，且必须写在@implementation的上方，否则编译会报错。\n扩展文件为单一的.h文件 命名为\u0026quot;类名_类别名.h\u0026quot; #import \u0026#34;类名.h\u0026#34; @interface 类名 () // 在此添加私有成员变量、属性、声明方法 @end ","date":"2022-11-14","permalink":"/oc/category/","section":"Objective-C","summary":"所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 \u003ccode\u003eclass\u003c/code\u003e 对象中一样的数据类型，只使用了新的变量存储。在 \u003ccode\u003eruntime\u003c/code\u003e时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（\u003ccode\u003eisa\u003c/code\u003e）。","title":"Category"},{"content":"","date":"2022-11-13","permalink":"/tags/app/","section":"Tags","summary":"","title":"app"},{"content":"","date":"2022-11-13","permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes"},{"content":" 碎片笔记本\n使用说明\u003e 使用说明 # 您可以纯粹的记录笔记，或者是把笔记和标签关联，比如这篇笔记\n它关联了状态标签\n默认状态是：🟡待办 选中状态是：🟢已完成 现在就可以尝试一下左上角的按钮，点点看😊\n如果您有一个待办事项，使用这个标签可轻松标记状态，当然您可以自定义，新建任何事件的两面性，或者只是新建个默认标签。\n笔记\n可以置顶🔝 可以编辑✒️ 可以删除🚮 也可以分享📟 只需长按列表某个笔记即可呼出菜单!!!\nEnjoy~\n隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 碎片笔记本 （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"2022-11-13","permalink":"/apps/notes/","section":"App","summary":"碎片笔记本，简单的记个笔记～","title":"Notes: 碎片笔记本使用手册"},{"content":"","date":"2022-11-13","permalink":"/tags/upaper/","section":"Tags","summary":"","title":"Upaper"},{"content":" 隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 Upaper （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"2022-11-13","permalink":"/apps/upaper/","section":"App","summary":"方便简单的找到一张壁纸～","title":"Upaper: 高清壁纸"},{"content":"这里会展示我自己应用的相关信息\n","date":"2022-11-13","permalink":"/apps/","section":"App","summary":"这里会展示我自己应用的相关信息","title":"App"},{"content":"","date":"2022-11-13","permalink":"/tags/resume/","section":"Tags","summary":"","title":"Resume"},{"content":"","date":"2022-11-13","permalink":"/tags/worknote/","section":"Tags","summary":"","title":"WorkNote"},{"content":"","date":"2022-11-13","permalink":"/works/","section":"Works","summary":"","title":"Works"},{"content":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。\n@interface WZPageContentViewController : UIViewController @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDataSource\u0026gt; dataSource; @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDelegate\u0026gt; delegate; @property (strong, nonatomic, readonly) UIPageViewController *pageController; @property (strong, nonatomic, readonly) __kindof UIViewController *selectedController; @property (assign, nonatomic, readonly) NSInteger selectedIndex; @property(nonatomic) WZPageMenuItemStyle *selectedStyle; @property(nonatomic) WZPageMenuItemStyle *normalStyle; /// 是否展示分割线 @property(nonatomic) BOOL showDividingLine; /// 是否展示位置指示器 @property(nonatomic) BOOL showIndicator; - (void)reloadDataAt:(NSInteger)index; /// 刷新菜单栏 - (void)reloadMenus; - (void)registerClass:(Class)aClass identifier:(nonnull NSString *)identifier; - (void)registerNib:(UINib *)nib identifier:(NSString *)identifier; @end 设计结果肯定是以业务为依托，搭建基础框架，然后在条条框框里填写需求。所以先看一下代理设置了些啥，最后再拆解整个结构。\nWZPageContentViewControllerDataSource\u003e WZPageContentViewControllerDataSource # 首先他需要一个标题数据源；- (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; 然后给到对应数据源的页面；- (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; 如果你只需要这样的基础页面，那你完成设置了。因为内部已经实现了基础样式，选中的标题高亮，粗体。帮你缓存已经加载过的页面，同时给到对应appear disappear 正常 UIViewController 的生命周期这也是 UIPageViewController 自带的功能。\n@protocol WZPageContentViewControllerDataSource \u0026lt;NSObject\u0026gt; @required /// 返回菜单栏标题数组 - (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; /// 返回对应 index 的 Controller 该方法会缓存ViewController /// /// title 为 KEY /// - (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; @optional /// only can disable `UIPageViewControllerTransitionStylePageCurl` style gestrue /// default is `false` - (BOOL)enablePageCurlGesture; /// default is `UIPageViewControllerTransitionStyleScroll` - (UIPageViewControllerTransitionStyle)pageStyle; /// 对应 cell 的宽度 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; /// 标题栏的高度控制 - (CGFloat)heightOfMenuContainer; /// default is top /// /// - WZPageContentMenuPositionTop /// - WZPageContentMenuPositionBottom /// - (WZPageContentMenuPosition)menuPositionType; /// register a class or nib first. this method will replace titles /// /// - registerClass:identifier: /// /// - registerNib:identifier: - (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; @end 稍微进行一点自定义\npage的动画相关目前是开放的，我想有时间完善可能会关闭它，可以更纯粹些。\n- (BOOL)enablePageCurlGesture; - (UIPageViewControllerTransitionStyle)pageStyle; 定义每个标题的宽度；\n这里有个小技巧可以帮助你实现如果只有一个或两个标题时又要居中对齐的需求。 设置collection的左右间距和标题宽度，使它们之和占满屏幕 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; 既然 collection 是那么把 Cell 的权限交给你，在这之前请注册你的 Cell，可以在 WZPageContentViewController 头文件找到对应的方法。\n- (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; WZPageContentViewControllerDelegate\u003e WZPageContentViewControllerDelegate # 这里也给到了些简单好用的方法。\n@protocol WZPageContentViewControllerDelegate \u0026lt;NSObject\u0026gt; @optional /// 将要点击index, 此时 `selectedIndex` 还没有变更 - (void)pageContent:(WZPageContentViewController*)content willSelectedAt:(NSInteger)index; /// 点击MenuItem触发的事件： 已经点击index, 此时 `selectedIndex` 已变更 - (void)pageContent:(WZPageContentViewController*)content didSelectedAt:(NSInteger)index; /// 是否需要响应对应的坐标的按钮，默认为true /// /// return false 将不会响应 `willSelectedAt:` `didSelectedAt:` /// - (BOOL)pageContent:(WZPageContentViewController *)content shouldSelectAt:(NSInteger)index; @end 结构\u003e 结构 # 拆解一下结构。是很简单的一个结构，完成所有也只是三四百行。所以造东西主要还是思路问题。\n","date":"2022-11-13","permalink":"/works/06/","section":"Works","summary":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。","title":"WZPageViewController"},{"content":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 添加本地数据存储，在对应的能力判断中添加该数据判断，使得所以引用的地方得到状态的修改。 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息\nSN：可以在回调中判断当前是哪台设备（多设备情况下） 升级/切换信息：设备重启后校验版本或ID判断成功与否 回调记录：回调过长（多）大概率设备没有重启，或其他错误，判断为超时，停止计时器 定时器\u003e 定时器 # 需要持续获取设备信息，那么定时器必不可少，当然它的任务必须在异步执行，防止堵塞主线。\n调用设备状态 如果有状态直接输出给回调 如果没有状态，那么设备大概率是断开了，在升级或重启，这个时候需要请求设备算法包信息，不过不需要频繁请求，可以在非主线程中使用同步堵塞调用。一旦设备响应，比对版本信息判断是否升级成功。 以上，升级过程即封装完毕，只需在对应页面启动定时器并实现回调。\n回调\u003e 回调 # 在回调时给出相应页面所需参数即可。\n","date":"2022-11-13","permalink":"/works/07/","section":"Works","summary":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 添加本地数据存储，在对应的能力判断中添加该数据判断，使得所以引用的地方得到状态的修改。 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息","title":"封装AI算法升级或切换"},{"content":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。\n一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。\n至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。\n所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。\n另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。\n想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。\n豁然开朗！😊\n用原数据对比简直简单…😓！！！\n","date":"2022-11-13","permalink":"/works/02/","section":"Works","summary":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。\n一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。\n至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。\n所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。","title":"时长云存逻辑梳理优化"},{"content":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。\n","date":"2022-11-13","permalink":"/works/05/","section":"Works","summary":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。","title":"第三方登陆会请求两次的问题"},{"content":" 所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.yzong@outlook.com 个人技能\u003e 个人技能 # 6年iOS开发经验(Objective-C / Swift)； 能够独立开发应用，有一定的架构思维； 对内存管理、多线程编程、runtime、runloop、性能优化、AudioUnit等技术有一定的了解； 熟练使用xib、storyboard或代码自动布局； 乐于接受新事物新语言，并有足够的学习动力； 熟练使用MacOS、Xcode开发工具、证书生成、应用上架发布等； svn、git代码管理； 能够简单使用ReactNative、Flutter写界面； 拥有个人博客、Gitbook 有一定的审美能力； 工作经历\u003e 工作经历 # 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今\u003e 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今 # 负责公司iOS应用开发、上线、维护以及定制APP工作。\n工作中使用的是OC语言，主要完成app和摄像头的交互工作，摄像头新增功能的适配。比如，摄像头新增了人形检测，app则需要提供摄像头人形检测的开关控制，等等以及其他方面的控制项。\n云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07\u003e 云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07 # 独立负责公司iOS应用开发、上线、维护的工作。\n工作中使用Swift语言进行开发，处理过iOS系统版本间的适配，APP使用到IM聊天，语音录制播放，视频播放，以及部分热门的第三方库。\n开发初期主要是全局的对应用需求梳理，然后调研热门的第三方库的适用性。复杂页面用代码，简单页面基本都是xib或者storyboard；例如应用中使用到的图表，起初使用的是第三方库Charts，后期因为项目开发基本完毕，觉得项目完全用不上这样复杂的图表，于是自己编写重构，可以实现各种自定义，样式也是随心所欲。\n对每个功能模块进行新建文件夹管理，继承一些负责管理公共功能的父类，例如继承UIViewController，管理所有子类的通用属性、方法。\n应用首页也经过两次改版，一开始是常规的图文列表，这样的列表因为图片高度不固定文字长短不固定，要做的就是把每个cell高度提前计算好，保证流畅度，较好的方式是和后台讨论，事先存储图片需要展示的高度。不过，因为接口在开发小程序时就定下了，所以只能由前端处理高度，缓存已经加载过的高度，提高流畅性；改版后首页改成了堆叠卡片的样式，这个样式的麻烦点就在于卡片坐标的计算。\n对于第三方SDK，则是认真阅读文档，想要实现自己的功能点就基本没啥问题了。\n后期对APP做的最多的就是之前实现得不好的方法重构抽取，对部分业务逻辑重新梳理较好的实现。\n上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02\u003e 上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02 # IOS开发工程师，但是是在项目中期加入，所做的工作则是新业务的开发、维护、升级、上线等日常开发工作。\n工作中使用的是Objective-C语言开发。使我更加了解了应用的生命周期，内存释放机制；熟悉了一些热门的第三方库，提高了业务的开发效率，在阅读大神源码时，也学习了相关代码风格，抽象方法。愈发熟练UIKit，以及自定义视图；涉及图表的地方，使我更加熟练UIBezierpath。\n项目介绍\u003e 项目介绍 # 蛮牛摄像机\u003e 蛮牛摄像机 # 该项目是物联网项目，主要是和摄像头通讯，远程控制摄像头，查看摄像头画面、对讲等功能。\n下拉刷新，上拉加载MJRefresh； 二维码生成与识别； YUV视频帧渲染； AudioUnit音频单元控制； AFNetworking网络请求； 多线程 Braineex脑洞\u003e Braineex脑洞 # 该APP是针对家长与学生群体，发布与接受各种工作的兼职平台，有同时具备分享与聊天的社交系统\n网络请求模块使用的是Moya第三方库； 对象管理使用的是HandyJSON第三方库； 下拉刷新，上拉加载MJRefresh； 二维码生成与识别； 图片加载与缓存使用的是Kingfisher； 集成了环信IM聊天SDK； 集成了JPUSH极光推送SDK； 支持微信小程序、链接等分享，QQ链接分享； 高德商圈API； 微信支付； 支持简单的富文本编辑、显示； 支持视频上传、播放； 易掌握\u003e 易掌握 # 该APP是针对用于企业的ERP管理系统，用户可以在该APP上提交报销单据、加班条、请假申请等服务，亦可以直观的知道单据提交状态，审批状态\n网络请求模块使用的是AFNetworking第三方库； 本地数据管理使用的是FMDB第三方库； 支持离线推送； 支持微信分享； 支持文件上传、OCR识别； ","date":"2022-11-13","permalink":"/resume/","section":"WUYUEZONG","summary":"所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.","title":"简历2022"},{"content":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。\n","date":"2022-11-13","permalink":"/works/01/","section":"Works","summary":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。","title":"通过控制线程并发数量来优化首页在多设备情况下的表现"},{"content":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….\n","date":"2022-11-13","permalink":"/works/03/","section":"Works","summary":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….","title":"项目定制优化"},{"content":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。\n","date":"2022-11-13","permalink":"/works/04/","section":"Works","summary":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。","title":"首页替换第三方组件为系统组件"},{"content":"@synthesize是给属性添加别名，并生成get、set方法（默认使用）\n@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.m文件中属性age的引用方式就是__age, 或self.age; @synthesize age = __age; { NSLog(@\u0026#34;age is %d\u0026#34;, __age); } // set - (void)setAge:(int)age { __age = age; } // get - (int)getAge { return __age; } // 不添加该语句，则系统默认生成 @synthesize age = _age; // 提示 等同于 @synthesize age = age; 也就是该默认的 _age 为 age； @synthesize age; @end @dynamic是告诉编译器不要生成getter、setter方法。\n@interface ViewController : UIViewController @property (assign, nonatomic) int height; @end @implementation ViewController @dynamic height; { self.height = 20; NSLog(@\u0026#34;height is %d\u0026#34;, self.height); } @end // 运行，直接报错 2021-06-01 14:11:01.503408+0800 Unit[3654:233676] *** Terminating app due to uncaught exception \u0026#39;NSInvalidArgumentException\u0026#39;, reason: \u0026#39;-[ViewController setHeight:]: unrecognized selector sent to instance 0x7fd827105730\u0026#39; Terminating app due to uncaught exception \u0026#39;NSInvalidArgumentException\u0026#39;, reason: \u0026#39;-[ViewController height]: unrecognized selector sent to instance 0x7ff842309b40\u0026#39; ","date":"2022-06-30","permalink":"/oc/synthesize-dynamic/","section":"Objective-C","summary":"\u003ccode\u003e@synthesize\u003c/code\u003e是给属性添加别名，并生成get、set方法（默认使用）\u003ccode\u003e@dynamic\u003c/code\u003e是告诉编译器不要生成getter、setter方法。","title":"@synthesize, @dynamic"},{"content":" initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序\u003e initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码\u003e initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !student { //Person类没有初始化 if !person { objc_msgSend([Person class],@seletor(initialize)) } objc_msgSend([Student class],@seletor(initialize)) } } 阅读源码（objc4）\u003e 阅读源码（objc4） # objc-msg-arm64.s objc_msgSend objc-runtime-new.mm class_getInstanceMethod lookUpImpOrNil lookUpImpOrForward _class_initialize callInitialize objc_msgSend(cls, SEL_initialize) ","date":"2022-06-30","permalink":"/oc/initialize/","section":"Objective-C","summary":"initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。","title":"+initialize"},{"content":" +load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序\u003e load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）\u003e 阅读源码（objc4） # objc-os.mm _objc_init load_images prepare_load_methods schedule_class_load add_class_to_loadable_list add_category_to_loadable_list call_load_methods call_class_loads call_category_loads *(load_method)(cls, SEL_load) +load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用 ","date":"2022-06-30","permalink":"/oc/load/","section":"Objective-C","summary":"+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。","title":"+load"},{"content":"","date":"2022-06-30","permalink":"/tags/associationobject/","section":"Tags","summary":"","title":"AssociationObject"},{"content":"AssociationObject关联对象的原理\u003e AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有\nAssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map\u0026lt;disguised_ptr_t, ObjectAssociationMap\u0026gt; class ObjectAssociationMap: public std::map\u0026lt;void *, ObjcAssociationMap\u0026gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构\u003e 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用\u003e AssociationObject关联对象的使用 # 关联对象常用API\u003e 关联对象常用API # 添加关联对象\nvoid objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) 获取关联对象\nid objc_getAssociatedObject(id object, const void * key) 移除所有关联对象\nvoid objc_removeAssociatedObjects(id object) 关联对象方法Key参数的常见用法\u003e 关联对象方法Key参数的常见用法 # static void *MyKey = \u0026amp;MyKey; objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, MyKey) static char MyKey; objc_setAssociatedObject(obj, \u0026amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, \u0026amp;MyKey) // 使用属性名作为key objc_setAssociatedObject(obj, @\u0026#34;property\u0026#34;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC); objc_getAssociatedObject(obj, @\u0026#34;property\u0026#34;); // 使用get方法的@selecor作为key（推荐） objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC) objc_getAssociatedObject(obj, @selector(getter)) 关联对象方法中 “objc_AssociationPolicy” 说明\u003e 关联对象方法中 “objc_AssociationPolicy” 说明 # objc_AssociationPolicy 对应修饰符 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_COPY copy atomic OBJC_ASSOCIATION_RETAIN strong atomic OBJC_ASSOCIATION_COPY_NONATOMIC copy nonatomic OBJC_ASSOCIATION_RETAIN_NONATOMIC strong nonatomic 通过关联对象实现分类（Category）属性的get、set方法。\u003e 通过关联对象实现分类（Category）属性的get、set方法。 # #import \u0026#34;Person+Test.h\u0026#34; #import \u0026lt;objc/runtime.h\u0026gt; @implementation Person(Test) - (void)setAge:(int)age { objc_setAssociatedObject(self, @selector(age), @(age), OBJC_ASSOCIATION_COPY_NONATOMIC); } - (int)age { return [objc_getAssociatedObject(self, _cmd) intValue]; } @end ","date":"2022-06-30","permalink":"/oc/association-object/","section":"Objective-C","summary":"关联对象的原理与使用","title":"AssociationObject"},{"content":"","date":"2022-06-30","permalink":"/tags/autoreleasepool/","section":"Tags","summary":"","title":"AutoreleasePool"},{"content":" 自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构\u003e AutoreleasePoolPage内部结构 # 每个 AutoreleasePoolPage 对象占用 4096 字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放 autorelease 对象的地址 所有的 AutoreleasePoolPage 对象通过双向链表的形式连接在一起 @autoreleasepool作用原理\u003e @autoreleasepool作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。\n说明\u003e 说明 # 调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址。 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY id *next指向了下一个能存放autorelease对象地址的区域\n","date":"2022-06-30","permalink":"/oc/autorelease-pool/","section":"Objective-C","summary":"自动释放池的原理与使用","title":"AutoreleasePool"},{"content":"","date":"2022-06-30","permalink":"/tags/block/","section":"Tags","summary":"","title":"Block"},{"content":"Block的本质\u003e Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。\nblock的底层结构\u003e block的底层结构 # block的变量捕获（capture）\u003e block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制\n变量类型 是否捕获到block内部 访问方式 auto 修饰符（局部变量） 会捕获 值传递 static 修饰符（局部变量） 会捕获 指针传递 全局变量 不捕获 直接访问 局部变量auto(自动变量)\u003e 局部变量auto(自动变量) # 平时写的局部变量，默认就有auto（自动变量，离开作用域 { } 就会自动销毁），该类型变量一般存储在Stack栈上。 #import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { // 实际上是auto int age = 10, 表示自动释放的局部变量，离开作用域就会被释放。 int age = 10; void(^block)(void) = ^{ NSLog(@\u0026#34;age is %d\u0026#34;, age); }; block(); } return 0; } // 将代码转为编译后代码 int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; int age = 10; void(*block)(void) = ((void (*)())\u0026amp;__main_block_impl_0((void *)__main_block_func_0, \u0026amp;__main_block_desc_0_DATA, age)); ((void (*)(__block_impl *))((__block_impl *)block)-\u0026gt;FuncPtr)((__block_impl *)block); } return 0; } // 找到block最后生成的结构体，这里可以看到age成为该结构体的一个变量。 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int age; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) { impl.isa = \u0026amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 对象类型的auto变量\u003e 对象类型的auto变量 # block内部调用对象时，会自动生成相应的内存管理方法。并在适当的时候retain或relese\n当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用。 调用copy方法将会调用block内部的_Block_object_assign函数，_Block_object_assign会根据auto变量的修饰符（__strong, __weak, __unsafe_unretained）做出相应的操作。形成强引用（retain）或者弱引用。 block从堆上移除，会调用blcok内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose会自动释放引用的auto变量。 局部变量static（静态局部变量）\u003e 局部变量static（静态局部变量） # 修饰符 extern/static/const/UIKIT_EXTERN(OC版extern) 的使用\n静态变量（static 修饰的变量）都在全局数据区分配内存，包括静态全局变量和静态局部变量。直到程序结束运行，它才会被释放。\nstatic int height = 20; // static 局部变量也捕获，但和auto变量不同，static存储的是指针，指向-\u0026gt;height内存地址 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) { impl.isa = \u0026amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; block的类型\u003e block的类型 # block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\nNSGlobalBlock （ _NSConcreteGlobalBlock ） NSStackBlock （ _NSConcreteStackBlock ） NSMallocBlock （ _NSConcreteMallocBlock ） 各类型所处内存位置如图\nblock类型 环境 内存区、释放机制 NSGlobalBlock 没有访问auto变量 全局数据区：程序运行结束才会被释放 NSStackBlock 访问auto变量 栈区：变量在作用域结束就会被释放 NSMallocBlock __NSStackBlock__调用了copy 堆区：需要程序员手动管理内存申请、释放 block的copy\u003e block的copy # block类型 副本源的存储域 复制效果 _NSConcreteStackBlock 栈 从栈复制到堆 _NSConcreteGlobalBlock 程序数据区域 什么也不做 _NSConcreteMallocBlock 堆 引用计数器增加 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况 block作为函数返回值时\ntypedef void (^Block)(void); - (Block)doSomething { Block b = ^{ }; return b; } 将block赋值给__strong指针时\nint a = 10; // b访问了auto变量，理论上是__NSStackBlock__, 但是b 默认被__strong修饰 // 所以ARC中会被copy操作上堆。 // 实际上是 __strong Block b = ... Block b = ^{ NSLog(@\u0026#34;a is %d\u0026#34;, a); }; // weakb 访问了auto变量，所以在栈上__NSStackBlock__ __weak Block weakb = ^{ NSLog(@\u0026#34;a is %d\u0026#34;, a); }; // ^{} 没有访问auto变量，所以为：__NSGlobalBlock__ NSLog(@\u0026#34;b class is %@, and block2 class is %@, weakb class is %@\u0026#34;, [b class], [^{} class], [weakb class]); // 打印输出 b class is __NSMallocBlock__, and block2 class is __NSGlobalBlock__, block3 class is __NSStackBlock__ block作为Cocoa API中方法名含有usingBlock的方法参数时\n[[[NSArray alloc] init] enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { }]; block作为GCD API的方法参数时\n// dispatch_async(dispatch_queue_t _Nonnull queue, \u0026lt;#^(void)block#\u0026gt;) dispatch_async(dispatch_get_main_queue(), ^{ }); MRC下block属性的建议写法\u003e MRC下block属性的建议写法 # @property (copy, nonatomic) void (^block)(void); ARC下block属性的建议写法\u003e ARC下block属性的建议写法 # @property (strong, nonatomic) void (^block)(void); @property (copy, nonatomic) void (^block)(void); __block的本质是什么？\u003e __block的本质是什么？ # __block会将修饰对象封装成__Block_byref_a_0结构体，将该对象作为自己的成员变量，如果是对象类型，同时会生成__Block_byref_id_object_copy方法和__Block_byref_id_object_dispose，对其内存进行管理。\n// 修饰基本数据类型 __block int a = 10; NSLog(@\u0026#34;a is %d\u0026#34;, a); // 转为源码 struct __Block_byref_a_0 { void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; }; // 修饰对象 __block NSObject *obj = [[NSObject alloc] init]; NSLog(@\u0026#34;str is %@\u0026#34;, obj); struct __Block_byref_obj_0 { void *__isa; __Block_byref_obj_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *obj; }; __block的使用\u003e __block的使用 # 编译器会将__block变量包装成一个对象\n__block可以用于解决block内部无法修改auto变量值的问题\u003e __block可以用于解决block内部无法修改auto变量值的问题 # int age = 10; void (^block)(void) = ^{ NSLog(@\u0026#34;age is %d\u0026#34;, age); }; age = 20; block(); // 打印输出 2021-05-30 21:44:34.484323+0800 Strong\u0026amp;Weak[7070:466915] age is 10 这种情况，block捕获age，并将age的值赋值给了block对象中的age。所以之后改变age，也不改变block中的age。通过__block修饰，则会生成一个__Block_byref_age_1结构体\n__block int age = 10; struct __Block_byref_age_1 { void *__isa; __Block_byref_age_1 *__forwarding; // 指向自己的指针 int __flags; int __size; int age; }; // 此时age = 20，在源码中是，第一个age（__Block_byref_age_1） // 相当于age.age,将值赋值给age对象中的age。 // age.age指向的地址没有改变 (age.__forwarding-\u0026gt;age) = 20; // 所以打印输出自然是20 2021-05-30 22:03:02.218831+0800 Strong\u0026amp;Weak[7264:480507] age is 20 __block不能修饰全局变量、静态变量（static）\u003e __block不能修饰全局变量、静态变量（static） # __block的内存管理\u003e __block的内存管理 # 当block在栈上时，并不会对__block变量产生强引用 当block被copy到堆时 会调用block内部的copy函数 copy函数内部会调用_Block_object_assign函数 _Block_object_assign函数会对__block变量形成强引用（retain） 当block从堆中移除时 会调用block内部的dispose函数 dispose函数内部会调用_Block_object_dispose函数 _Block_object_dispose函数会自动释放引用的__block变量（release） __block的__forwarding指针\u003e __block的__forwarding指针 # 循环引用\u003e 循环引用 # 循环引用的产生\u003e 循环引用的产生 # 对象持有block，而block持有对象就会造成，双方都无法释放，导致循环应用。 对象持有block，block持有__block变量，__block持有对象也会造成循环引用 循环引用的解决\u003e 循环引用的解决 # 用__weak、__unsafe_unretained解决 用__block解决（必须要调用block） 解决循环引用问题 - MRC\u003e 解决循环引用问题 - MRC # 问题s\u003e 问题s # Q：为什么捕获age（auto 自由变量）？\n**A：**局部自由变量在离开作用域时就会被释放，如果block在其他地方调用，此时，之前的变量已经被释放，所以需要事先保存下来，以防数据丢失。\nQ：以下代码的输出分别是什么？\n#import \u0026lt;Foundation/Foundation.h\u0026gt; int main(int argc, const char * argv[]) { @autoreleasepool { // 实际上是auto int age = 10, 表示自动释放的局部变量，离开作用域就会被释放。 int age = 10; static int height = 20; void(^block)(void) = ^{ NSLog(@\u0026#34;age is %d and height is %d\u0026#34;, age, height); }; age = 1; height = 2; block(); } return 0; } A：\nage is 10 and height is 2 age = 10 时，已经被存储到block中，之后改变 age 并不会影响 block 中的 age。block 中 height 存储的时指向 height 的指针，所以在调用时取到的是 height 对应地址的值。\nQ：block在修改NSMutableArray，需不需要添加__block？\nA：不需要，NSMutableArray本身是个对象，会被block强引用，block没有释放，NSMutableArray也不会被释放，加__block属于多此一举，凭空增加内存。\nQ：block的属性修饰词为什么是copy？使用block有哪些使用注意？\nA：block一旦没有进行copy操作，就不会在堆上；使用注意：循环引用问题\nQ：__block的作用是什么？有什么使用注意点？\nA：__block可以用于解决block内部无法修改auto变量值的问题，__block不能修饰全局变量、静态变量（static）。\n","date":"2022-06-30","permalink":"/oc/block/","section":"Objective-C","summary":"\u003ccode\u003eblock\u003c/code\u003e本质上也是一个OC对象，它内部也有个\u003ccode\u003eisa指针\u003c/code\u003e，\u003ccode\u003eblock\u003c/code\u003e是封装了函数调用以及函数调用环境的OC对象。","title":"Block"},{"content":"","date":"2022-06-30","permalink":"/tags/cache/","section":"Tags","summary":"","title":"Cache"},{"content":"","date":"2022-06-30","permalink":"/tags/data-storage/","section":"Tags","summary":"","title":"Data Storage"},{"content":"","date":"2022-06-30","permalink":"/tags/flexbox/","section":"Tags","summary":"","title":"Flexbox"},{"content":"","date":"2022-06-30","permalink":"/tags/ios%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/","section":"Tags","summary":"","title":"iOS签名机制"},{"content":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。\n公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？\n混合密码系统(Hybrid Cryptosystem)\u003e 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。\n单向散列函数\u003e 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。\n特点\n根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）\n如何防止数据被篡改\u003e 如何防止数据被篡改 # 本地模型 网络模型 https://www.realvnc.com/en/connect/download/vnc/ 数字签名\u003e 数字签名 # 了解了单向散列函数，就可以理解数字签名，就可以解答之前 \u0026lsquo;遗留的问题\u0026rsquo; \u0026lsquo;B接收到的消息，真的就是A发送的吗？\u0026rsquo;。数字签名就是消息发送者（A）通过私钥加密消息的散列值的到的结果。接受者则（B）可以通过，A的公钥解密签名的到散列值，同时计算的到收到的消息的散列值，如果相等，则确认是（A）发送的消息。\n要注意的是，数字签名不能保证消息的机密性，它是一种验证手段，可能确保消息的来源和内容的真实性（验证散列值）。\n对于主动攻击者，还存在下面的模型的问题：主动攻击者可能伪造公钥，让发送者误以为是接受者的公钥。\n那如何验证公钥的合法性？\n证书(Certificate)\u003e 证书(Certificate) # 公钥证书（Public-key Certificate，PKC），认证机构（Certificate Authority，CA）施加数字签名。通过国际性组织、政府设立的组织、通过提供认证服务来盈利的企业或个人提供认证服务，也就是发送者，和接收者的第三方担保，它可以确保公钥的合法性。 iOS签名机制\u003e iOS签名机制 # iOS的签名机制，可以保证安装到用户手机上的APP都是经过Apple官方允许的。 不管是真机调试，还是发布APP，开发者都需要经过一系列复杂的步骤\n生成 CertificateSigningRequest.certSigningRequest 文件 获得 ios_development.cer\\ios_distribution.cer 证书文件 注册device、添加App ID 获得*.mobileprovision文件 （描述文件） 通过原理来翻译，则是：\n获得Mac电脑公钥 通过Mac公钥，向Apple申请加密，为公钥（证书） 添加设备，账号 向Apple申请将设备账号包装并生成新公钥（描述文件） XCode自动签名已经完成了以上所有步骤。\n.certSigningRequest、.cer、.mobileprovision文件究竟里面包含了什么？有何用处\n","date":"2022-06-30","permalink":"/ios/ios-signing/","section":"IOS","summary":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。","title":"iOS签名机制"},{"content":"","date":"2022-06-30","permalink":"/tags/ipa/","section":"Tags","summary":"","title":"IPA"},{"content":"","date":"2022-06-30","permalink":"/tags/nstimer/","section":"Tags","summary":"","title":"NSTimer"},{"content":"","date":"2022-06-30","permalink":"/series/oc/","section":"Series","summary":"","title":"OC"},{"content":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.h\u0026gt; 创建 pthread_t 对象以及使用\u003e 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(\u0026amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明\nint pthread_create(pthread_t _Nullable * _Nonnull __restrict, const pthread_attr_t * _Nullable __restrict, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable __restrict); 表示线程对象，指向线程标识符的指针 \u0026amp;thread 表示线程属性，可赋值 NULL 表示函数指针，在 thread 线程中要执行的任务 表示函数参数 pthread 其他相关方法\u003e pthread 其他相关方法 # pthread_create() 创建一个线程 pthread_exit() 终止当前线程 pthread_cancel() 中断另外一个线程的运行 pthread_join() 阻塞当前的线程，直到另外一个线程运行结束 pthread_attr_init() 初始化线程的属性 pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合） pthread_attr_getdetachstate() 获取脱离状态的属性 pthread_attr_destroy() 删除线程的属性 pthread_kill() 向线程发送一个信号 NSThread\u003e NSThread # NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread 。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。\n创建、启动线程\u003e 创建、启动线程 # // 1. 创建线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; // 2. 启动线程 [thread start]; // 线程一启动，就会在线程thread中执行self的run方法 // 新线程调用方法，里边为需要执行的任务 - (void)run { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); } 待更新\u0026hellip; 暂时不想更新😭\n","date":"2022-06-30","permalink":"/ios/pthred-nsthread/","section":"IOS","summary":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.","title":"pthread / NSThread"},{"content":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。\nFlex Direction\u003e Flex Direction # 在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\ncolumn | 从上到下 row | 从左到右 column-reverse | 从下到上 row-reverse | 从右到左 Layout Direction\u003e Layout Direction # ltr | 从左到右 rtl | 从右到左 justifyContent\u003e justifyContent # 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有：\nflex-start flex-end space-between space-around space-evenly Align Items\u003e Align Items # 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有\nstretch | 填满次轴 flex-start flex-end center baseline Align Self\u003e Align Self # 作用同 Align Items，但是只作用于被定义的对象，不影响容器子对象。\nAlign Content\u003e Align Content # 适用于被折行的子视图，即，设置属性flexWrap时（Wrap）。效果同justifyContent，是次轴上的justifyContent。\nflex-start flex-end space-between space-around space-evenly Flex Wrap\u003e Flex Wrap # wrap no-wrap Flex Basis, Grow, and Shrink\u003e Flex Basis, Grow, and Shrink # flexBasis: 视图在主轴上的宽度（auto，int） flexGrow: 视图在主轴上的生长能力（int），grow较大则会填充容器。 flexShrink: 视图在主轴上的缩小能力（int），shrink较大视图则会根据basis或width的值显示。\n","date":"2022-06-30","permalink":"/rn/flex-layout/","section":"React Native","summary":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。","title":"React Native Flexbox"},{"content":"","date":"2022-06-30","permalink":"/tags/%E5%8A%A0%E5%AF%86/","section":"Tags","summary":"","title":"加密"},{"content":" 资源（图片、音频、视频等）\u003e 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.com/tinymind/LSUnusedResources 可执行文件瘦身\u003e 可执行文件瘦身 # 编译器优化 Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -\u0026gt; Code -\u0026gt; Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 ","date":"2022-06-30","permalink":"/oc/ipa/","section":"Objective-C","summary":"安装包瘦身","title":"安装包瘦身"},{"content":"NSTimer、CADisplayLink定时器\u003e NSTimer、CADisplayLink定时器 # CADisplayLink使用\n@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用\n@interface TMViewController () @property (strong, nonatomic) NSTimer * timer; @end - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:(id)target selector:@selector(linkTest) userInfo:nil repeats:YES]; } - (void)dealloc { [_timer invalidate]; } 以上方式如果将target传为self，则会造成self对timer的强引用，timer又对self强引用，双方释放不了，造成循环引用。\n解决方法\u003e 解决方法 # 创建一个不依赖于self的timer - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@\u0026#34;执行任务\u0026#34;); }]; [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_timer invalidate]; } 添加中间对象（NSProxy），弱引用self然后将消息转发给self。 - (void)viewDidLoad { [super viewDidLoad]; _timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[TMProxy initWithTarget:self] selector:@selector(linkTest) userInfo:nil repeats:YES]; } - (void)dealloc { [_timer invalidate]; } // TMProxy实现 @interface TMProxy () @property (weak, nonatomic) id target; @end @implementation TMProxy + (TMProxy *)initWithTarget:(id)target { TMProxy *proxy = [TMProxy alloc]; proxy.target = target; return proxy; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { return [_target methodSignatureForSelector:sel]; } - (void)forwardInvocation:(NSInvocation *)invocation { [invocation invokeWithTarget:_target]; } @end GCD定时器\u003e GCD定时器 # 由于NSTimer是依赖于RunLoop进行工作的，而RunLoop内部除了需要执行NSTimer事务，同时也可能处理其他事务，所以RunLoop进行计时会又不准确的情况。而GCD不依赖于RunLoop，GCD定时器属于系统层面。所以GCD定时器能够相对准确。\n创建GCD定时器\u003e 创建GCD定时器 # @interface ViewController () @property (strong, nonatomic) dispatch_source_t timer; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0); dispatch_source_set_event_handler(timer, ^{ NSLog(@\u0026#34;gcd timer counting.\u0026#34;); }); dispatch_resume(timer); // 防止timer被释放。 _timer = timer; } @end ","date":"2022-06-30","permalink":"/oc/nstimer/","section":"Objective-C","summary":"NSTimer、CADisplayLink定时器","title":"定时器"},{"content":"在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n查看详情 CPU和GPU\u003e CPU和GPU # CPU（Central Processing Unit，中央处理器）\n对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）\nGPU（Graphics Processing Unit，图形处理器）\n纹理的渲染\n在iOS中是双缓冲机制，有前帧缓存、后帧缓存\n屏幕成像原理\u003e 屏幕成像原理 # 硬件时钟会定时发出垂直同步信号（VSync）\nCPU和GPU需要在这个时间间隔把这一帧处理、缓存、并渲染到屏幕上。\n卡顿产生的原因\u003e 卡顿产生的原因 # 卡顿检测\u003e 卡顿检测 # 平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作\n可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的\n耗电优化\u003e 耗电优化 # 耗电来源\u003e 耗电来源 # CPU处理，Processing\n网络，Networking\n定位，Location\n图像，Graphics\n优化\u003e 优化 # 尽可能降低CPU、GPU功耗\n少用定时器\n优化I/O操作\u003e 优化I/O操作 # 尽量不要频繁写入小数据，最好批量一次性写入\n读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问\n数据量比较大的，建议使用数据库（比如SQLite、CoreData）\n网络优化\u003e 网络优化 # 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化\u003e 定位优化 # 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化\u003e 硬件检测优化 # 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件\n","date":"2022-06-30","permalink":"/oc/performance-optimization/","section":"Objective-C","summary":"iOS的性能优化","title":"性能优化"},{"content":"进入 ViewController2\n+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController\n-[ViewController2 viewWillDisappear:] -[ViewController viewWillAppear:] -[ViewController2 viewDidDisappear:] -[ViewController viewDidAppear:] -[ViewController2 dealloc] 当添加了一个子视图时(Storyboard) - 进入\n+[ViewController2 initialize] +[TestView2 initialize] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[TestView2 layoutSubviews] -[TestView2 drawRect:] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 当添加了一个子视图时(Storyboard) - 返回\n-[ViewController2 viewWillDisappear:] -[ViewController viewWillAppear:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[ViewController2 viewDidDisappear:] -[ViewController viewDidAppear:] -[ViewController2 dealloc] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] 单独拆分View2的生命周期\u003e 单独拆分View2的生命周期 # +[TestView2 initialize] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[TestView2 layoutSubviews] -[TestView2 drawRect:] -[TestView2 willMoveToWindow:] -[TestView2 didMoveToWindow] -[TestView2 willMoveToSuperview:] -[TestView2 didMoveToSuperview] 给 View2 动态添加一个子视图时\n+[TestView initialize] -[TestView willMoveToWindow:] -[TestView willMoveToSuperview: -[TestView didMoveToWindow] -[TestView didMoveToSuperview] -[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 修改子视图 frame 时\n-[TestView willMoveToWindow:] -[TestView willMoveToSuperview:] -[TestView didMoveToWindow] -[TestView didMoveToSuperview] -[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 简化对View2子视图的操作\u003e 简化对View2子视图的操作 # 被添加时\n+[TestView initialize] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] 被修改时 frame 时\n-[TestView2 didAddSubview:] -[TestView2 addSubview:] -[TestView2 layoutSubviews] -[TestView layoutSubviews] -[TestView layoutSubviews] -[TestView drawRect:] ","date":"2022-06-30","permalink":"/oc/uiviewcontroller-life-cycle/","section":"Objective-C","summary":"探究UIViewController生命周期","title":"探究UIViewController生命周期"},{"content":"首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。\n应用沙盒文件夹\u003e 应用沙盒文件夹 # Application（应用程序包）: 包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。\nDocuments: 文档目录，要保存程序生成的数据，会自动备份到iCloud中。保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录。⚠️ 不要保存从网络上下载的文件，否则会无法上架。\nLibrary：\n用户偏好，使用NSUserDefault直接读写。 如果想数据及时写入磁盘，还需要调用同步方法。 保存临时文件，“后续需要使用”，例如：缓存图片，离线数据（地图数据） 系统不会清理cache目录中的文件，所以要求程序开发时，必须提供cache目录的清理解决方案。 Caches: 存放体积大而又不需要备份的数据 Preference: 保存应用的所有偏好设置，iCloud会备份设置信息。 Tmp: 临时文件，系统会自动清理。重启时会清理。保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。\n存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除。 保存临时文件，“后续无需使用” tmp目录中的文件，系统会自动清理。 重启手机，tmp目录会被清空。 系统磁盘空间不足时，系统也会自动清理。 iOS应用可执行文件里面都有什么？\n静态库 iOS APP可执行文件的组成\n","date":"2022-06-30","permalink":"/oc/data-store/","section":"Objective-C","summary":"首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。","title":"数据持久化、缓存"},{"content":"","date":"2022-06-30","permalink":"/tags/%E7%BA%BF%E7%A8%8B/","section":"Tags","summary":"","title":"线程"},{"content":"","date":"2022-06-13","permalink":"/tags/app-lanuch/","section":"Tags","summary":"","title":"App Lanuch"},{"content":"APP启动的分类\u003e APP启动的分类 # 冷启动\u003e 冷启动 # 冷启动（Cold Launch）：从零开始启动APP\n热启动\u003e 热启动 # 热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP\n💡 APP启动优化主要是针对冷启动进行优化的 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -\u0026gt; Run -\u0026gt; Arguments）\nDYLD_PRINT_STATISTICS设置为1\n如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1\n冷启动的三个阶段\u003e 冷启动的三个阶段 # dyld runtime main dyld\u003e dyld # dyld，即dynamic link editor，Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）\ndyld做的事情\u003e dyld做的事情 # 装载APP的可执行文件，同时会递归加载所有依赖的动态库 当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理 APP启动时，runtime做的事情\u003e APP启动时，runtime做的事情 # 调用map_images进行可执行文件内容的解析和处理 在load_iamges中调用call_load_methods，调用所有Class和Category的+load方法 进行各种objc结构的初始化（注册Objc类、初始化类对象等等） 调用C++静态初始化器和__attribute__((constructor))修饰的函数 到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP \u0026hellip;）都已经按格式成功加载到内存中，被runtime所管理\nmain\u003e main # APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库 并由runtime负责加载成objc定义的结构 所有初始化工作结束后，dyld就会调用main函数 接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法 启动优化按不同的阶段\u003e 启动优化按不同的阶段 # dyld\u003e dyld # 减少动态库、合并一些动态库（定期清理不必要的动态库） 减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类） 减少C++虚函数数量 Swift尽量使用struct runtime\u003e runtime # 用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load\nmain\u003e main # 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中 按需加载 ","date":"2022-06-13","permalink":"/oc/app-lanuch/","section":"Objective-C","summary":"APP启动介绍与优化","title":"App Lanuch"},{"content":"","date":"2022-06-13","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001-01-01","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"}]