[{"content":"","date":"131313.1111.1111","permalink":"/tags/app/","section":"Tags","summary":"","title":"app"},{"content":"","date":"131313.1111.1111","permalink":"/series/app/","section":"Series","summary":"","title":"App"},{"content":"这里会展示我自己应用的相关信息\n","date":"131313.1111.1111","permalink":"/apps/","section":"App","summary":"这里会展示我自己应用的相关信息","title":"App"},{"content":"","date":"131313.1111.1111","permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes"},{"content":" 碎片笔记本\n使用说明\u003e 使用说明 # 您可以纯粹的记录笔记，或者是把笔记和标签关联，比如这篇笔记\n它关联了状态标签\n默认状态是：🟡待办 选中状态是：🟢已完成 现在就可以尝试一下左上角的按钮，点点看😊\n如果您有一个待办事项，使用这个标签可轻松标记状态，当然您可以自定义，新建任何事件的两面性，或者只是新建个默认标签。\n笔记\n可以置顶🔝 可以编辑✒️ 可以删除🚮 也可以分享📟 只需长按列表某个笔记即可呼出菜单!!!\nEnjoy~\n隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 碎片笔记本 （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"131313.1111.1111","permalink":"/apps/notes/","section":"App","summary":"碎片笔记本\n使用说明\u003e 使用说明 # 您可以纯粹的记录笔记，或者是把笔记和标签关联，比如这篇笔记\n它关联了状态标签\n默认状态是：🟡待办 选中状态是：🟢已完成 现在就可以尝试一下左上角的按钮，点点看😊\n如果您有一个待办事项，使用这个标签可轻松标记状态，当然您可以自定义，新建任何事件的两面性，或者只是新建个默认标签。\n笔记\n可以置顶🔝 可以编辑✒️ 可以删除🚮 也可以分享📟 只需长按列表某个笔记即可呼出菜单!!!\nEnjoy~\n隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 碎片笔记本 （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.","title":"Notes: 碎片笔记本使用手册"},{"content":"","date":"131313.1111.1111","permalink":"/tags/resume/","section":"Tags","summary":"","title":"Resume"},{"content":"","date":"131313.1111.1111","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":" ","date":"131313.1111.1111","permalink":"/tags/","section":"Tags","summary":" ","title":"Tags"},{"content":"","date":"131313.1111.1111","permalink":"/tags/upaper/","section":"Tags","summary":"","title":"Upaper"},{"content":"隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 Upaper （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。\n三、我们如何共享、转让、公开披露您的个人信息\u003e 三、我们如何共享、转让、公开披露您的个人信息 # 在管理我们的日常业务活动所需要时，为追求合法利益以更好地服务客户， 我们将合规且恰当的使用您的个人信息。出于对业务和各个方面的综合考虑， 我们仅自身使用这些数据，不与任何第三方分享。 我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。 在符合法律法规的前提下，当我们收到上述披露信息的请求时，我们会要求必须出具与之相应的法律文件，如传票或调查函。 我们坚信，对于要求我们提供的信息，应该在法律允许的范围内尽可能保持透明。\n在以下情形中，共享、转让、公开披露您的个人信息无需事先征得您的授权同意：\n与国家安全、国防安全直接相关的； 与犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行向社会公众公开的个人信息； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 根据个人信息主体要求签订和履行合同所必需的； 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； 法律法规规定的其他情形。 ","date":"131313.1111.1111","permalink":"/apps/upaper/","section":"App","summary":"隐私政策\u003e 隐私政策 # 欢迎您访问我们的产品。 Upaper （包括App等产品提供的服务，以下简称“产品和服务”）是由 WUYUEZONG （以下简称“我们”）开发并运营的。 确保用户的数据安全和隐私保护是我们的首要任务， 本隐私政策载明了您访问和使用我们的产品和服务时所收集的数据及其处理方式。 请您在继续使用我们的产品前务必认真仔细阅读并确认充分理解本隐私政策全部规则和要点， 一旦您选择使用，即视为您同意本隐私政策的全部内容，同意我们按其收集和使用您的相关信息。 如您在在阅读过程中，对本政策有任何疑问，可联系我们的客服咨询， 请通过 w.yzong@outlook.com 或产品中的反馈方式与我们取得联系。 如您不同意相关协议或其中的任何条款的，您应停止使用我们的产品和服务。\n本隐私政策帮助您了解以下内容：\n一、我们如何收集和使用您的个人信息； 二、我们如何存储和保护您的个人信息； 三、我们如何共享、转让、公开披露您的个人信息； 一、我们如何收集和使用您的个人信息\u003e 一、我们如何收集和使用您的个人信息 # 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息， 结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 由于我们的产品和服务并不需要此类信息，因此很高兴的告知您， 我们不会收集关于您的任何个人信息。\n二、我们如何存储和保护您的个人信息\u003e 二、我们如何存储和保护您的个人信息 # 作为一般规则，我们仅在实现信息收集目的所需的时间内保留您的个人信息。 我们会在对于管理与您之间的关系严格必要的时间内保留您的个人信息 （例如，当您开立帐户，从我们的产品获取服务时）。 出于遵守法律义务或为证明某项权利或合同满足适用的诉讼时效要求的目的， 我们可能需要在上述期限到期后保留您存档的个人信息，并且无法按您的要求删除。","title":"Upaper: 高清壁纸"},{"content":"","date":"131313.1111.1111","permalink":"/tags/worknote/","section":"Tags","summary":"","title":"WorkNote"},{"content":"","date":"131313.1111.1111","permalink":"/works/","section":"Works","summary":"","title":"Works"},{"content":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平\n","date":"131313.1111.1111","permalink":"/","section":"WUYUEZONG","summary":"青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。\n习近平","title":"WUYUEZONG"},{"content":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。\n@interface WZPageContentViewController : UIViewController @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDataSource\u0026gt; dataSource; @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDelegate\u0026gt; delegate; @property (strong, nonatomic, readonly) UIPageViewController *pageController; @property (strong, nonatomic, readonly) __kindof UIViewController *selectedController; @property (assign, nonatomic, readonly) NSInteger selectedIndex; @property(nonatomic) WZPageMenuItemStyle *selectedStyle; @property(nonatomic) WZPageMenuItemStyle *normalStyle; /// 是否展示分割线 @property(nonatomic) BOOL showDividingLine; /// 是否展示位置指示器 @property(nonatomic) BOOL showIndicator; - (void)reloadDataAt:(NSInteger)index; /// 刷新菜单栏 - (void)reloadMenus; - (void)registerClass:(Class)aClass identifier:(nonnull NSString *)identifier; - (void)registerNib:(UINib *)nib identifier:(NSString *)identifier; @end 设计结果肯定是以业务为依托，搭建基础框架，然后在条条框框里填写需求。所以先看一下代理设置了些啥，最后再拆解整个结构。\nWZPageContentViewControllerDataSource\u003e WZPageContentViewControllerDataSource # 首先他需要一个标题数据源；- (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; 然后给到对应数据源的页面；- (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; 如果你只需要这样的基础页面，那你完成设置了。因为内部已经实现了基础样式，选中的标题高亮，粗体。帮你缓存已经加载过的页面，同时给到对应appear disappear 正常 UIViewController 的生命周期这也是 UIPageViewController 自带的功能。\n@protocol WZPageContentViewControllerDataSource \u0026lt;NSObject\u0026gt; @required /// 返回菜单栏标题数组 - (NSArray\u0026lt;NSString *\u0026gt; *)titlesForMenuItems; /// 返回对应 index 的 Controller 该方法会缓存ViewController /// /// title 为 KEY /// - (__kindof UIViewController *)contentForPageContentAt:(NSInteger)index; @optional /// only can disable `UIPageViewControllerTransitionStylePageCurl` style gestrue /// default is `false` - (BOOL)enablePageCurlGesture; /// default is `UIPageViewControllerTransitionStyleScroll` - (UIPageViewControllerTransitionStyle)pageStyle; /// 对应 cell 的宽度 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; /// 标题栏的高度控制 - (CGFloat)heightOfMenuContainer; /// default is top /// /// - WZPageContentMenuPositionTop /// - WZPageContentMenuPositionBottom /// - (WZPageContentMenuPosition)menuPositionType; /// register a class or nib first. this method will replace titles /// /// - registerClass:identifier: /// /// - registerNib:identifier: - (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; @end 稍微进行一点自定义\npage的动画相关目前是开放的，我想有时间完善可能会关闭它，可以更纯粹些。\n- (BOOL)enablePageCurlGesture; - (UIPageViewControllerTransitionStyle)pageStyle; 定义每个标题的宽度；\n这里有个小技巧可以帮助你实现如果只有一个或两个标题时又要居中对齐的需求。 设置collection的左右间距和标题宽度，使它们之和占满屏幕 - (CGFloat)widthOfMenuItemCollection:(UICollectionView*)collection atIndex:(NSInteger)index; 既然 collection 是那么把 Cell 的权限交给你，在这之前请注册你的 Cell，可以在 WZPageContentViewController 头文件找到对应的方法。\n- (__kindof UICollectionViewCell *)page:(WZPageContentViewController*)page collection:(UICollectionView*)collection titleViewForMenuItemsAt:(NSIndexPath *)indexPath; WZPageContentViewControllerDelegate\u003e WZPageContentViewControllerDelegate # 这里也给到了些简单好用的方法。\n@protocol WZPageContentViewControllerDelegate \u0026lt;NSObject\u0026gt; @optional /// 将要点击index, 此时 `selectedIndex` 还没有变更 - (void)pageContent:(WZPageContentViewController*)content willSelectedAt:(NSInteger)index; /// 点击MenuItem触发的事件： 已经点击index, 此时 `selectedIndex` 已变更 - (void)pageContent:(WZPageContentViewController*)content didSelectedAt:(NSInteger)index; /// 是否需要响应对应的坐标的按钮，默认为true /// /// return false 将不会响应 `willSelectedAt:` `didSelectedAt:` /// - (BOOL)pageContent:(WZPageContentViewController *)content shouldSelectAt:(NSInteger)index; @end 结构\u003e 结构 # 拆解一下结构。是很简单的一个结构，完成所有也只是三四百行。所以造东西主要还是思路问题。\n","date":"131313.1111.1111","permalink":"/works/06/","section":"Works","summary":"头文件\u003e 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。\n@interface WZPageContentViewController : UIViewController @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDataSource\u0026gt; dataSource; @property (weak, nonatomic) id\u0026lt;WZPageContentViewControllerDelegate\u0026gt; delegate; @property (strong, nonatomic, readonly) UIPageViewController *pageController; @property (strong, nonatomic, readonly) __kindof UIViewController *selectedController; @property (assign, nonatomic, readonly) NSInteger selectedIndex; @property(nonatomic) WZPageMenuItemStyle *selectedStyle; @property(nonatomic) WZPageMenuItemStyle *normalStyle; /// 是否展示分割线 @property(nonatomic) BOOL showDividingLine; /// 是否展示位置指示器 @property(nonatomic) BOOL showIndicator; - (void)reloadDataAt:(NSInteger)index; /// 刷新菜单栏 - (void)reloadMenus; - (void)registerClass:(Class)aClass identifier:(nonnull NSString *)identifier; - (void)registerNib:(UINib *)nib identifier:(NSString *)identifier; @end 设计结果肯定是以业务为依托，搭建基础框架，然后在条条框框里填写需求。所以先看一下代理设置了些啥，最后再拆解整个结构。","title":"WZPageViewController"},{"content":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息\nSN：可以在回调中判断当前是哪台设备（多设备情况下） 升级/切换信息：设备重启后校验版本或ID判断成功与否 回调记录：回调过长（多）大概率设备没有重启，或其他错误，判断为超时，停止计时器 定时器\u003e 定时器 # 需要持续获取设备信息，那么定时器必不可少，当然它的任务必须在异步执行，防止堵塞主线。\n调用设备状态 如果有状态直接输出给回调 如果没有状态，那么设备大概率是断开了，在升级或重启，这个时候需要请求设备算法包信息，不过不需要频繁请求，可以在非主线程中使用同步堵塞调用。一旦设备响应，比对版本信息判断是否升级成功。 以上，升级过程即封装完毕，只需在对应页面启动定时器并实现回调。\n回调\u003e 回调 # 在回调时给出相应页面所需参数即可。\n","date":"131313.1111.1111","permalink":"/works/07/","section":"Works","summary":"首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。\n那么这个时候首先会想到单例，在已有的单例中扩充该功能。\n需求点\u003e 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； \u0026hellip; 其他页面优先级不高，暂不考虑 实现\u003e 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息\nSN：可以在回调中判断当前是哪台设备（多设备情况下） 升级/切换信息：设备重启后校验版本或ID判断成功与否 回调记录：回调过长（多）大概率设备没有重启，或其他错误，判断为超时，停止计时器 定时器\u003e 定时器 # 需要持续获取设备信息，那么定时器必不可少，当然它的任务必须在异步执行，防止堵塞主线。\n调用设备状态 如果有状态直接输出给回调 如果没有状态，那么设备大概率是断开了，在升级或重启，这个时候需要请求设备算法包信息，不过不需要频繁请求，可以在非主线程中使用同步堵塞调用。一旦设备响应，比对版本信息判断是否升级成功。 以上，升级过程即封装完毕，只需在对应页面启动定时器并实现回调。\n回调\u003e 回调 # 在回调时给出相应页面所需参数即可。","title":"封装AI算法升级或切换"},{"content":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。 一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。 至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。 所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。 另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。 想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。\n豁然开朗！😊\n用原数据对比简直简单…😓！！！\n","date":"131313.1111.1111","permalink":"/works/02/","section":"Works","summary":"当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。 一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。 至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。 所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。 另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。 想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。\n豁然开朗！😊\n用原数据对比简直简单…😓！！！","title":"时长云存逻辑梳理优化"},{"content":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。\n","date":"131313.1111.1111","permalink":"/works/05/","section":"Works","summary":"通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。","title":"第三方登陆会请求两次的问题"},{"content":" 所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.yzong@outlook.com 个人技能\u003e 个人技能 # 6年iOS开发经验(Objective-C / Swift)； 能够独立开发应用，有一定的架构思维； 对内存管理、多线程编程、runtime、runloop、性能优化、AudioUnit等技术有一定的了解； 熟练使用xib、storyboard或代码自动布局； 乐于接受新事物新语言，并有足够的学习动力； 熟练使用MacOS、Xcode开发工具、证书生成、应用上架发布等； svn、git代码管理； 能够简单使用ReactNative、Flutter写界面； 拥有个人博客、Gitbook 有一定的审美能力； 工作经历\u003e 工作经历 # 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今\u003e 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今 # 负责公司iOS应用开发、上线、维护以及定制APP工作。\n工作中使用的是OC语言，主要完成app和摄像头的交互工作，摄像头新增功能的适配。比如，摄像头新增了人形检测，app则需要提供摄像头人形检测的开关控制，等等以及其他方面的控制项。\n云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07\u003e 云南龙腾软件开发有限公司iOS(swift)开发 - 昆明 - 2018.03 ～ 2021.07 # 独立负责公司iOS应用开发、上线、维护的工作。\n工作中使用Swift语言进行开发，处理过iOS系统版本间的适配，APP使用到IM聊天，语音录制播放，视频播放，以及部分热门的第三方库。\n开发初期主要是全局的对应用需求梳理，然后调研热门的第三方库的适用性。复杂页面用代码，简单页面基本都是xib或者storyboard；例如应用中使用到的图表，起初使用的是第三方库Charts，后期因为项目开发基本完毕，觉得项目完全用不上这样复杂的图表，于是自己编写重构，可以实现各种自定义，样式也是随心所欲。\n对每个功能模块进行新建文件夹管理，继承一些负责管理公共功能的父类，例如继承UIViewController，管理所有子类的通用属性、方法。\n应用首页也经过两次改版，一开始是常规的图文列表，这样的列表因为图片高度不固定文字长短不固定，要做的就是把每个cell高度提前计算好，保证流畅度，较好的方式是和后台讨论，事先存储图片需要展示的高度。不过，因为接口在开发小程序时就定下了，所以只能由前端处理高度，缓存已经加载过的高度，提高流畅性；改版后首页改成了堆叠卡片的样式，这个样式的麻烦点就在于卡片坐标的计算。\n对于第三方SDK，则是认真阅读文档，想要实现自己的功能点就基本没啥问题了。\n后期对APP做的最多的就是之前实现得不好的方法重构抽取，对部分业务逻辑重新梳理较好的实现。\n上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02\u003e 上海比孚信息科技有限公司iOS(OC)开发 - 上海 - 2015.11 ～ 2018.02 # IOS开发工程师，但是是在项目中期加入，所做的工作则是新业务的开发、维护、升级、上线等日常开发工作。\n工作中使用的是Objective-C语言开发。使我更加了解了应用的生命周期，内存释放机制；熟悉了一些热门的第三方库，提高了业务的开发效率，在阅读大神源码时，也学习了相关代码风格，抽象方法。愈发熟练UIKit，以及自定义视图；涉及图表的地方，使我更加熟练UIBezierpath。\n项目介绍\u003e 项目介绍 # 蛮牛摄像机\u003e 蛮牛摄像机 # 该项目是物联网项目，主要是和摄像头通讯，远程控制摄像头，查看摄像头画面、对讲等功能。\n下拉刷新，上拉加载MJRefresh； 二维码生成与识别； YUV视频帧渲染； AudioUnit音频单元控制； AFNetworking网络请求； 多线程 Braineex脑洞\u003e Braineex脑洞 # 该APP是针对家长与学生群体，发布与接受各种工作的兼职平台，有同时具备分享与聊天的社交系统\n网络请求模块使用的是Moya第三方库； 对象管理使用的是HandyJSON第三方库； 下拉刷新，上拉加载MJRefresh； 二维码生成与识别； 图片加载与缓存使用的是Kingfisher； 集成了环信IM聊天SDK； 集成了JPUSH极光推送SDK； 支持微信小程序、链接等分享，QQ链接分享； 高德商圈API； 微信支付； 支持简单的富文本编辑、显示； 支持视频上传、播放； 易掌握\u003e 易掌握 # 该APP是针对用于企业的ERP管理系统，用户可以在该APP上提交报销单据、加班条、请假申请等服务，亦可以直观的知道单据提交状态，审批状态\n网络请求模块使用的是AFNetworking第三方库； 本地数据管理使用的是FMDB第三方库； 支持离线推送； 支持微信分享； 支持文件上传、OCR识别； ","date":"131313.1111.1111","permalink":"/works/resume/","section":"Works","summary":"所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.yzong@outlook.com 个人技能\u003e 个人技能 # 6年iOS开发经验(Objective-C / Swift)； 能够独立开发应用，有一定的架构思维； 对内存管理、多线程编程、runtime、runloop、性能优化、AudioUnit等技术有一定的了解； 熟练使用xib、storyboard或代码自动布局； 乐于接受新事物新语言，并有足够的学习动力； 熟练使用MacOS、Xcode开发工具、证书生成、应用上架发布等； svn、git代码管理； 能够简单使用ReactNative、Flutter写界面； 拥有个人博客、Gitbook 有一定的审美能力； 工作经历\u003e 工作经历 # 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今\u003e 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.","title":"简历2022"},{"content":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。\n","date":"131313.1111.1111","permalink":"/works/01/","section":"Works","summary":"由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。","title":"通过控制线程并发数量来优化首页在多设备情况下的表现"},{"content":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….\n","date":"131313.1111.1111","permalink":"/works/03/","section":"Works","summary":"我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….","title":"项目定制优化"},{"content":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。\n","date":"131313.1111.1111","permalink":"/works/04/","section":"Works","summary":"在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。","title":"首页替换第三方组件为系统组件"},{"content":"","date":"303030.66.66","permalink":"/tags/autolayout/","section":"Tags","summary":"","title":"AutoLayout"},{"content":"","date":"303030.66.66","permalink":"/tags/ctmediator/","section":"Tags","summary":"","title":"CTMediator"},{"content":"","date":"303030.66.66","permalink":"/tags/faceid/","section":"Tags","summary":"","title":"FaceID"},{"content":"","date":"303030.66.66","permalink":"/tags/flexbox/","section":"Tags","summary":"","title":"Flexbox"},{"content":"","date":"303030.66.66","permalink":"/tags/ios/","section":"Tags","summary":"","title":"ios"},{"content":"","date":"303030.66.66","permalink":"/series/ios/","section":"Series","summary":"","title":"IOS"},{"content":"整理中\u0026hellip;\u003e 整理中\u0026hellip; # RunLoop与线程\u003e RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。\nvoid const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) { if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); } __CFLock(\u0026amp;loopsLock); if (!__CFRunLoops) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, \u0026amp;kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); #pragma GCC diagnostic push #pragma GCC diagnostic ignored \u0026#34;-Wdeprecated\u0026#34; if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)\u0026amp;__CFRunLoops)) { #pragma GCC diagnostic pop CFRelease(dict); } CFRelease(mainLoop); } CFRunLoopRef newLoop = NULL; CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { newLoop = __CFRunLoopCreate(t); cf_trace(KDEBUG_EVENT_CFRL_LIFETIME|DBG_FUNC_START, newLoop, NULL, NULL, NULL); CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } __CFUnlock(\u0026amp;loopsLock); // don\u0026#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it if (newLoop) { CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) { #if _POSIX_THREADS _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); #else _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, \u0026amp;__CFFinalizeRunLoop); #endif } } return loop; } RunLoop的组成\u003e RunLoop的组成 # 一个 RunLoop 主要由：CFRunLoopMode / CFRunLoopSourceRef / CFRunLoopObserverRef / CFRunLoopTimerRef 组成。 RunLoop 可以拥有多种Mode，Mode中包含 Source / Observer / Timer。 CFRunLoopMode（RunLoop的运行模式）共五类\u003e CFRunLoopMode（RunLoop的运行模式）共五类 # kCFRunLoopDefaultMode App 的默认 Mode，通常主线程是在这个 Mode 下运行\nUITrackingRunLoopMode 界面跟踪Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\nUIInitializationRunLoopMode 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用\nGSEventReceiveRunLoopMode 接受系统事件的内部 Mode，通常用不到\nkCFRunLoopCommonModes 这是一个占位用的 Mode，不是一种真正的 Mode，可以简单理解为 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode 的结合\nCFRunLoopSource（输入源/事件源）\u003e CFRunLoopSource（输入源/事件源） # 这里有两个源：_sources0 、 _sources1 _sources0 即非基于 port 的，也就是用户触发事件，需要手动唤醒线程。将当前线程从 \u0026lsquo;内核态切换到用户态\u0026rsquo; \u0026lsquo;CPU的两种工作状态，内核态可以调度所有的资源，用户态则只可以调度用户工作界面\u0026rsquo; _sources1 基于 port 的，包含一个 mach_port 和一个回调，可以监听系统端口和通过内核态和其他线程发送消息，能主动唤醒 RunLoop，接收分发系统事件，具备唤醒线程能力。\nCFRunLoopTimer（定时源）\u003e CFRunLoopTimer（定时源） # 基于时间的触发器，基本上说的就是 NSTimer。在预设的时间点唤醒 RunLoop 执行回调。因为它是基于 RunLoop 的，因此它不是实时的（就是 NSTimer 是不准确的。 因为 RunLoop 只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致 Timer 本次延时，或者少执行一次）\nCFRunLoopObserver（观察者）\u003e CFRunLoopObserver（观察者） # 可以对 RunLoop 不同状态下进行监听，从而对当前 RunLoop 工作状态进行优化。\nkCFRunLoopEntry RunLoop 准备启动 kCFRunLoopBeforeTimers RunLoop 将要处理一些 Timer 相关事件 kCFRunLoopBeforeSources RunLoop 将要处理一些 Source 事件 kCFRunLoopBeforeWaiting RunLoop 将要进行休眠状态，即将由用户态切换到内核态 kCFRunLoopAfterWaiting RunLoop 被唤醒，即从内核态切换到用户态后 kCFRunLoopExit RunLoop 退出 kCFRunLoopAllActivities 监听所有状态活动 如何设置监听\nRunLoop运行机制\u003e RunLoop运行机制 # 1️⃣ 调用 Observer 监听方法状态为 kCFRunLoopEntry 2️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeTimers 3️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeSources 4️⃣ 处理 Blocks ：__CFRunLoopDoBlocks 5️⃣ 处理 sources0，如果被处理过则再次处理 Blocks ⁉️ 判断是否存在 sources1，如果存在 7️⃣，如果不存在 6️⃣ 6️⃣ 调用 Observer 监听方法状态为 kCFRunLoopBeforeWaiting，并随时等待被 sources1 / dipatch / timer / source0 / 手动唤醒 唤醒，如有，则会：调用 Observer 监听方法状态为 kCFRunLoopAfterWaiting 继续 7️⃣ 7️⃣ 处理 timers 8️⃣ 处理 GCD Main 9️⃣ 处理 sources1 🔟 处理 Blocks ⁉️ 是否还有需要处理的任务？是跳转到 2️⃣ 重新开始， 否则：调用 Observer 监听方法状态为 kCFRunLoopExit\n主线程\u003e 主线程 # 自己能够保活，因为底层判断是根据 modes 是否为空来决定线程是否休眠（销毁），如果是主线程则是个例外，直接返回不为空。非主线程则是根据 _sources0 _sources1 _timers 中是否有数据来判断。 源码如是\n// expects rl and rlm locked static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) { CHECK_FOR_FORK(); if (NULL == rlm) return true; #if TARGET_OS_WIN32 if (0 != rlm-\u0026gt;_msgQMask) return false; #endif #if __HAS_DISPATCH__ Boolean libdispatchQSafe = pthread_main_np() == 1 \u0026amp;\u0026amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY \u0026amp;\u0026amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe \u0026amp;\u0026amp; (CFRunLoopGetMain() == rl) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)) return false; // represents the libdispatch main queue #endif if (NULL != rlm-\u0026gt;_sources0 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources0)) return false; if (NULL != rlm-\u0026gt;_sources1 \u0026amp;\u0026amp; 0 \u0026lt; CFSetGetCount(rlm-\u0026gt;_sources1)) return false; if (NULL != rlm-\u0026gt;_timers \u0026amp;\u0026amp; 0 \u0026lt; CFArrayGetCount(rlm-\u0026gt;_timers)) return false; struct _block_item *item = rl-\u0026gt;_blocks_head; while (item) { struct _block_item *curr = item; item = item-\u0026gt;_next; Boolean doit = false; if (_kCFRuntimeIDCFString == CFGetTypeID(curr-\u0026gt;_mode)) { doit = CFEqual(curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFEqual(curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } else { doit = CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, rlm-\u0026gt;_name) || (CFSetContainsValue((CFSetRef)curr-\u0026gt;_mode, kCFRunLoopCommonModes) \u0026amp;\u0026amp; CFSetContainsValue(rl-\u0026gt;_commonModes, rlm-\u0026gt;_name)); } if (doit) return false; } return true; } 所以如何进行线程保活?\u003e 所以如何进行线程保活? # 只需要在 _sources0 _sources1 _timers 中添加事件，线程就能处于活跃状态。\n线程是保活了，但如果我想停止怎么办？\n如何控制RunLoop\u003e 如何控制RunLoop # RunLoop还解决哪些问题？\u003e RunLoop还解决哪些问题？ # 卡顿\nNSRunLoop VS CFRunLoop CFRunLoop存在于Foundation框架中，使用的是纯C函数实现，相对于NSRunloop，这些C函数API都是线程安全🔐的。\n参考\u003e 参考 # 1 2 3\n","date":"303030.66.66","permalink":"/posts/runloop/","section":"Posts","summary":"整理中\u0026hellip;\u003e 整理中\u0026hellip; # RunLoop与线程\u003e RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。\nvoid const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。","title":"iOS Runloop"},{"content":"","date":"303030.66.66","permalink":"/tags/ios%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/","section":"Tags","summary":"","title":"iOS签名机制"},{"content":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。\n公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？\n混合密码系统(Hybrid Cryptosystem)\u003e 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。\n单向散列函数\u003e 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。\n特点\n根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）\n如何防止数据被篡改\u003e 如何防止数据被篡改 # 本地模型 网络模型 https://www.realvnc.com/en/connect/download/vnc/ 数字签名\u003e 数字签名 # 了解了单向散列函数，就可以理解数字签名，就可以解答之前 \u0026lsquo;遗留的问题\u0026rsquo; \u0026lsquo;B接收到的消息，真的就是A发送的吗？\u0026rsquo;。数字签名就是消息发送者（A）通过私钥加密消息的散列值的到的结果。接受者则（B）可以通过，A的公钥解密签名的到散列值，同时计算的到收到的消息的散列值，如果相等，则确认是（A）发送的消息。\n要注意的是，数字签名不能保证消息的机密性，它是一种验证手段，可能确保消息的来源和内容的真实性（验证散列值）。\n对于主动攻击者，还存在下面的模型的问题：主动攻击者可能伪造公钥，让发送者误以为是接受者的公钥。\n那如何验证公钥的合法性？\n证书(Certificate)\u003e 证书(Certificate) # 公钥证书（Public-key Certificate，PKC），认证机构（Certificate Authority，CA）施加数字签名。通过国际性组织、政府设立的组织、通过提供认证服务来盈利的企业或个人提供认证服务，也就是发送者，和接收者的第三方担保，它可以确保公钥的合法性。 iOS签名机制\u003e iOS签名机制 # iOS的签名机制，可以保证安装到用户手机上的APP都是经过Apple官方允许的。 不管是真机调试，还是发布APP，开发者都需要经过一系列复杂的步骤\n生成 CertificateSigningRequest.certSigningRequest 文件 获得 ios_development.cer\\ios_distribution.cer 证书文件 注册device、添加App ID 获得*.mobileprovision文件 （描述文件） 通过原理来翻译，则是：\n获得Mac电脑公钥 通过Mac公钥，向Apple申请加密，为公钥（证书） 添加设备，账号 向Apple申请将设备账号包装并生成新公钥（描述文件） XCode自动签名已经完成了以上所有步骤。\n.certSigningRequest、.cer、.mobileprovision文件究竟里面包含了什么？有何用处\n","date":"303030.66.66","permalink":"/posts/ios-signing/","section":"Posts","summary":"要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。\n在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密\n加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。\n非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。\n公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？\n混合密码系统(Hybrid Cryptosystem)\u003e 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。\n单向散列函数\u003e 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。\n特点\n根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）","title":"iOS签名机制"},{"content":"","date":"303030.66.66","permalink":"/tags/mach-o/","section":"Tags","summary":"","title":"Mach-O"},{"content":"","date":"303030.66.66","permalink":"/tags/oc/","section":"Tags","summary":"","title":"OC"},{"content":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.h\u0026gt; 创建 pthread_t 对象以及使用\u003e 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(\u0026amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明\nint pthread_create(pthread_t _Nullable * _Nonnull __restrict, const pthread_attr_t * _Nullable __restrict, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable __restrict); 表示线程对象，指向线程标识符的指针 \u0026amp;thread 表示线程属性，可赋值 NULL 表示函数指针，在 thread 线程中要执行的任务 表示函数参数 pthread 其他相关方法\u003e pthread 其他相关方法 # pthread_create() 创建一个线程 pthread_exit() 终止当前线程 pthread_cancel() 中断另外一个线程的运行 pthread_join() 阻塞当前的线程，直到另外一个线程运行结束 pthread_attr_init() 初始化线程的属性 pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合） pthread_attr_getdetachstate() 获取脱离状态的属性 pthread_attr_destroy() 删除线程的属性 pthread_kill() 向线程发送一个信号 NSThread\u003e NSThread # NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread 。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。\n创建、启动线程\u003e 创建、启动线程 # // 1. 创建线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; // 2. 启动线程 [thread start]; // 线程一启动，就会在线程thread中执行self的run方法 // 新线程调用方法，里边为需要执行的任务 - (void)run { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); } 待更新\u0026hellip; 暂时不想更新😭\n","date":"303030.66.66","permalink":"/posts/pthred-nsthread/","section":"Posts","summary":"pthread\u003e pthread # 导入头文件\u003e 导入头文件 # #import \u0026lt;pthread.h\u0026gt; 创建 pthread_t 对象以及使用\u003e 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(\u0026amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@\u0026#34;%@\u0026#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明","title":"pthread / NSThread"},{"content":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。\nFlex Direction\u003e Flex Direction # 在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\ncolumn | 从上到下 row | 从左到右 column-reverse | 从下到上 row-reverse | 从右到左 Layout Direction\u003e Layout Direction # ltr | 从左到右 rtl | 从右到左 justifyContent\u003e justifyContent # 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有：\nflex-start flex-end space-between space-around space-evenly Align Items\u003e Align Items # 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有\nstretch | 填满次轴 flex-start flex-end center baseline Align Self\u003e Align Self # 作用同 Align Items，但是只作用于被定义的对象，不影响容器子对象。\nAlign Content\u003e Align Content # 适用于被折行的子视图，即，设置属性flexWrap时（Wrap）。效果同justifyContent，是次轴上的justifyContent。\nflex-start flex-end space-between space-around space-evenly Flex Wrap\u003e Flex Wrap # wrap no-wrap Flex Basis, Grow, and Shrink\u003e Flex Basis, Grow, and Shrink # flexBasis: 视图在主轴上的宽度（auto，int） flexGrow: 视图在主轴上的生长能力（int），grow较大则会填充容器。 flexShrink: 视图在主轴上的缩小能力（int），shrink较大视图则会根据basis或width的值显示。\n","date":"303030.66.66","permalink":"/posts/rn-flex-layout/","section":"Posts","summary":"这里只是个人学习对官方的Flexbox布局的简单总结以及备忘，内容并不全面，深入学习建议阅读官方文档。\n推荐阅读官网 “使用Flexbox布局”\nFlex\u003e Flex # flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex属性值被分割成多个部分。\nFlex Direction\u003e Flex Direction # 在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\ncolumn | 从上到下 row | 从左到右 column-reverse | 从下到上 row-reverse | 从右到左 Layout Direction\u003e Layout Direction # ltr | 从左到右 rtl | 从右到左 justifyContent\u003e justifyContent # 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有：","title":"React Native Flexbox"},{"content":"","date":"303030.66.66","permalink":"/series/rn/","section":"Series","summary":"","title":"RN"},{"content":"","date":"303030.66.66","permalink":"/tags/runloop/","section":"Tags","summary":"","title":"runloop"},{"content":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","date":"303030.66.66","permalink":"/posts/center-core-mode/","section":"Posts","summary":" 中间管理者，与模块之间约定好的模块名称、方法名称以及参数，通过 Runtime 方法，调用对应对象的方法来获取想要的对象。 实现步骤\u003e 实现步骤 # 自己：中间管理者拥有一套控制逻辑、并制定规则。 增强：模块根据规则封装对外接口，通过添加分类的方式，使得中间管理者能够控制模块相关功能。 项目工程使用中间管理者调度业务、页面、控件等组成APP。 好处\u003e 好处 # 被分成块的页面或组件可以被其他项目很方便的复用，这样大大减少了开发任务量，使开发 APP 过程变成和搭建积木一样。 同时各个模块也是经过验证的，测试的工作也相应的减少。 可以一定程度培养开发人员封装接口能力。 app bug可能相对少，而且查找更为方便， 因为模块可以单独测试，bug的出现一般可以直接指向对应的模块 不好的地方\u003e 不好的地方 # 相比于主项目上直接开发多了接口封装的过程。 对于只负责某一模块开发的人员可能会失去一些对业务的理解。 暂时想到这么多\u0026hellip; ","title":"Target-Action组件化方案CTMediator"},{"content":"","date":"303030.66.66","permalink":"/tags/touchid/","section":"Tags","summary":"","title":"TouchID"},{"content":"","date":"303030.66.66","permalink":"/tags/wwdc/","section":"Tags","summary":"","title":"WWDC"},{"content":"","date":"303030.66.66","permalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"中间人模式"},{"content":"","date":"303030.66.66","permalink":"/tags/%E5%8A%A0%E5%AF%86/","section":"Tags","summary":"","title":"加密"},{"content":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;\nPrivacy - Face ID Usage Description OR\nNSFaceIDUsageDescription 引入相关的库\nLocalAuthentication 引入头文件\n#import \u0026lt;LocalAuthentication/LocalAuthentication.h\u0026gt; 使用\u003e 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.localizedFallbackTitle = @\u0026#34;localizedFallbackTitle\u0026#34;; NSError *error; LAPolicy policy = LAPolicyDeviceOwnerAuthenticationWithBiometrics; if ([context canEvaluatePolicy:policy error:\u0026amp;error]) { [context evaluatePolicy:policy localizedReason:@\u0026#34;通过Home键验证已有指纹\u0026#34; reply:^(BOOL success, NSError * _Nullable error) { if (success) { // success MNLog(self, @\u0026#34; successed!!!\u0026#34;); } else if (error) { MNLog(self, @\u0026#34; face error.code = %@\u0026#34;, error); switch (error.code) { case LAErrorAuthenticationFailed: break; default: break; } } else { // other MNLog(self, @\u0026#34; face id the other reason!!!\u0026#34;); } }]; } else { // error MNLog(self, @\u0026#34;还没有设置id, %@\u0026#34;, error); } } ","date":"303030.66.66","permalink":"/posts/authentication-biometrics/","section":"Posts","summary":"事前准备\u003e 事前准备 # 添加权限请求描述: e.g. \u0026ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者\u0026rdquo;\nPrivacy - Face ID Usage Description OR\nNSFaceIDUsageDescription 引入相关的库\nLocalAuthentication 引入头文件\n#import \u0026lt;LocalAuthentication/LocalAuthentication.h\u0026gt; 使用\u003e 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.","title":"生物认证 TouchID/FaceID"},{"content":"","date":"303030.66.66","permalink":"/tags/%E7%BA%BF%E7%A8%8B/","section":"Tags","summary":"","title":"线程"},{"content":"Mach-O\u003e Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。\nMach-O文件的分类\nExecutable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成\u003e Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)\nHeader\u003e Header # 指明了 CPU 架构、大小端序、文件类型、Load Commands 个数等一些基本信息，Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境，64位架构为例， Header结构定义如下\nstruct mach_header_64 { uint32_t magic; /* mach magic number identifier 魔数，用于快速确认该文件用于64位还是32位 */ cpu_type_t cputype; /* cpu specifier，CPU**类型，比如 arm */ cpu_subtype_t cpusubtype; /* machine specifier，对应的具体类型，比如arm64、armv7 */ uint32_t filetype; /* type of file，文件类型，比如可执行文件、库文件、Dsym文件，demo中是2 `MH_EXECUTE`，代表可执行文件*/ uint32_t ncmds; /* number of load commands 加载命令条数 */ uint32_t sizeofcmds; /* the size of all the load commands 所有加载命令的大小 */ uint32_t flags; /* flags 标志位 */ uint32_t reserved; /* reserved 保留字段 */ }; filetype\nOBJECT，指的是 .o 文件或者 .a 文件； EXECUTE，指的是 IPA 拆包后的文件； DYLIB，指的是 .dylib 或 .framework 文件； DYLINKER，指的是动态链接器； DSYM，指的是保存有符号信息用于分析闪退信息的文件。 待更新\u0026hellip; 感觉还没学会😭\nLLVM-NM\u003e LLVM-NM # 参考 了解Mach-O文件 2\n","date":"303030.66.66","permalink":"/posts/link-symbol/","section":"Posts","summary":"Mach-O\u003e Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。\nMach-O文件的分类\nExecutable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成\u003e Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)","title":"链接与符号 Link\u0026Symbol"},{"content":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。\n避免操作updateConstants()\u003e 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。\nfunc updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系\u003e 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。\n无需视图时使用hideen属性，而不是删除约束\u003e 无需视图时使用hideen属性，而不是删除约束 # 通过激活或停用改变视图，而不是修改约束。\u003e 通过激活或停用改变视图，而不是修改约束。 # UILabe、UIImageView、自动测量尺寸并不会消耗多少性能。 如果需要频繁计算视图尺寸或已经知道该视图尺寸可以重写属性，提高部分性能。 override var intrinsicContentSize: CGSize { return CGSize(width: UIView.noIntrinsicMetric, height: UIView.noIntrinsicMetric) } 想了解的更多可以看 WWDC18: High Performance Auto Layout 相关视频、资料。\n","date":"303030.66.66","permalink":"/posts/high-performance-autolayout/","section":"Posts","summary":"以下是看完 WWDC18: High Performance Auto Layout 的简单总结。\n避免操作updateConstants()\u003e 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。\nfunc updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系\u003e 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。","title":"高性能的AutoLayout"},{"content":"","date":"131313.66.66","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"1011.11.11","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1011.11.11","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1011.11.11","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"}]