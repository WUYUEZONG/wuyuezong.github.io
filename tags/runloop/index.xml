<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>runloop on a half fish</title><link>/tags/runloop/</link><description>Recent content in runloop on a half fish</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 30 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/runloop/index.xml" rel="self" type="application/rss+xml"/><item><title>iOS Runloop</title><link>/posts/runloop/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/runloop/</guid><description>整理中&amp;hellip;> 整理中&amp;hellip; # RunLoop与线程> RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。
void const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。</description></item></channel></rss>