<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WorkNote on a half fish</title><link>/tags/worknote/</link><description>Recent content in WorkNote on a half fish</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/worknote/index.xml" rel="self" type="application/rss+xml"/><item><title>Works</title><link>/works/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/</guid><description/></item><item><title>WZPageViewController</title><link>/works/06/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/06/</guid><description>头文件> 头文件 # 使用传统MVC的设计模式，通过 dataSource delegate 完成数据接入和动作交互。当然也提供一些基本属性快速方便的设置样式，比如：WZPageMenuItemStyle 标题按钮样式的基本设置。
@interface WZPageContentViewController : UIViewController @property (weak, nonatomic) id&amp;lt;WZPageContentViewControllerDataSource&amp;gt; dataSource; @property (weak, nonatomic) id&amp;lt;WZPageContentViewControllerDelegate&amp;gt; delegate; @property (strong, nonatomic, readonly) UIPageViewController *pageController; @property (strong, nonatomic, readonly) __kindof UIViewController *selectedController; @property (assign, nonatomic, readonly) NSInteger selectedIndex; @property(nonatomic) WZPageMenuItemStyle *selectedStyle; @property(nonatomic) WZPageMenuItemStyle *normalStyle; /// 是否展示分割线 @property(nonatomic) BOOL showDividingLine; /// 是否展示位置指示器 @property(nonatomic) BOOL showIndicator; - (void)reloadDataAt:(NSInteger)index; /// 刷新菜单栏 - (void)reloadMenus; - (void)registerClass:(Class)aClass identifier:(nonnull NSString *)identifier; - (void)registerNib:(UINib *)nib identifier:(NSString *)identifier; @end 设计结果肯定是以业务为依托，搭建基础框架，然后在条条框框里填写需求。所以先看一下代理设置了些啥，最后再拆解整个结构。</description></item><item><title>封装AI算法升级或切换</title><link>/works/07/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/07/</guid><description>首先AI算法升级或切换的过程需要多个地方监听，所以不能仅在升级页面上写监听逻辑，封装起来使得多个页面都能有能力接收升级回调。
那么这个时候首先会想到单例，在已有的单例中扩充该功能。
需求点> 需求点 # 升级/切换过程及完成首页封面需要变更状态，那么就需要一个容器存储正在升级/切换的设备。 需要监听设备状态反馈到界面上； 如果当前处于升级页面需要显示升级过程； 如果当前处于ai列表，升级完成要及时更新列表； 如果当前处于首页，升级完成要及时更新封面； &amp;hellip; 其他页面优先级不高，暂不考虑 实现> 实现 # 这里可能涉及多台设备更新，所以在单例内部管理一个数组，存储升级中的设备基本信息
SN：可以在回调中判断当前是哪台设备（多设备情况下） 升级/切换信息：设备重启后校验版本或ID判断成功与否 回调记录：回调过长（多）大概率设备没有重启，或其他错误，判断为超时，停止计时器 定时器> 定时器 # 需要持续获取设备信息，那么定时器必不可少，当然它的任务必须在异步执行，防止堵塞主线。
调用设备状态 如果有状态直接输出给回调 如果没有状态，那么设备大概率是断开了，在升级或重启，这个时候需要请求设备算法包信息，不过不需要频繁请求，可以在非主线程中使用同步堵塞调用。一旦设备响应，比对版本信息判断是否升级成功。 以上，升级过程即封装完毕，只需在对应页面启动定时器并实现回调。
回调> 回调 # 在回调时给出相应页面所需参数即可。</description></item><item><title>时长云存逻辑梳理优化</title><link>/works/02/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/02/</guid><description>当时有这样一个需求，用户可以设置当天的某个时间段，进行录像任务，当用户设置的时间段时，已设置过的时间段需要置灰不可选，这里时间段涉及两个点，一是开始时间，二是时长，而时长的设置是有限制的，它不能超过下一个计划的开始时间，不能大于剩余可设置时长，不大于剩余可设置时长，这个判断很简单，难点在于，根据给出的开始时间找到下一个录像的开始时间，最后计算出可设置时长。 一开始的想法是，把数据分为了，天、时对象。天包含所有不可用的小时及对应的小时对象，小时包含当前小时被占用的分钟区间。 这样在封装数据的时候，小时默认有个初始60分钟，根据被占用分钟区间相减，如果初始值被减到0则表示该小时不可用🚫。天的对象不可用就比较简单，如果小时对象数量小于24表示可用，如果等于24则找到可用的小时，没找到则当天不可用。 至此，解决了页面对应天，小时，分钟的颜色置灰显示。还剩下一个问题，计算可设置的时长。 所以根据数据封装的格式，很自然的把用户选定的开始时间分为，小时和分钟，先从小时开始找，如果当天不可用的小时不包含选定的小时，那处理比较简单，将数据排好序，找到第一个大于当前小时的数据，做减法，得出的时间就是可设置时才，不过这里就要注意⚠，没找到要从跨天数据数据中找。 另一种情况，如果当天不可用的小时包含选定的小时，这里就要判断选定的分钟在当前小时哪个位置，如果在最后，这又要处理跨小时数据。 想想就很复杂，后来再看这里的代码终于想通，其实，就是给定一个开始时间，找到刚好比开始时间大的数据，然后做个减法的问题。时间对比除了可以逐级对比小时、分钟，还可以直接将小时换算成分钟，然后对比分钟啊。所以把不可用的时间段铺平再一天的时间线上，这样对比就简单得多了。就没有跨小时的说法了。而跨天，只需查一下第二天是否有计划，拿到第一个计划时间段，加入当天就行了。
豁然开朗！😊
用原数据对比简直简单…😓！！！</description></item><item><title>第三方登陆会请求两次的问题</title><link>/works/05/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/05/</guid><description>通过bug复现可以得到，该方法确实被调用两次，有的时候甚至会更多，导致这个bug的主要原因是该方法的调用是通过“发送通知”调用，也就是广播，所以只要该通知发出，注册个该通知的对象，都能接收得到，所以就出现会调用两次，甚至多次。代码中存在退出登陆，重新构建新的登陆页面，而旧的页面没有被释放，这样就会存在页面上虽然只展示一个页面，但内存中实际存在两个对象。解决该bug则需要释放调旧的对象，以及考虑这个方法的调用真的需要使用通知的方式吗？从一开始使用通知的角度来讲，确实这种方式很方便，但后期接手的人更改这里的业务逻辑或许因为没考虑到这个问题，拷贝了一份代码，改改做新需求，这就会导致意想不到的问题存在。我梳理了一下调用逻辑，其实只需要使用回调来处理调用。并且整理的代理对象，让只要写一份的代码，就只写一份。</description></item><item><title>简历2022</title><link>/works/resume/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/resume/</guid><description>所在地：杭州（余杭） 毕业于：211南昌大学软件工程系（2012 ～ 2016） 联系我：13037241933（同微信） 邮件我：w.yzong@outlook.com 个人技能> 个人技能 # 6年iOS开发经验(Objective-C / Swift)； 能够独立开发应用，有一定的架构思维； 对内存管理、多线程编程、runtime、runloop、性能优化、AudioUnit等技术有一定的了解； 熟练使用xib、storyboard或代码自动布局； 乐于接受新事物新语言，并有足够的学习动力； 熟练使用MacOS、Xcode开发工具、证书生成、应用上架发布等； svn、git代码管理； 能够简单使用ReactNative、Flutter写界面； 拥有个人博客、Gitbook 有一定的审美能力； 工作经历> 工作经历 # 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.07 ～ 至今> 杭州蛮牛网络技术有限公司iOS(OC)开发 - 杭州 - 2021.</description></item><item><title>通过控制线程并发数量来优化首页在多设备情况下的表现</title><link>/works/01/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/01/</guid><description>由于之前的代码对于异步任务都是简单的丢到 global 线程中，导致当设备达到一定数量后，子线程不受控制，使 app 卡顿。通过该用NSOperationQueue 来控制线程的并发数量，有效的解决了，多设备的卡顿问题。</description></item><item><title>项目定制优化</title><link>/works/03/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/03/</guid><description>我简化了定制流程，以前需要翻找旧代码去依据情况定制，。。。 统一改成在代码中根据bundleid判断显示或其他….</description></item><item><title>首页替换第三方组件为系统组件</title><link>/works/04/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>/works/04/</guid><description>在了解大概的业务逻辑和代码的情况后，首先是有想法进行重构，但是并没有鲁莽的直接去大刀阔斧的修改代码，二十先对目前冗余代码进行抽象，减少繁杂的代码，使整体更容易阅读，对理解到的点进行添加注释，通过一步一步的整理，以便于后期对该项业务或功能点进行重构，比如：首页，之前的代码为了实现一个简单的则掉效果，引入了复杂的第三方组件，使用该组件还需另外封装数据去适配，显然得不偿失，多浪费一份内存不说，后期需求的适配也极难维护，考虑到该效果如果使用系统组件是十分容易实现的，所以对业务足够了解后，就立马着手重构，同样因为之前就对这块代码进行了整理，所以整个重构过程可以说是十分轻松。</description></item></channel></rss>