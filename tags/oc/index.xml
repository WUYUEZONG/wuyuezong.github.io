<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OC on a half fish</title><link>/tags/oc/</link><description>Recent content in OC on a half fish</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Mon, 14 Nov 2022 14:48:46 +0800</lastBuildDate><atom:link href="/tags/oc/index.xml" rel="self" type="application/rss+xml"/><item><title>Category</title><link>/posts/oc/category/</link><pubDate>Mon, 14 Nov 2022 14:48:46 +0800</pubDate><guid>/posts/oc/category/</guid><description>category定义在objc-runtime-new.h中，结构如下：
所以定义在分类中的属性、对象方法、类方法、协议等数据会被编译成和 class 对象中一样的数据类型，只使用了新的变量存储。在 runtime时，分类中的数据（属性、方法、协议）会被合并到原来的类、元类中。所以对象调用分类中的数据（属性、方法、协议）理论上是和调用类中的方法是一致的（isa）。 知识点> 知识点 # 后编译的先调用> 后编译的先调用 # 多个分类中如果存在相同的方法，编译顺序决定调用那个。后编译的先调用。</description></item><item><title>@synthesize, @dynamic</title><link>/posts/oc/synthesize-dynamic/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/synthesize-dynamic/</guid><description>@synthesize是给属性添加别名，并生成get、set方法（默认使用）
@interface ViewController : UIViewController @property (assign, nonatomic) int age; @end @implementation ViewController // 此时在.</description></item><item><title>+initialize</title><link>/posts/oc/initialize/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/initialize/</guid><description>initialize是类第一次接收到消息时调用的( [类 alloc]的时候)，每个类只会调用initialize一次（父类的initialize方法可能会被多调用），initialize是通过objc_msgSend调用的。 initialize调用顺序> initialize调用顺序 # 先出初始化父类 再初始化子类（可能最终调用的是父类的initialize方法，因为是通过isa指针，superclass指针去寻找方法调用的） initialize底层实现伪代码> initialize底层实现伪代码 # @interface Person @end @interface Student: Person @end void lookUpImpOrNil() { //Student类没有初始化 if !</description></item><item><title>+load方法</title><link>/posts/oc/load/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/load/</guid><description>+load是runtime加载类、分类时调用（只会调用1次）+load是根据函数地址直接调用的。 load调用顺序> load调用顺序 # 先调用类的+load 先编译的类优先调用 Category（分类） 调用子类的+load之前，会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译。先调用） 阅读源码（objc4）> 阅读源码（objc4） # objc-os.</description></item><item><title>AssociationObject关联对象</title><link>/posts/oc/association-object/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/association-object/</guid><description>AssociationObject关联对象的原理> AssociationObject关联对象的原理 # 实现关联对象技术的核心对象有
AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation // 关系伪代码 class AssociationsManager { static AssociationsHashMap *_map; }; class AssociationsHashMap: public unordered_map&amp;lt;disguised_ptr_t, ObjectAssociationMap&amp;gt; class ObjectAssociationMap: public std::map&amp;lt;void *, ObjcAssociationMap&amp;gt; class ObjcAssociationMap { uintptr_t _policy; id _value; }; 关联对象的结构> 关联对象的结构 # 关联对象不是存储在被关联对象本身的内存中 关联对象存储在全局的统一的一个AssociationsManager中 设置关联对象为nil，就相当于是移除关联对象 class property AssociationsManager _map: AssociationsHashMap AssociationsHashMap @{disguised_ptr_t: ObjectAssociationMap} ObjectAssociationMap @{void*: ObjcAssociation} ObjcAssociation values OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY AssociationObject关联对象的使用> AssociationObject关联对象的使用 # 关联对象常用API> 关联对象常用API # 添加关联对象</description></item><item><title>AutoreleasePool</title><link>/posts/oc/autorelease-pool/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/autorelease-pool/</guid><description>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage；调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的 AutoreleasePoolPage内部结构> AutoreleasePoolPage内部结构 # 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址 所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起 @autoreleasepool 作用原理> @autoreleasepool 作用原理 # @autoreleasepool { NSObject *obj = [[[NSObject alloc] init] autorelease]; } // 以上代码可以被解释为 { // atautoreleasepoolobj = 0x1038 atautoreleasepoolobj = objc_autoreleasePoolPush(); NSObject *obj = [[[NSObject alloc] init] autorelease]; objc_autoreleasePoolPop(0x1038); } 在大括号开始时将autorelease对象地址push进AutoreleasePoolPage，在大括号结束时pop出来。</description></item><item><title>Block</title><link>/posts/oc/block/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/block/</guid><description>Block的本质> Block的本质 # block本质上也是一个OC对象，它内部也有个isa指针，block是封装了函数调用以及函数调用环境的OC对象。
block的底层结构> block的底层结构 # block的变量捕获（capture）> block的变量捕获（capture） # 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</description></item><item><title>pthread / NSThread</title><link>/posts/pthred-nsthread/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/pthred-nsthread/</guid><description>pthread> pthread # 导入头文件> 导入头文件 # #import &amp;lt;pthread.</description></item><item><title>安装包瘦身</title><link>/posts/oc/ipa/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/ipa/</guid><description>资源（图片、音频、视频等）> 资源（图片、音频、视频等） # 采取无损压缩 去除没有用到的资源： https://github.</description></item><item><title>定时器</title><link>/posts/oc/nstimer/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/nstimer/</guid><description>NSTimer、CADisplayLink定时器> NSTimer、CADisplayLink定时器 # CADisplayLink使用
@interface TMViewController () @property (strong, nonatomic) CADisplayLink * link; @end - (void)viewDidLoad { [super viewDidLoad]; _link = [CADisplayLink displayLinkWithTarget:(id)target selector:@selector(linkTest)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; } - (void)dealloc { [_link invalidate]; } NSTimer使用</description></item><item><title>性能优化</title><link>/posts/oc/performance-optimization/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/performance-optimization/</guid><description>在屏幕成像的过程中，CPU和GPU起着至关重要的作用
查看详情 CPU和GPU> CPU和GPU # CPU（Central Processing Unit，中央处理器）</description></item><item><title>探究UIViewController生命周期</title><link>/posts/oc/uiviewcontroller-life-cycle/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/uiviewcontroller-life-cycle/</guid><description>进入 ViewController2
+[ViewController2 load] // 加载时就会调用 +[ViewController2 initialize] // 第一次接收通知时调用(alloc) -[ViewController2 loadView] -[ViewController2 viewDidLoad] -[ViewController viewWillDisappear:] -[ViewController2 viewWillAppear:] -[ViewController2 viewWillLayoutSubviews] -[ViewController2 viewDidLayoutSubviews] -[ViewController viewDidDisappear:] -[ViewController2 viewDidAppear:] 返回 ViewController</description></item><item><title>数据持久化、缓存</title><link>/posts/oc/data-store/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/oc/data-store/</guid><description>首先了解以下应用沙盒文件夹，了解每个文件夹的具体作用，就能更方便于我们如何存储应用生成的数据。
应用沙盒文件夹> 应用沙盒文件夹 # Application（应用程序包）：包含了所有资源文件和可执行文件，上架前会经过数字签名，上架后就不可修改。</description></item><item><title>APP启动</title><link>/posts/oc/app-lanuch/</link><pubDate>Mon, 13 Jun 2022 20:55:37 +0100</pubDate><guid>/posts/oc/app-lanuch/</guid><description>APP启动的分类> APP启动的分类 # 冷启动> 冷启动 # 冷启动（Cold Launch）：从零开始启动APP</description></item></channel></rss>