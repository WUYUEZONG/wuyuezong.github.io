<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ios on a half fish</title><link>/tags/ios/</link><description>Recent content in ios on a half fish</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 30 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>iOS Runloop</title><link>/posts/runloop/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/runloop/</guid><description>整理中&amp;hellip;> 整理中&amp;hellip; # RunLoop与线程> RunLoop与线程 # RunLoop 和线程是一一对应关系，在源码中，线程和 Runloop 互为一对 Key、Value，可以关注一下 loop 的获取：是把线程地址作为key来获取RunLoop的。
void const *CFDictionaryGetValue(CFDictionaryRef hc, void const *key) {...} // ... CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); 通过这里也可以知道，RunLoop 中是没有提供创建的API，只需要通过在线程内部获取当前 RunLoop 就会自动创建（主线程除外）。</description></item><item><title>iOS签名机制</title><link>/posts/ios-signing/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/ios-signing/</guid><description>要了解iOS签名，首先得从加密入手，了解对称加密、非对称加密、公钥密码、单向散列函数等名词，这些名词一抛出，可能你云里雾里了，但是不急，学习是需要过程的，下面对这些名词一一介绍。
在学之前我们先通过简单模型理解为什么要加密？A给B发送消息，那么如果有不法分子就想知道A发给B是什么内容，那么就会产生窃听 对称加密
加密和解密的密钥相同即为对称加密。它的特点是：加密解密快、传输不安全。
非对称加密(公钥加密) 加密和解密的密钥不同即为非对称加密。加密解密较慢，相比对称加密更安全。
公钥密码 公钥密码中包含一对密码：加密密钥、解密密钥(公钥，私钥)。公钥是可公开的密钥。 公钥加密是为了解决密钥配送问题，通过简单模型理解： B生成密钥对，并把公钥发送给A，A通过 B的公钥加密消息得到密文，然后发送给B ，B得到密文，通过自己的私钥解密密文就得到了消息。 整个过程没有私钥的泄漏，所以数据传输是安全的，但是想一下： B接收到的消息，真的就是A发送的吗？
混合密码系统(Hybrid Cryptosystem)> 混合密码系统(Hybrid Cryptosystem) # 同时结合对称加密的快的有点和非对称加密安全的优点的加密方式。 在混合密码系统中，会多出一个会话密钥(session key)，它用于加密和解密消息（对称加密），结合上面的例子，B给的公钥，用来加密会话密钥A同时发送，会话密钥加密的消息和公钥加密的会话密钥给B，那么 B则通过私钥解密得到会话密钥，在用会话密钥解密密文得到消息。
单向散列函数> 单向散列函数 # 单向散列函数，可以根据根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值。
特点
根据任意长度的消息，计算出固定长度的散列值 计算速度快，能快速计算出散列值 消息不同，散列值也不同（哪怕只有1bit的区别也会产生完全不同的散列值） 具备单向性（散列值无法还原为原始文件）</description></item><item><title>pthread / NSThread</title><link>/posts/pthred-nsthread/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/pthred-nsthread/</guid><description>pthread> pthread # 导入头文件> 导入头文件 # #import &amp;lt;pthread.h&amp;gt; 创建 pthread_t 对象以及使用> 创建 pthread_t 对象以及使用 # - (void)viewDidLoad { [super viewDidLoad]; // 申明变量 pthread_t thread; // 开启现场，执行任务 pthread_create(&amp;amp;thread, NULL, run, NULL); // 设置子线程状态为 detach, 该线程运行结束后会自动释放所有资源 pthread_detach(thread); } void *run(void *param) { NSLog(@&amp;#34;%@&amp;#34;, [NSThread currentThread]); return NULL; } pthread_create 函数参数说明</description></item><item><title>中间人模式 (CTMediator) 分析</title><link>/posts/center-core-mode/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/center-core-mode/</guid><description>组件化> 组件化 # 关于组件化开发，在我的理解里，它一直都是，应用主体去协调各个 pod 。
理解： 如果在一个大型项目中， 首先根据项目去化分业务 (业务1， 业务2， 业务3，&amp;hellip;) 每个业务给到开发人员，开发人员根据业务去开发相应的功能，那么这个过程中，肯定会有不同业务中的相识功能，就比如，业务1，网络请求用A库而业务2用的是B库，那么其实A库、B库能做的事情是一样的，选择较好的就行，所以就要提前制定规则，把应用分层，不至于造成这样的代码冗余，我的想法是分为三层：
首先是基础模块，一般通用切必要的服务可以归类在这一层，比如网络和存储。 其次是业务组件，就是单个UI层面的通用组件，它可以供各个业务模块使用。 最后是业务层，他们是某一业务的完整功能，比如账号、支付、埋点等等。 那么还有一个分工问题。应用层次为三层，是不是对应分人做就是？</description></item><item><title>生物认证 TouchID/FaceID</title><link>/posts/authentication-biometrics/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/authentication-biometrics/</guid><description>事前准备> 事前准备 # 添加权限请求描述: e.g. &amp;ldquo;App需要TouchID或FaceID权限，来验证使用者是否是手机所有者&amp;rdquo;
Privacy - Face ID Usage Description OR
NSFaceIDUsageDescription 引入相关的库
LocalAuthentication 引入头文件
#import &amp;lt;LocalAuthentication/LocalAuthentication.h&amp;gt; 使用> 使用 # - (void)faceID { LAContext *context = [LAContext new]; context.</description></item><item><title>链接与符号 Link&amp;Symbol</title><link>/posts/link-symbol/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/link-symbol/</guid><description>Mach-O> Mach-O # Mach-O格式全称为Mach Object文件格式的缩写，是MacOS或者iOS上可执行的程序格式，类似于Windows上的PE格式 (Portable Executable)，linux上的ELF格式 (Executable and Linking Format)。
Mach-O文件的分类
Executable 应用可执行文件 Dylib Library 动态链接库（又称DSO或DLL） Static Library 静态链接库 Bundle 不能被链接的Dylib，只能在运行时使用dlopen( )加载，可当做macOS的插件 Relocatable Object File 可重定向文件类型 Mach-O文件的组成> Mach-O文件的组成 # Mach-O文件主要包括三部分内容： Header(头部)、Load Commands(加载命令)、Data(数据区)</description></item><item><title>高性能的AutoLayout</title><link>/posts/high-performance-autolayout/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>/posts/high-performance-autolayout/</guid><description>以下是看完 WWDC18: High Performance Auto Layout 的简单总结。
避免操作updateConstants()> 避免操作updateConstants() # 避免操作updateConstants() ，它的调用频次是 120次/s ，如果需要在updateConstants()中操作布局，尽量只布局未设置约束的视图。
func updateConstants() { if constants == nil { // set constants. } super.updateConstants() } 尽量少而简单的视图依赖关系> 尽量少而简单的视图依赖关系 # 设置约束时，尽量只依赖父视图，多个依赖关系可能会造成更多的计算量，而只依赖一个父试图，则只是需要的计算。</description></item></channel></rss>